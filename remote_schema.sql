

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE SCHEMA IF NOT EXISTS "public";


ALTER SCHEMA "public" OWNER TO "pg_database_owner";


COMMENT ON SCHEMA "public" IS 'Sistema de presupuestos con conversión a facturas - Compatible con Veri*Factu';



CREATE TYPE "public"."campaign_status" AS ENUM (
    'draft',
    'scheduled',
    'sent'
);


ALTER TYPE "public"."campaign_status" OWNER TO "postgres";


CREATE TYPE "public"."campaign_trigger_type" AS ENUM (
    'manual',
    'birthday',
    'inactivity'
);


ALTER TYPE "public"."campaign_trigger_type" OWNER TO "postgres";


CREATE TYPE "public"."campaign_type" AS ENUM (
    'email',
    'whatsapp',
    'sms'
);


ALTER TYPE "public"."campaign_type" OWNER TO "postgres";


CREATE TYPE "public"."consent_status" AS ENUM (
    'pending',
    'accepted',
    'rejected',
    'revoked'
);


ALTER TYPE "public"."consent_status" OWNER TO "postgres";


CREATE TYPE "public"."content_status" AS ENUM (
    'idea',
    'copy',
    'design',
    'review',
    'scheduled',
    'published'
);


ALTER TYPE "public"."content_status" OWNER TO "postgres";


CREATE TYPE "public"."invitation_status" AS ENUM (
    'not_sent',
    'sent',
    'opened',
    'completed'
);


ALTER TYPE "public"."invitation_status" OWNER TO "postgres";


CREATE TYPE "public"."invoice_status" AS ENUM (
    'draft',
    'sent',
    'paid',
    'partial',
    'overdue',
    'cancelled',
    'void',
    'approved',
    'issued',
    'rectified'
);


ALTER TYPE "public"."invoice_status" OWNER TO "postgres";


COMMENT ON TYPE "public"."invoice_status" IS 'draft, sent, paid, partial, overdue, cancelled, approved, issued, rectified';



CREATE TYPE "public"."invoice_type" AS ENUM (
    'normal',
    'simplified',
    'rectificative',
    'summary'
);


ALTER TYPE "public"."invoice_type" OWNER TO "postgres";


CREATE TYPE "public"."lead_source" AS ENUM (
    'web_form',
    'doctoralia',
    'top_doctors',
    'whatsapp',
    'phone',
    'referral',
    'other',
    'google_ads',
    'instagram_ads',
    'tiktok_ads',
    'email_marketing'
);


ALTER TYPE "public"."lead_source" OWNER TO "postgres";


CREATE TYPE "public"."lead_status" AS ENUM (
    'new',
    'contacted',
    'no_answer',
    'meeting_scheduled',
    'won',
    'lost'
);


ALTER TYPE "public"."lead_status" OWNER TO "postgres";


CREATE TYPE "public"."module_status" AS ENUM (
    'activado',
    'desactivado',
    'en_desarrollo'
);


ALTER TYPE "public"."module_status" OWNER TO "postgres";


CREATE TYPE "public"."note_decrypted" AS (
	"id" "uuid",
	"client_id" "uuid",
	"company_id" "uuid",
	"author_id" "uuid",
	"created_at" timestamp with time zone,
	"content" "text",
	"author_name" "text"
);


ALTER TYPE "public"."note_decrypted" OWNER TO "postgres";


CREATE TYPE "public"."payment_method" AS ENUM (
    'cash',
    'bank_transfer',
    'card',
    'direct_debit',
    'paypal',
    'other'
);


ALTER TYPE "public"."payment_method" OWNER TO "postgres";


CREATE TYPE "public"."quote_status" AS ENUM (
    'draft',
    'sent',
    'viewed',
    'accepted',
    'rejected',
    'expired',
    'invoiced',
    'cancelled',
    'paused',
    'pending',
    'request',
    'active'
);


ALTER TYPE "public"."quote_status" OWNER TO "postgres";


CREATE TYPE "public"."stage_category" AS ENUM (
    'open',
    'in_progress',
    'completed',
    'on_hold'
);


ALTER TYPE "public"."stage_category" OWNER TO "postgres";


CREATE TYPE "public"."waitlist_status" AS ENUM (
    'pending',
    'notified',
    'prioritized',
    'expired',
    'converted'
);


ALTER TYPE "public"."waitlist_status" OWNER TO "postgres";


CREATE TYPE "public"."workflow_category" AS ENUM (
    'cancel',
    'waiting',
    'analysis',
    'action',
    'final'
);


ALTER TYPE "public"."workflow_category" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."accept_company_invitation"("p_invitation_token" "text", "p_auth_user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_invitation record;
  v_user_id uuid;
  v_role_id uuid;
  v_company_name text;
BEGIN
  -- 1. Validate Invitation
  SELECT i.*, c.name as company_name
  INTO v_invitation
  FROM public.company_invitations i
  JOIN public.companies c ON c.id = i.company_id
  WHERE i.token = p_invitation_token
    AND i.status = 'pending';

  IF v_invitation.id IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Invalid or expired invitation');
  END IF;

  -- 2. Validate User (public.users)
  SELECT id INTO v_user_id FROM public.users WHERE auth_user_id = p_auth_user_id;
  
  IF v_user_id IS NULL THEN
     RETURN json_build_object('success', false, 'error', 'User not found in public registry');
  END IF;

  -- 3. Resolve Role ID
  SELECT id INTO v_role_id FROM public.app_roles WHERE name = v_invitation.role;

  IF v_role_id IS NULL THEN
     -- Fallback: If role not found, default to 'member' or 'client' based on string
     IF v_invitation.role = 'client' THEN
        SELECT id INTO v_role_id FROM public.app_roles WHERE name = 'client';
     ELSE
        SELECT id INTO v_role_id FROM public.app_roles WHERE name = 'member';
     END IF;
  END IF;

  -- 4. LINK CLIENT (Specific for 'client' role)
  IF v_invitation.role = 'client' THEN
      -- Link the existing client record to the new auth user
      UPDATE public.clients
      SET 
        auth_user_id = p_auth_user_id,
        is_active = true,
        updated_at = now()
      WHERE 
        email = v_invitation.email 
        AND company_id = v_invitation.company_id;
      
      -- Add to company_members using role_id
      INSERT INTO public.company_members (
          user_id,
          company_id,
          role_id,
          status
      ) VALUES (
          v_user_id,
          v_invitation.company_id,
          v_role_id,
          'active'
      )
      ON CONFLICT (user_id, company_id) DO UPDATE
      SET role_id = v_role_id, status = 'active', updated_at = now();

  ELSE
      -- For non-clients (admin/member)
      INSERT INTO public.company_members (
          user_id,
          company_id,
          role_id,
          status
      ) VALUES (
          v_user_id,
          v_invitation.company_id,
          v_role_id,
          'active'
      )
      ON CONFLICT (user_id, company_id) DO UPDATE
      SET role_id = v_role_id, status = 'active', updated_at = now();
  END IF;

  -- 5. Update users table (Context Switch) using app_role_id
  UPDATE public.users
  SET 
    company_id = v_invitation.company_id,
    app_role_id = v_role_id,
    updated_at = now()
  WHERE id = v_user_id;

  -- 6. Mark Invitation as Accepted (using responded_at instead of updated_at)
  UPDATE public.company_invitations
  SET status = 'accepted', responded_at = now()
  WHERE id = v_invitation.id;

  RETURN json_build_object(
    'success', true, 
    'company_id', v_invitation.company_id, 
    'company_name', v_invitation.company_name,
    'role', v_invitation.role
  );
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."accept_company_invitation"("p_invitation_token" "text", "p_auth_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."accept_company_invitation_admin"("p_invitation_token" "text", "p_auth_user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    inv public.company_invitations;
    existing_user public.users;
    placeholder_user public.users;
    new_user_id uuid;
    company_name text;
    v_role_id uuid;
BEGIN
    SELECT * INTO inv
    FROM public.company_invitations
    WHERE token = p_invitation_token
      AND expires_at > NOW()
    ORDER BY created_at DESC
    LIMIT 1;

    IF NOT FOUND THEN
        RETURN json_build_object('success', false, 'error', 'Invalid or expired invitation');
    END IF;

    SELECT name INTO company_name FROM public.companies WHERE id = inv.company_id;

    -- Map text role to role_id
    SELECT id INTO v_role_id FROM public.app_roles WHERE name = inv.role;
    IF v_role_id IS NULL THEN
        -- Fallback for legacy 'client' role if not in app_roles (should be there)
        IF inv.role = 'client' THEN
           SELECT id INTO v_role_id FROM public.app_roles WHERE name = 'client';
        END IF;
    END IF;

    SELECT * INTO existing_user FROM public.users WHERE auth_user_id = p_auth_user_id LIMIT 1;
    
    IF FOUND THEN
        -- Link existing user
        UPDATE public.users
           SET email = COALESCE(inv.email, existing_user.email),
               active = true,
               company_id = inv.company_id, -- Set primary company
               updated_at = NOW()
         WHERE id = existing_user.id
         RETURNING id INTO new_user_id;
    ELSE
        -- Helper logic for placeholder
        SELECT * INTO placeholder_user
          FROM public.users
         WHERE email = inv.email AND company_id = inv.company_id
         ORDER BY created_at DESC
         LIMIT 1;

        IF FOUND THEN
            UPDATE public.users
               SET auth_user_id = p_auth_user_id,
                   active = true,
                   updated_at = NOW()
             WHERE id = placeholder_user.id
             RETURNING id INTO new_user_id;
        ELSE
            INSERT INTO public.users (
                email, name, surname, active, company_id, auth_user_id, permissions
            ) VALUES (
                inv.email,
                split_part(inv.email, '@', 1),
                NULL,
                true,
                inv.company_id,
                p_auth_user_id,
                '{}'::jsonb
            ) RETURNING id INTO new_user_id;
        END IF;
    END IF;

    -- Upsert Company Member
    INSERT INTO public.company_members (user_id, company_id, role_id, status)
    VALUES (new_user_id, inv.company_id, v_role_id, 'active')
    ON CONFLICT (user_id, company_id) DO UPDATE
    SET role_id = EXCLUDED.role_id, status = 'active', updated_at = NOW();

    UPDATE public.company_invitations
       SET status = 'accepted', responded_at = NOW()
     WHERE id = inv.id;

    UPDATE public.pending_users
       SET confirmed_at = NOW(), company_id = inv.company_id
     WHERE auth_user_id = p_auth_user_id AND email = inv.email;

    RETURN json_build_object(
        'success', true,
        'user_id', new_user_id,
        'company_id', inv.company_id,
        'company_name', company_name,
        'role', inv.role
    );
EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."accept_company_invitation_admin"("p_invitation_token" "text", "p_auth_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."accept_company_invitation_by_email"("p_email" "text", "p_auth_user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  inv public.company_invitations;
  existing_user public.users;
  placeholder_user public.users;
  new_user_id uuid;
  company_name text;
  v_role_id uuid;
BEGIN
  IF auth.uid() IS DISTINCT FROM p_auth_user_id THEN
    RETURN json_build_object('success', false, 'error', 'Unauthorized');
  END IF;

  SELECT * INTO inv
  FROM public.company_invitations
  WHERE LOWER(email) = LOWER(p_email)
  ORDER BY created_at DESC
  LIMIT 1;

  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Invitation not found for email');
  END IF;

  SELECT name INTO company_name FROM public.companies WHERE id = inv.company_id;

  IF inv.status = 'accepted' THEN
    RETURN json_build_object('success', true, 'company_id', inv.company_id, 'company_name', company_name, 'role', inv.role, 'message', 'Invitation already accepted');
  END IF;

  -- Map Text Role -> UUID
  SELECT id INTO v_role_id FROM public.app_roles WHERE name = inv.role;

  SELECT * INTO existing_user FROM public.users WHERE auth_user_id = p_auth_user_id LIMIT 1;
  
  IF FOUND THEN
    UPDATE public.users
    SET email = COALESCE(inv.email, existing_user.email),
        active = true,
        company_id = inv.company_id,
        updated_at = NOW()
    WHERE id = existing_user.id
    RETURNING id INTO new_user_id;
  ELSE
    SELECT * INTO placeholder_user
    FROM public.users
    WHERE email = inv.email AND company_id = inv.company_id
    ORDER BY created_at DESC
    LIMIT 1;

    IF FOUND THEN
      UPDATE public.users
      SET auth_user_id = p_auth_user_id,
          active = true,
          updated_at = NOW()
      WHERE id = placeholder_user.id
      RETURNING id INTO new_user_id;
    ELSE
      INSERT INTO public.users (email, name, surname, active, company_id, auth_user_id, permissions)
      VALUES (inv.email, split_part(inv.email, '@', 1), NULL, true, inv.company_id, p_auth_user_id, '{}'::jsonb)
      RETURNING id INTO new_user_id;
    END IF;
  END IF;

  -- Upsert Membership
  INSERT INTO public.company_members (user_id, company_id, role_id, status)
  VALUES (new_user_id, inv.company_id, v_role_id, 'active')
  ON CONFLICT (user_id, company_id) DO UPDATE
  SET role_id = EXCLUDED.role_id, status = 'active', updated_at = NOW();

  UPDATE public.company_invitations
  SET status = 'accepted', responded_at = NOW()
  WHERE id = inv.id;

  UPDATE public.pending_users
  SET confirmed_at = NOW(), company_id = inv.company_id
  WHERE auth_user_id = p_auth_user_id AND email = inv.email;

  RETURN json_build_object('success', true, 'user_id', new_user_id, 'company_id', inv.company_id, 'company_name', company_name, 'role', inv.role, 'message', 'Invitation accepted successfully');
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."accept_company_invitation_by_email"("p_email" "text", "p_auth_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."activate_invited_user"("auth_user_id" "uuid", "user_email" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  user_record RECORD;
BEGIN
  -- Buscar el usuario por email
  SELECT * INTO user_record
  FROM users 
  WHERE email = user_email 
  AND active = false
  LIMIT 1;
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Usuario no encontrado o ya está activo'
    );
  END IF;
  
  -- Activar usuario y asociar con auth_user_id
  UPDATE users 
  SET 
    auth_user_id = activate_invited_user.auth_user_id,
    active = true,
    updated_at = NOW()
  WHERE id = user_record.id;
  
  RETURN json_build_object(
    'success', true,
    'message', 'Usuario activado correctamente',
    'user_id', user_record.id,
    'company_id', user_record.company_id
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object(
    'success', false,
    'error', SQLERRM
  );
END;
$$;


ALTER FUNCTION "public"."activate_invited_user"("auth_user_id" "uuid", "user_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."activate_recurring_service_on_payment"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Check if invoice is paid and has a source quote
  IF NEW.payment_status = 'paid' AND NEW.source_quote_id IS NOT NULL THEN
     -- Update quote status to 'active' if it is 'accepted' and is recurring
     UPDATE public.quotes
     SET status = 'active'
     WHERE id = NEW.source_quote_id
       AND recurrence_type IS NOT NULL
       AND recurrence_type <> 'none'
       AND status = 'accepted';
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."activate_recurring_service_on_payment"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_client_note"("p_client_id" "uuid", "p_company_id" "uuid", "p_content" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    new_key_id uuid;
    new_nonce bytea;
    encrypted_data bytea;
    note_id uuid;
    v_author_id uuid;
BEGIN
    v_author_id := get_my_public_id();

    IF NOT EXISTS (
        SELECT 1 FROM company_members cm 
        WHERE cm.user_id = v_author_id AND cm.company_id = p_company_id AND cm.status = 'active'
    ) THEN
        RAISE EXCEPTION 'Access Denied';
    END IF;

    SELECT id INTO new_key_id FROM pgsodium.create_key();
    new_nonce := pgsodium.crypto_secretbox_noncegen();
    encrypted_data := pgsodium.crypto_secretbox(
        p_content::bytea,
        new_nonce,
        new_key_id
    );

    INSERT INTO client_notes (client_id, company_id, author_id, key_id, nonce, encrypted_content)
    VALUES (p_client_id, p_company_id, v_author_id, new_key_id, new_nonce, encrypted_data)
    RETURNING id INTO note_id;

    RETURN note_id;
END;
$$;


ALTER FUNCTION "public"."add_client_note"("p_client_id" "uuid", "p_company_id" "uuid", "p_content" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_list_companies"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_user_role_name text;
    v_user_company_id uuid;
    v_companies jsonb;
BEGIN
    -- Security Check: Join with app_roles
    SELECT r.name, u.company_id 
    INTO v_user_role_name, v_user_company_id
    FROM public.users u
    JOIN public.app_roles r ON u.app_role_id = r.id
    WHERE u.auth_user_id = auth.uid();

    -- Allow Super Admin OR Owner
    IF v_user_role_name IS NULL OR (v_user_role_name != 'super_admin' AND v_user_role_name != 'owner') THEN
         RAISE EXCEPTION 'Access denied';
    END IF;

    -- Fetch companies with their respective module status
    SELECT jsonb_agg(
        jsonb_build_object(
            'id', c.id,
            'name', c.name,
            'settings', c.settings,
            'subscription_tier', c.subscription_tier,
            'is_active', c.is_active,
            'modules', (
                SELECT jsonb_agg(
                    jsonb_build_object(
                        'key', mc.key,
                        'label', mc.label,
                        'status', COALESCE(cm.status, 'inactive')
                    ) ORDER BY mc.key ASC
                )
                FROM public.modules_catalog mc
                LEFT JOIN public.company_modules cm 
                    ON cm.module_key = mc.key 
                    AND cm.company_id = c.id
            )
        ) ORDER BY c.name ASC
    ) INTO v_companies
    FROM public.companies c
    WHERE 
        -- Super Admin sees all
        v_user_role_name = 'super_admin'
        OR
        -- Owner sees only own company
        (v_user_role_name = 'owner' AND c.id = v_user_company_id);

    RETURN jsonb_build_object('companies', COALESCE(v_companies, '[]'::jsonb));
END;
$$;


ALTER FUNCTION "public"."admin_list_companies"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_list_company_modules"("p_company_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_modules JSONB;
    v_user_role_name text;
    v_user_company_id uuid;
BEGIN
    SELECT r.name, u.company_id 
    INTO v_user_role_name, v_user_company_id
    FROM public.users u
    JOIN public.app_roles r ON u.app_role_id = r.id
    WHERE u.auth_user_id = auth.uid(); -- FIX: Use auth_user_id
    
    -- Check permissions
    IF v_user_role_name = 'super_admin' THEN
        -- OK
    ELSIF v_user_role_name = 'owner' AND v_user_company_id = p_company_id THEN
        -- OK (Owner managing own company)
    ELSE
        RAISE EXCEPTION 'Access Denied: Insufficient permissions';
    END IF;
    
    SELECT jsonb_agg(
        jsonb_build_object(
            'key', mc.key,
            'label', mc.label,
            'status', COALESCE(cm.status, 'inactive')
        )
    )
    INTO v_modules
    FROM public.modules_catalog mc
    LEFT JOIN public.company_modules cm 
        ON mc.key = cm.module_key AND cm.company_id = p_company_id;

    RETURN jsonb_build_object('modules', COALESCE(v_modules, '[]'::jsonb));
END;
$$;


ALTER FUNCTION "public"."admin_list_company_modules"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_list_owners"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_user_role_name text;
    v_owners jsonb;
BEGIN
    -- Security Check
    SELECT ar.name INTO v_user_role_name
    FROM public.users u
    JOIN public.app_roles ar ON u.app_role_id = ar.id
    WHERE u.auth_user_id = auth.uid();

    IF v_user_role_name IS NULL OR v_user_role_name != 'super_admin' THEN
         RAISE EXCEPTION 'Access denied';
    END IF;

    -- Select users who have app_role = 'owner'
    SELECT jsonb_agg(
        jsonb_build_object(
            'id', u.id,
            'email', u.email,
            'name', COALESCE(u.name || ' ' || COALESCE(u.surname, ''), u.email),
            'company_id', u.company_id,
            'company_name', c.name
        ) ORDER BY c.name ASC NULLS LAST
    ) INTO v_owners
    FROM public.users u
    JOIN public.app_roles ar ON u.app_role_id = ar.id
    LEFT JOIN public.companies c ON u.company_id = c.id
    WHERE ar.name = 'owner';

    -- FIX: Return object wrapper
    RETURN jsonb_build_object('owners', COALESCE(v_owners, '[]'::jsonb));
END;
$$;


ALTER FUNCTION "public"."admin_list_owners"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_list_user_modules"("p_company_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_user_role_name text;
    v_target_company_id uuid;
    v_users jsonb;
    v_modules jsonb;
    v_assignments jsonb;
BEGIN
    SELECT ar.name INTO v_user_role_name
    FROM public.users u
    JOIN public.app_roles ar ON u.app_role_id = ar.id
    WHERE u.auth_user_id = auth.uid();
    
    IF v_user_role_name IS NULL OR v_user_role_name NOT IN ('owner', 'admin', 'super_admin') THEN
         RAISE EXCEPTION 'Access denied';
    END IF;

    IF p_company_id IS NOT NULL THEN
        IF v_user_role_name = 'super_admin' THEN
            v_target_company_id := p_company_id;
        ELSE
             SELECT company_id INTO v_target_company_id FROM public.users WHERE auth_user_id = auth.uid();
        END IF;
    ELSE
        SELECT company_id INTO v_target_company_id FROM public.users WHERE auth_user_id = auth.uid();
    END IF;

    IF v_target_company_id IS NULL THEN
         RETURN jsonb_build_object('users', '[]'::jsonb, 'modules', '[]'::jsonb, 'assignments', '[]'::jsonb);
    END IF;

    SELECT jsonb_agg(
        jsonb_build_object(
            'id', u.id,
            'email', u.email,
            'name', COALESCE(u.name || ' ' || COALESCE(u.surname, ''), u.email),
            'role', ar.name,
            'app_role_name', ar.name,
            'active', COALESCE(u.active, true)
        )
    ) INTO v_users
    FROM public.users u
    LEFT JOIN public.app_roles ar ON u.app_role_id = ar.id
    WHERE u.company_id = v_target_company_id;

    SELECT jsonb_agg(
        jsonb_build_object(
            'key', m.key,
            'name', m.label
        ) ORDER BY m.key ASC
    ) INTO v_modules
    FROM public.modules_catalog m;

    SELECT jsonb_agg(
        jsonb_build_object(
            'user_id', um.user_id,
            'module_key', um.module_key,
            'status', um.status
        )
    ) INTO v_assignments
    FROM public.user_modules um
    WHERE um.user_id IN (SELECT id FROM public.users WHERE company_id = v_target_company_id);

    RETURN jsonb_build_object(
        'users', COALESCE(v_users, '[]'::jsonb),
        'modules', COALESCE(v_modules, '[]'::jsonb),
        'assignments', COALESCE(v_assignments, '[]'::jsonb)
    );
END;
$$;


ALTER FUNCTION "public"."admin_list_user_modules"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_set_company_module"("p_target_company_id" "uuid", "p_module_key" "text", "p_status" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_user_role_name text;
    v_user_company_id uuid;
BEGIN
    SELECT r.name, u.company_id 
    INTO v_user_role_name, v_user_company_id
    FROM public.users u
    JOIN public.app_roles r ON u.app_role_id = r.id
    WHERE u.auth_user_id = auth.uid();

    -- Check permissions: Super Admin OR Owner of the target company
    IF v_user_role_name = 'super_admin' THEN
        -- Allowed
    ELSIF v_user_role_name = 'owner' AND v_user_company_id = p_target_company_id THEN
        -- Allowed
    ELSE
        RAISE EXCEPTION 'Access Denied: Insufficient permissions to set company module';
    END IF;

    -- Upsert company module status
    INSERT INTO public.company_modules (company_id, module_key, status, updated_at)
    VALUES (p_target_company_id, p_module_key, p_status, now())
    ON CONFLICT (company_id, module_key) 
    DO UPDATE SET status = EXCLUDED.status, updated_at = now();

    RETURN jsonb_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."admin_set_company_module"("p_target_company_id" "uuid", "p_module_key" "text", "p_status" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_set_user_module"("p_target_user_id" "uuid", "p_module_key" "text", "p_status" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_caller_role text;
    v_caller_company_id uuid;
    v_target_company_id uuid;
BEGIN
    -- 1. Get Caller Info (Role and Company)
    SELECT ar.name, u.company_id
    INTO v_caller_role, v_caller_company_id
    FROM public.users u
    JOIN public.app_roles ar ON u.app_role_id = ar.id
    WHERE u.auth_user_id = auth.uid();

    -- 2. Get Target User Info
    SELECT company_id INTO v_target_company_id
    FROM public.users
    WHERE id = p_target_user_id;

    IF v_target_company_id IS NULL THEN
        RAISE EXCEPTION 'Target user not found';
    END IF;

    -- 3. Permission Logic
    -- Super Admin can do anything
    IF v_caller_role = 'super_admin' THEN
        -- Allowed
    -- Owners/Admins can only modify users in THEIR company
    ELSIF v_caller_role IN ('owner', 'admin') THEN
        IF v_caller_company_id != v_target_company_id THEN
            RAISE EXCEPTION 'Access denied: You can only manage modules for your own company';
        END IF;
    ELSE
        RAISE EXCEPTION 'Access denied: Insufficient privileges';
    END IF;

    -- 4. Execute Update
    INSERT INTO public.user_modules (user_id, module_key, status, updated_at)
    VALUES (p_target_user_id, p_module_key, p_status, now())
    ON CONFLICT (user_id, module_key)
    DO UPDATE SET
        status = EXCLUDED.status,
        updated_at = now();
END;
$$;


ALTER FUNCTION "public"."admin_set_user_module"("p_target_user_id" "uuid", "p_module_key" "text", "p_status" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_toggle_company_module"("p_company_id" "uuid", "p_module_key" "text", "p_status" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_user_role_name text;
    v_user_company_id uuid;
BEGIN
    SELECT r.name, u.company_id 
    INTO v_user_role_name, v_user_company_id
    FROM public.users u
    JOIN public.app_roles r ON u.app_role_id = r.id
    WHERE u.auth_user_id = auth.uid(); -- FIX: Use auth_user_id
    
    -- Check permissions
    IF v_user_role_name = 'super_admin' THEN
        -- OK
    ELSIF v_user_role_name = 'owner' AND v_user_company_id = p_company_id THEN
        -- OK (Owner managing own company)
    ELSE
        RAISE EXCEPTION 'Access Denied: Insufficient permissions';
    END IF;

    IF p_status NOT IN ('active', 'inactive') THEN
         RAISE EXCEPTION 'Invalid status. Must be active or inactive';
    END IF;

    INSERT INTO public.company_modules (company_id, module_key, status, updated_at)
    VALUES (p_company_id, p_module_key, p_status, now())
    ON CONFLICT (company_id, module_key)
    DO UPDATE SET status = EXCLUDED.status, updated_at = now();

    RETURN jsonb_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."admin_toggle_company_module"("p_company_id" "uuid", "p_module_key" "text", "p_status" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Verificar que sea persona física
  IF (SELECT client_type FROM public.clients WHERE id = p_client_id) = 'business' THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Las empresas no están sujetas a GDPR. No se puede anonimizar.'
    );
  END IF;
  
  -- ... resto del código de anonimización
END;
$$;


ALTER FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid", "p_reason" "text" DEFAULT 'gdpr_erasure_request'::"text", "p_requesting_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_client record;
    v_company_id uuid;
    v_original_email text;
    v_anonymized_count int := 0;
BEGIN
    -- Verificar acceso del usuario
    SELECT company_id INTO v_company_id
    FROM users
    WHERE auth_user_id = COALESCE(p_requesting_user_id, auth.uid());
    
    -- Obtener datos del cliente antes de anonimizar
    SELECT * INTO v_client
    FROM clients
    WHERE id = p_client_id
    AND company_id = v_company_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Cliente no encontrado o sin acceso'
        );
    END IF;
    
    -- Verificar si ya está anonimizado
    IF v_client.anonymized_at IS NOT NULL THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Cliente ya fue anonimizado',
            'anonymized_at', v_client.anonymized_at
        );
    END IF;
    
    v_original_email := v_client.email;
    
    -- ✅ Anonimizar datos del cliente (UPDATED apellidos -> surname)
    UPDATE clients
    SET 
        name = 'ANONYMIZED_' || SUBSTRING(MD5(name) FROM 1 FOR 8),
        surname = 'ANONYMIZED_' || SUBSTRING(MD5(COALESCE(surname, '')) FROM 1 FOR 8),
        email = 'anonymized.' || SUBSTRING(MD5(email) FROM 1 FOR 8) || '@anonymized.local',
        phone = NULL,
        dni = NULL,
        address = jsonb_build_object('anonymized', true),
        metadata = jsonb_build_object(
            'anonymized', true,
            'original_metadata', jsonb_build_object(
                'original_id', p_client_id,
                'anonymized_at', now(),
                'anonymized_by', COALESCE(p_requesting_user_id, auth.uid()),
                'reason', p_reason,
                'original_email_hash', MD5(v_original_email),
                'original_dni_hash', MD5(COALESCE(v_client.dni, ''))
            )
        ),
        anonymized_at = now(),
        last_accessed_at = now(),
        access_count = COALESCE(access_count, 0) + 1,
        is_active = true,
        updated_at = now()
    WHERE id = p_client_id;
    
    GET DIAGNOSTICS v_anonymized_count = ROW_COUNT;
    
    -- Anonimizar registros de consentimiento relacionados
    UPDATE gdpr_consent_records
    SET 
        subject_email = 'anonymized.' || SUBSTRING(MD5(subject_email) FROM 1 FOR 8) || '@anonymized.local'
    WHERE subject_id = p_client_id;
    
    -- Registrar en audit log
    INSERT INTO gdpr_audit_log (
        user_id,
        company_id,
        action_type,
        table_name,
        record_id,
        subject_email,
        purpose,
        created_at
    ) VALUES (
        COALESCE(p_requesting_user_id, auth.uid()),
        v_company_id,
        'anonymize',
        'clients',
        p_client_id,
        'anonymized.' || SUBSTRING(MD5(v_original_email) FROM 1 FOR 8) || '@anonymized.local',
        p_reason,
        now()
    );
    
    -- Retornar resultado exitoso
    RETURN jsonb_build_object(
        'success', true,
        'message', 'Cliente anonimizado correctamente',
        'anonymized_count', v_anonymized_count,
        'client_id', p_client_id,
        'anonymized_at', now()
    );
    
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'error_detail', SQLSTATE
    );
END;
$$;


ALTER FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid", "p_reason" "text", "p_requesting_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid", "p_reason" "text", "p_requesting_user_id" "uuid") IS 'Anonimiza todos los datos personales de un cliente incluyendo apellidos (Art. 17 GDPR)';



CREATE OR REPLACE FUNCTION "public"."anonymize_invoice_data"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF NEW.retention_until < CURRENT_DATE AND NEW.anonymized_at IS NULL THEN
    NEW.notes := 'ANONIMIZADO';
    NEW.internal_notes := 'ANONIMIZADO';
    NEW.anonymized_at := CURRENT_TIMESTAMP;
    RAISE NOTICE 'Factura % anonimizada por GDPR', NEW.full_invoice_number;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."anonymize_invoice_data"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."anonymize_quote_data"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Solo anonimizar si el periodo de retención ha pasado
  IF OLD.retention_until < CURRENT_DATE AND NOT OLD.is_anonymized THEN
    UPDATE quotes
    SET 
      description = '[ANONIMIZADO]',
      notes = NULL,
      terms_conditions = NULL,
      client_ip_address = NULL,
      client_user_agent = NULL,
      digital_signature = NULL,
      is_anonymized = TRUE,
      anonymized_at = NOW()
    WHERE id = OLD.id;
  END IF;
  
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."anonymize_quote_data"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auth_has_permission"("p_permission" "text", "p_company_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Check simply: Does the user have an active role in this company that grants this permission?
  RETURN EXISTS (
    SELECT 1
    FROM public.company_members cm
    JOIN public.role_permissions rp ON cm.role_id = rp.role_id AND cm.company_id = rp.company_id
    WHERE cm.user_id = (SELECT id FROM public.users WHERE auth_user_id = auth.uid())
      AND cm.company_id = p_company_id
      AND cm.status = 'active'
      AND rp.permission = p_permission
      AND rp.granted = true
  );
END;
$$;


ALTER FUNCTION "public"."auth_has_permission"("p_permission" "text", "p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auth_user_email"() RETURNS "text"
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
  SELECT lower(current_setting('request.jwt.claims', true)::jsonb ->> 'email')
$$;


ALTER FUNCTION "public"."auth_user_email"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."auth_user_email"() IS 'Returns lowercased email from JWT claims.';



CREATE OR REPLACE FUNCTION "public"."auto_move_project_to_review"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_total_tasks INT;
    v_completed_tasks INT;
    v_project_company_id UUID;
    v_review_stage_id UUID;
    v_default_stage_id UUID;
    v_current_stage_id UUID;
BEGIN
    -- Count total and completed tasks for this project
    SELECT COUNT(*), COUNT(*) FILTER (WHERE is_completed = TRUE)
    INTO v_total_tasks, v_completed_tasks
    FROM project_tasks
    WHERE project_id = NEW.project_id;

    -- Get project's company_id and current stage
    SELECT company_id, stage_id
    INTO v_project_company_id, v_current_stage_id
    FROM projects
    WHERE id = NEW.project_id;

    -- Find review and default stages
    SELECT id INTO v_review_stage_id
    FROM project_stages
    WHERE company_id = v_project_company_id AND is_review = TRUE
    LIMIT 1;

    SELECT id INTO v_default_stage_id
    FROM project_stages
    WHERE company_id = v_project_company_id AND is_default = TRUE
    LIMIT 1;

    -- ALL tasks completed → move to review
    IF v_total_tasks > 0 AND v_completed_tasks = v_total_tasks THEN
        IF v_review_stage_id IS NOT NULL AND v_current_stage_id IS DISTINCT FROM v_review_stage_id THEN
            UPDATE projects
            SET stage_id = v_review_stage_id, updated_at = NOW()
            WHERE id = NEW.project_id;
        END IF;
    ELSE
        -- NOT all tasks completed and project is in review → move back to default
        IF v_current_stage_id = v_review_stage_id AND v_default_stage_id IS NOT NULL THEN
            UPDATE projects
            SET stage_id = v_default_stage_id, updated_at = NOW()
            WHERE id = NEW.project_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_move_project_to_review"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_annual_price"("p_monthly_price" numeric, "p_discount_percentage" numeric DEFAULT 16) RETURNS numeric
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN ROUND((p_monthly_price * 12) * (1 - p_discount_percentage / 100), 2);
END;
$$;


ALTER FUNCTION "public"."calculate_annual_price"("p_monthly_price" numeric, "p_discount_percentage" numeric) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_annual_price"("p_monthly_price" numeric, "p_discount_percentage" numeric) IS 'Calcula el precio anual aplicando un descuento al precio mensual';



CREATE OR REPLACE FUNCTION "public"."calculate_invoice_totals"("p_invoice_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_subtotal NUMERIC(12,2);
  v_tax_amount NUMERIC(12,2);
  v_total NUMERIC(12,2);
  v_paid_amount NUMERIC(12,2);
  v_new_status invoice_status;
  v_due_date DATE;
BEGIN
  -- Calcular totales desde las líneas
  SELECT 
    COALESCE(SUM(subtotal), 0),
    COALESCE(SUM(tax_amount), 0),
    COALESCE(SUM(total), 0)
  INTO v_subtotal, v_tax_amount, v_total
  FROM invoice_items
  WHERE invoice_id = p_invoice_id;
  
  -- Calcular total pagado
  SELECT COALESCE(SUM(amount), 0)
  INTO v_paid_amount
  FROM invoice_payments
  WHERE invoice_id = p_invoice_id;
  
  -- Obtener estado actual y fecha vencimiento
  SELECT status, due_date INTO v_new_status, v_due_date 
  FROM invoices WHERE id = p_invoice_id;
  
  -- Lógica de estados
  IF v_paid_amount >= v_total AND v_total > 0 THEN
    v_new_status := 'paid';
  ELSIF v_paid_amount > 0 AND v_paid_amount < v_total THEN
    v_new_status := 'partial';
  ELSIF v_new_status = 'draft' THEN
    v_new_status := 'draft';
  ELSIF v_due_date < CURRENT_DATE AND v_new_status NOT IN ('cancelled', 'rectified', 'paid') THEN
    v_new_status := 'overdue';
  ELSE
    -- Si no es pagada, ni parcial, ni borrador, ni vencida...
    -- Mantener estados especiales si ya los tiene
    IF v_new_status IN ('approved', 'issued', 'rectified', 'sent', 'cancelled') THEN
       -- Mantener el estado actual
       v_new_status := v_new_status;
    ELSE
       -- Si venía de 'paid', 'partial' u 'overdue' y ya no lo es,
       -- por defecto la pasamos a 'sent' (o 'approved' si preferimos, pero 'sent' es más seguro para cobro)
       -- En este caso, si acabamos de crearla como 'approved', entrará en el IF anterior y se mantendrá.
       v_new_status := 'sent';
    END IF;
  END IF;
  
  -- Actualizar factura
  UPDATE invoices
  SET 
    subtotal = v_subtotal,
    tax_amount = v_tax_amount,
    total = v_total,
    paid_amount = v_paid_amount,
    status = v_new_status,
    updated_at = CURRENT_TIMESTAMP
  WHERE id = p_invoice_id;
END;
$$;


ALTER FUNCTION "public"."calculate_invoice_totals"("p_invoice_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_invoice_totals"("p_invoice_id" "uuid") IS 'Recalcula los totales y estado de una factura';



CREATE OR REPLACE FUNCTION "public"."calculate_invoice_totals_payment_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM calculate_invoice_totals(OLD.invoice_id);
  ELSE
    PERFORM calculate_invoice_totals(NEW.invoice_id);
  END IF;
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."calculate_invoice_totals_payment_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_invoice_totals_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM calculate_invoice_totals(OLD.invoice_id);
  ELSE
    PERFORM calculate_invoice_totals(NEW.invoice_id);
  END IF;
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."calculate_invoice_totals_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_quote_item_totals"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_prices_include_tax boolean;
  v_divisor numeric;
BEGIN
  -- Obtener configuración de la empresa
  SELECT prices_include_tax INTO v_prices_include_tax 
  FROM company_settings 
  WHERE company_id = NEW.company_id;

  -- Si no hay configuración de empresa, usar la global
  IF v_prices_include_tax IS NULL THEN
    SELECT default_prices_include_tax INTO v_prices_include_tax
    FROM app_settings
    LIMIT 1;
  END IF;

  -- Default: FALSE (precios SIN IVA)
  v_prices_include_tax := COALESCE(v_prices_include_tax, false);

  IF v_prices_include_tax AND NEW.tax_rate > 0 THEN
    -- =============================================
    -- PRECIOS CON IVA INCLUIDO
    -- =============================================
    -- unit_price ya incluye IVA, así que:
    -- total = quantity * unit_price (el usuario ya puso el precio final)
    -- subtotal = total / (1 + tax_rate/100) (extraer base imponible)
    -- tax_amount = total - subtotal

    -- 1. Total bruto (antes de descuento)
    NEW.total := NEW.quantity * NEW.unit_price;
    
    -- 2. Aplicar descuento sobre el total
    NEW.discount_amount := NEW.total * (COALESCE(NEW.discount_percent, 0) / 100);
    NEW.total := NEW.total - NEW.discount_amount;

    -- 3. Extraer base imponible (subtotal) del total
    v_divisor := 1 + (NEW.tax_rate / 100);
    NEW.subtotal := NEW.total / v_divisor;
    
    -- 4. Calcular IVA (la diferencia)
    NEW.tax_amount := NEW.total - NEW.subtotal;
    
  ELSE
    -- =============================================
    -- PRECIOS SIN IVA INCLUIDO (comportamiento tradicional)
    -- =============================================
    -- unit_price es el precio neto, hay que añadir IVA

    -- 1. Subtotal = quantity * unit_price
    NEW.subtotal := NEW.quantity * NEW.unit_price;
    
    -- 2. Aplicar descuento
    NEW.discount_amount := NEW.subtotal * (COALESCE(NEW.discount_percent, 0) / 100);
    NEW.subtotal := NEW.subtotal - NEW.discount_amount;
    
    -- 3. Calcular IVA sobre la base imponible
    NEW.tax_amount := NEW.subtotal * (NEW.tax_rate / 100);
    
    -- 4. Total = base + IVA
    NEW.total := NEW.subtotal + NEW.tax_amount;
  END IF;
  
  -- Redondear a 2 decimales
  NEW.subtotal := ROUND(NEW.subtotal, 2);
  NEW.tax_amount := ROUND(NEW.tax_amount, 2);
  NEW.total := ROUND(NEW.total, 2);
  NEW.discount_amount := ROUND(COALESCE(NEW.discount_amount, 0), 2);
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calculate_quote_item_totals"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_quote_item_totals"() IS 'Calcula subtotal, tax_amount y total de quote_items respetando prices_include_tax';



CREATE OR REPLACE FUNCTION "public"."calculate_quote_totals"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  items_subtotal DECIMAL(12, 2);
  items_tax DECIMAL(12, 2);
BEGIN
  -- Sumar todos los items
  SELECT 
    COALESCE(SUM(subtotal), 0),
    COALESCE(SUM(tax_amount), 0)
  INTO items_subtotal, items_tax
  FROM quote_items
  WHERE quote_id = NEW.quote_id;
  
  -- Actualizar totales del presupuesto
  UPDATE quotes
  SET 
    subtotal = items_subtotal,
    tax_amount = items_tax,
    total_amount = items_subtotal + items_tax,
    updated_at = NOW()
  WHERE id = NEW.quote_id;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calculate_quote_totals"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cancel_contracted_service"("p_quote_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_user_id uuid;
    v_user_email text;
    v_quote_record record;
    v_invoice_record record;
    v_action_taken text;
    v_has_access boolean;
BEGIN
    -- 1. Get context
    v_user_id := auth.uid();
    v_user_email := (SELECT email FROM auth.users WHERE id = v_user_id);
    
    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'No autenticado');
    END IF;

    -- 2. Find the Quote (Service)
    SELECT * INTO v_quote_record 
    FROM public.quotes 
    WHERE id = p_quote_id;

    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Servicio no encontrado');
    END IF;

    -- 3. Validate User Access
    -- Check if the regular user owns the client profile associated with this quote
    SELECT EXISTS (
        SELECT 1 FROM public.client_portal_users
        WHERE email = v_user_email
        AND client_id = v_quote_record.client_id
        AND company_id = v_quote_record.company_id
        AND is_active = true
    ) INTO v_has_access;

    -- Fallback: Check strictly against clients table if no portal mapping found
    IF NOT v_has_access THEN
        SELECT EXISTS (
            SELECT 1 FROM public.clients
            WHERE id = v_quote_record.client_id
            AND company_id = v_quote_record.company_id
            AND is_active = true
            AND deleted_at IS NULL
            AND (email = v_user_email OR auth_user_id = v_user_id)
        ) INTO v_has_access;
    END IF;

    IF NOT v_has_access THEN
         RETURN jsonb_build_object('success', false, 'error', 'No autorizado para gestionar este servicio');
    END IF;

    IF v_quote_record.status = 'cancelled' THEN
         RETURN jsonb_build_object('success', false, 'error', 'El servicio ya está cancelado');
    END IF;

    -- 4. Check for the LATEST associated invoice
    SELECT * INTO v_invoice_record 
    FROM public.invoices 
    WHERE source_quote_id = p_quote_id 
    AND company_id = v_quote_record.company_id 
    ORDER BY created_at DESC 
    LIMIT 1;

    -- 5. Decision Logic
    IF v_invoice_record.id IS NOT NULL AND v_invoice_record.status IN ('paid', 'partial', 'issued', 'rectified') THEN
        -- SCENARIO A: Invoice is PAID/ISSUED. Cancel subscription only.
        UPDATE public.quotes 
        SET 
            status = 'cancelled',
            recurrence_end_date = NOW(),
            notes = COALESCE(notes, '') || E'\n[Baja solicitada por cliente: ' || COALESCE(p_reason, 'Sin motivo') || ']'
        WHERE id = p_quote_id;

        v_action_taken := 'service_cancelled_billing_stopped';
    ELSE
        -- SCENARIO B: Invoice is UNPAID/DRAFT. Void invoice and Cancel quote.
        UPDATE public.quotes 
        SET 
            status = 'cancelled',
            recurrence_end_date = NOW(),
            notes = COALESCE(notes, '') || E'\n[Cancelado por cliente antes del pago: ' || COALESCE(p_reason, 'Sin motivo') || ']'
        WHERE id = p_quote_id;

        IF v_invoice_record.id IS NOT NULL AND v_invoice_record.status NOT IN ('void', 'cancelled') THEN
            UPDATE public.invoices
            SET 
                status = 'void',
                notes = COALESCE(notes, '') || E'\n[Anulada automáticamente por cancelación del servicio]'
            WHERE id = v_invoice_record.id;
        END IF;

        v_action_taken := 'service_cancelled_invoice_voided';
    END IF;

    -- 6. Return Success
    RETURN jsonb_build_object(
        'success', true, 
        'action', v_action_taken,
        'message', 'Servicio dado de baja correctamente',
        'quote_id', p_quote_id
    );

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."cancel_contracted_service"("p_quote_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cancel_invoice"("p_invoice_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
declare
  v_company_id uuid;
begin
  select company_id into v_company_id from public.invoices where id=p_invoice_id;
  if v_company_id is null then raise exception 'Invoice not found'; end if;
  
  -- Update status AND state to void
  -- We update both to ensure consistency and bypass immutability guard (which now allows 'void')
  update public.invoices 
  set status='void', 
      state='void' 
  where id=p_invoice_id 
  and (status <> 'void' or state <> 'void');
  
  -- Insert or update anulacion event (idempotent)
  insert into verifactu.events(company_id, invoice_id, event_type, payload)
  values (v_company_id, p_invoice_id, 'anulacion', jsonb_build_object('reason', coalesce(p_reason,'n/a')))
  on conflict (invoice_id, event_type) do update
  set payload = excluded.payload,
      status = 'pending'; -- Reset status to pending if we are re-requesting cancellation
  
  -- Update meta status
  update verifactu.invoice_meta set status='void' where invoice_id=p_invoice_id;
  
  return json_build_object('status','void');
end$$;


ALTER FUNCTION "public"."cancel_invoice"("p_invoice_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_company_exists"("p_company_name" "text") RETURNS TABLE("company_exists" boolean, "company_id" "uuid", "company_name" "text", "owner_email" "text", "owner_name" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    EXISTS(SELECT 1 FROM public.companies WHERE LOWER(name) = LOWER(p_company_name)) as company_exists,
    c.id as company_id,
    c.name as company_name,
    u.email as owner_email,
    u.name as owner_name
  FROM public.companies c
  LEFT JOIN public.company_members cm ON cm.company_id = c.id AND cm.status = 'active'
  LEFT JOIN public.app_roles ar ON ar.id = cm.role_id AND ar.name = 'owner'
  LEFT JOIN public.users u ON u.id = cm.user_id
  WHERE LOWER(c.name) = LOWER(p_company_name)
  LIMIT 1;
END;
$$;


ALTER FUNCTION "public"."check_company_exists"("p_company_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_gdpr_compliance"() RETURNS TABLE("check_name" "text", "status" "text", "value" "text", "is_compliant" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    RETURN QUERY
    
    -- Check 1: Todos los clientes tienen consentimiento
    SELECT 
        'Consentimiento de procesamiento'::TEXT,
        CASE 
            WHEN pct = 100 THEN '✅ COMPLIANT'
            WHEN pct >= 80 THEN '⚠️ ADVERTENCIA'
            ELSE '❌ NO COMPLIANT'
        END,
        pct::TEXT || '%',
        pct >= 80
    FROM (
        SELECT ROUND(
            100.0 * COUNT(*) FILTER (WHERE data_processing_consent = true) 
            / NULLIF(COUNT(*), 0),
            2
        ) as pct
        FROM clients WHERE deleted_at IS NULL
    ) sub
    
    UNION ALL
    
    -- Check 2: Todos los clientes tienen base legal
    SELECT 
        'Base legal de procesamiento'::TEXT,
        CASE 
            WHEN pct = 100 THEN '✅ COMPLIANT'
            WHEN pct >= 80 THEN '⚠️ ADVERTENCIA'
            ELSE '❌ NO COMPLIANT'
        END,
        pct::TEXT || '%',
        pct >= 80
    FROM (
        SELECT ROUND(
            100.0 * COUNT(*) FILTER (WHERE data_processing_legal_basis IS NOT NULL) 
            / NULLIF(COUNT(*), 0),
            2
        ) as pct
        FROM clients WHERE deleted_at IS NULL
    ) sub
    
    UNION ALL
    
    -- Check 3: RLS habilitado en tablas críticas
    SELECT 
        'RLS en tablas GDPR'::TEXT,
        CASE 
            WHEN COUNT(*) FILTER (WHERE rowsecurity = false) = 0 THEN '✅ COMPLIANT'
            ELSE '❌ NO COMPLIANT'
        END,
        COUNT(*) FILTER (WHERE rowsecurity = true)::TEXT || '/' || COUNT(*)::TEXT || ' tablas',
        COUNT(*) FILTER (WHERE rowsecurity = false) = 0
    FROM pg_tables
    WHERE schemaname = 'public'
    AND tablename IN ('clients', 'gdpr_access_requests', 'gdpr_consent_records', 'gdpr_audit_log')
    
    UNION ALL
    
    -- Check 4: Políticas RLS en tablas GDPR
    SELECT 
        'Políticas RLS GDPR'::TEXT,
        CASE 
            WHEN COUNT(*) >= 12 THEN '✅ COMPLIANT'
            WHEN COUNT(*) >= 8 THEN '⚠️ ADVERTENCIA'
            ELSE '❌ NO COMPLIANT'
        END,
        COUNT(*)::TEXT || ' políticas',
        COUNT(*) >= 8
    FROM pg_policies
    WHERE tablename LIKE 'gdpr_%'
    
    UNION ALL
    
    -- Check 5: Solicitudes GDPR procesadas a tiempo (<30 días)
    SELECT 
        'Tiempo de respuesta solicitudes'::TEXT,
        CASE 
            WHEN avg_days <= 15 THEN '✅ COMPLIANT'
            WHEN avg_days <= 30 THEN '⚠️ ADVERTENCIA'
            ELSE '❌ NO COMPLIANT'
        END,
        ROUND(avg_days, 1)::TEXT || ' días promedio',
        avg_days <= 30
    FROM (
        SELECT COALESCE(
            AVG(EXTRACT(DAY FROM (completed_at - created_at))),
            0
        ) as avg_days
        FROM gdpr_access_requests
        WHERE processing_status = 'completed'
        AND completed_at IS NOT NULL
    ) sub;
    
END;
$$;


ALTER FUNCTION "public"."check_gdpr_compliance"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_stage_coverage_after_hide"("p_company_id" "uuid", "p_stage_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_category text;
  v_visible_count int;
BEGIN
  -- Get category of the stage being hidden
  SELECT workflow_category INTO v_category
  FROM ticket_stages
  WHERE id = p_stage_id;

  IF v_category IS NULL THEN
    RETURN TRUE; -- Should not happen if stage exists
  END IF;

  -- Count visible stages in this category for this company, EXCLUDING the one being hidden
  -- Visible = (Generic AND NOT Hidden) OR (Company Specific)
  SELECT COUNT(*)
  INTO v_visible_count
  FROM ticket_stages ts
  WHERE ts.workflow_category = v_category
    AND ts.deleted_at IS NULL
    AND (
      -- Company specific stage
      ts.company_id = p_company_id
      OR
      -- Generic stage not hidden (and not the one we are hiding)
      (ts.company_id IS NULL 
       AND ts.id != p_stage_id
       AND NOT EXISTS (
         SELECT 1 FROM hidden_stages hs 
         WHERE hs.company_id = p_company_id 
           AND hs.stage_id = ts.id
       )
      )
    );

  RETURN v_visible_count > 0;
END;
$$;


ALTER FUNCTION "public"."check_stage_coverage_after_hide"("p_company_id" "uuid", "p_stage_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."clean_expired_pending_users"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Eliminar registros expirados (más de 24 horas)
    DELETE FROM public.pending_users 
    WHERE expires_at < NOW() 
    AND confirmed_at IS NULL;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."clean_expired_pending_users"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_current_duplicates"() RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    duplicate_count INTEGER := 0;
    company_record RECORD;
BEGIN
    -- Buscar empresas con nombres similares y consolidar
    FOR company_record IN
        SELECT 
            c1.id as keep_id,
            c1.name as keep_name,
            c2.id as remove_id,
            c2.name as remove_name
        FROM public.companies c1
        JOIN public.companies c2 ON 
            LOWER(TRIM(c1.name)) = LOWER(TRIM(c2.name))
            AND c1.id != c2.id
            AND c1.created_at < c2.created_at
        WHERE c1.deleted_at IS NULL AND c2.deleted_at IS NULL
    LOOP
        -- Migrar usuarios de empresa duplicada a empresa original
        UPDATE public.users
        SET company_id = company_record.keep_id
        WHERE company_id = company_record.remove_id;
        
        -- Marcar empresa duplicada como eliminada
        UPDATE public.companies
        SET deleted_at = NOW()
        WHERE id = company_record.remove_id;
        
        duplicate_count := duplicate_count + 1;
    END LOOP;
    
    RETURN FORMAT('Cleaned up %s duplicate companies', duplicate_count);
END;
$$;


ALTER FUNCTION "public"."cleanup_current_duplicates"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_duplicate_companies"() RETURNS TABLE("action" "text", "details" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  dup_record RECORD;
  users_migrated INTEGER := 0;
  total_companies_cleaned INTEGER := 0;
BEGIN
  FOR dup_record IN
    WITH duplicates AS (
      SELECT name, id, created_at,
             ROW_NUMBER() OVER (PARTITION BY LOWER(name) ORDER BY created_at DESC) as rn
      FROM public.companies
      WHERE deleted_at IS NULL
    ),
    to_keep AS (
      SELECT name, id as keep_id FROM duplicates WHERE rn = 1
    ),
    to_remove AS (
      SELECT d.name, d.id as remove_id, tk.keep_id
      FROM duplicates d
      JOIN to_keep tk ON LOWER(d.name) = LOWER(tk.name)
      WHERE d.rn > 1
    )
    SELECT * FROM to_remove
  LOOP
    UPDATE public.users SET company_id = dup_record.keep_id WHERE company_id = dup_record.remove_id;
    GET DIAGNOSTICS users_migrated = ROW_COUNT;

    UPDATE public.companies SET deleted_at = NOW() WHERE id = dup_record.remove_id;

    total_companies_cleaned := total_companies_cleaned + 1;

    RETURN QUERY SELECT 'MIGRATED'::TEXT,
      FORMAT('Company "%s": migrated %s users from %s to %s', dup_record.name, users_migrated, dup_record.remove_id, dup_record.keep_id);
  END LOOP;

  IF total_companies_cleaned = 0 THEN
    RETURN QUERY SELECT 'NO_DUPLICATES'::TEXT, 'No duplicate companies found';
  ELSE
    RETURN QUERY SELECT 'COMPLETED'::TEXT, FORMAT('Cleaned up %s duplicate companies', total_companies_cleaned);
  END IF;
END;
$$;


ALTER FUNCTION "public"."cleanup_duplicate_companies"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_expired_gdpr_data"() RETURNS TABLE("clients_anonymized" integer, "audit_logs_deleted" integer, "old_consents_archived" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_clients_anonymized INT := 0;
    v_audit_logs_deleted INT := 0;
    v_consents_archived INT := 0;
BEGIN
    -- 1. Anonimizar clientes cuya retención ha expirado
    WITH anonymized AS (
        UPDATE clients
        SET 
            name = 'Cliente Anonimizado',
            email = 'anonimizado_' || id::text || '@gdpr.local',
            phone = NULL,
            address = NULL,
            metadata = jsonb_set(
                COALESCE(metadata, '{}'::jsonb),
                '{anonimizado}',
                'true'::jsonb
            ),
            anonymized_at = NOW(),
            is_active = false
        WHERE data_retention_until < NOW()
        AND anonymized_at IS NULL
        AND deleted_at IS NULL
        RETURNING id
    )
    SELECT COUNT(*) INTO v_clients_anonymized FROM anonymized;
    
    -- 2. Eliminar logs de auditoría antiguos (>2 años)
    WITH deleted_logs AS (
        DELETE FROM gdpr_audit_log
        WHERE created_at < NOW() - INTERVAL '2 years'
        AND action_type NOT IN ('anonymize', 'delete', 'breach_reported')
        RETURNING id
    )
    SELECT COUNT(*) INTO v_audit_logs_deleted FROM deleted_logs;
    
    -- 3. Archivar consentimientos antiguos inactivos (>3 años)
    -- (Para cumplir con minimización de datos)
    WITH archived_consents AS (
        UPDATE gdpr_consent_records
        SET is_active = false
        WHERE created_at < NOW() - INTERVAL '3 years'
        AND is_active = true
        AND consent_given = false
        RETURNING id
    )
    SELECT COUNT(*) INTO v_consents_archived FROM archived_consents;
    
    RETURN QUERY SELECT v_clients_anonymized, v_audit_logs_deleted, v_consents_archived;
END;
$$;


ALTER FUNCTION "public"."cleanup_expired_gdpr_data"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_pending_user"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
    DELETE FROM public.pending_users 
    WHERE auth_user_id = OLD.id;
    RETURN OLD;
END;
$$;


ALTER FUNCTION "public"."cleanup_pending_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."client_can_access_company"("p_company_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Check if the current user (auth.uid()) is a client of the given company.
  -- We use get_my_public_id() if needed, but for clients table we usually link by auth_user_id.
  -- Based on the previous policy: SELECT clients.company_id FROM clients WHERE clients.auth_user_id = auth.uid()
  
  RETURN EXISTS (
    SELECT 1
    FROM public.clients c
    WHERE c.company_id = p_company_id
    AND c.auth_user_id = auth.uid()
  );
END;
$$;


ALTER FUNCTION "public"."client_can_access_company"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."client_cancel_booking"("p_booking_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_booking RECORD;
    v_user_id UUID;
    v_client_id UUID;
    v_quote_id UUID;
BEGIN
    v_user_id := auth.uid();

    -- 1. Find Client ID for validation
    -- Try direct link first
    SELECT id INTO v_client_id
    FROM public.clients
    WHERE auth_user_id = v_user_id;

    -- Fallback to portal user email link
    IF v_client_id IS NULL THEN
        SELECT c.id INTO v_client_id
        FROM public.clients c
        JOIN public.client_portal_users cpu ON c.id = cpu.client_id
        WHERE cpu.email = (SELECT email FROM auth.users WHERE id = v_user_id);
    END IF;

    IF v_client_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Client profile not found');
    END IF;

    -- 2. Verify Booking Ownership
    SELECT * INTO v_booking
    FROM public.bookings
    WHERE id = p_booking_id AND client_id = v_client_id;

    IF v_booking IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Booking not found or access denied');
    END IF;

    -- 3. Check Status
    IF v_booking.status = 'cancelled' THEN
        RETURN jsonb_build_object('success', false, 'error', 'Booking is already cancelled');
    END IF;

    -- 4. Cancel Booking
    UPDATE public.bookings
    SET status = 'cancelled',
        notes = COALESCE(notes, '') || E'\n[Client Cancelled]: ' || COALESCE(p_reason, 'No reason provided'),
        updated_at = NOW()
    WHERE id = p_booking_id;

    -- 5. Cancel Associated Quote (if any)
    IF v_booking.quote_id IS NOT NULL THEN
        UPDATE public.quotes
        SET status = 'rejected', -- Or 'cancelled' if that status exists, usually 'rejected' or 'expired' for untaken quotes. 
            -- Let's check status constraint. Usually: draft, sent, accepted, rejected, invoiced, paid.
            -- 'rejected' is appropriate for client cancellation.
            updated_at = NOW()
        WHERE id = v_booking.quote_id;
    END IF;

    RETURN jsonb_build_object('success', true);

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."client_cancel_booking"("p_booking_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."client_create_booking"("p_company_id" "uuid", "p_service_id" "uuid", "p_start_time" timestamp with time zone, "p_end_time" timestamp with time zone) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_client_id UUID;
    v_booking_id UUID;
    v_quote_id UUID;
    v_booking_type_id UUID;
    v_customer_name TEXT;
    v_customer_email TEXT;
    v_service RECORD;
    v_user_id UUID;
    -- Variables for Price Calculation
    v_price NUMERIC;
    v_company_settings RECORD;
    v_quote_number TEXT;
    v_sequence_number BIGINT;
    v_year INTEGER;
    v_tax_rate NUMERIC;
    v_prices_include_tax BOOLEAN;
    v_base_price NUMERIC;
    v_tax_amount NUMERIC;
    v_total_amount NUMERIC;
    v_discount_percent NUMERIC := 0;
BEGIN
    -- 1. Identify Client & Get Name/Email
    v_user_id := auth.uid();
    
    SELECT id, name || ' ' || COALESCE(surname, ''), email INTO v_client_id, v_customer_name, v_customer_email
    FROM public.clients
    WHERE auth_user_id = v_user_id AND company_id = p_company_id;

    IF v_client_id IS NULL THEN
        -- Link by email if needed
        SELECT c.id, c.name || ' ' || COALESCE(c.surname, ''), c.email INTO v_client_id, v_customer_name, v_customer_email
        FROM public.clients c
        JOIN public.client_portal_users cpu ON c.id = cpu.client_id
        WHERE cpu.company_id = p_company_id 
        AND cpu.email = (SELECT email FROM auth.users WHERE id = v_user_id);
    END IF;

    IF v_client_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Client profile not found');
    END IF;

    -- 2. Verify Service & Get Booking Type
    SELECT * INTO v_service FROM public.services WHERE id = p_service_id;
    IF v_service IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Service not found');
    END IF;

    -- Get Default Booking Type (First one found)
    SELECT id INTO v_booking_type_id FROM public.booking_types WHERE company_id = p_company_id LIMIT 1;
    
    -- 3. Create Booking
    INSERT INTO public.bookings (
        company_id, service_id, client_id, start_time, end_time, status, booking_type_id, customer_name, customer_email
    ) VALUES (
        p_company_id, p_service_id, v_client_id, p_start_time, p_end_time, 'confirmed', v_booking_type_id, v_customer_name, v_customer_email
    ) RETURNING id INTO v_booking_id;

    -- Calculate Price
    v_price := COALESCE(v_service.base_price, 0);

    IF v_price > 0 THEN
        -- Get Tax Settings
        SELECT * INTO v_company_settings FROM public.company_settings WHERE company_id = p_company_id;
        v_prices_include_tax := COALESCE(v_company_settings.prices_include_tax, false);
        v_tax_rate := CASE WHEN COALESCE(v_company_settings.iva_enabled, true) THEN COALESCE(v_company_settings.iva_rate, 21.0) ELSE 0 END;

        IF v_prices_include_tax THEN
            v_total_amount := v_price;
            v_base_price := v_total_amount / (1 + v_tax_rate / 100.0);
            v_tax_amount := v_total_amount - v_base_price;
        ELSE
            v_base_price := v_price;
            v_tax_amount := v_base_price * (v_tax_rate / 100.0);
            v_total_amount := v_base_price + v_tax_amount;
        END IF;

        -- Generate Quote Number
        v_year := date_part('year', CURRENT_DATE);
        BEGIN
            v_sequence_number := public.get_next_quote_number(p_company_id, v_year);
        EXCEPTION WHEN OTHERS THEN
            v_sequence_number := (extract(epoch from now())::bigint);
        END;
        v_quote_number := v_year || '-P-' || lpad(v_sequence_number::text, 5, '0');

        -- Create Quote
        INSERT INTO public.quotes (
            company_id, client_id, year, sequence_number, quote_number, title, description,
            status, quote_date, valid_until, currency, subtotal, tax_amount, total_amount, created_by,
            booking_id -- LINK TO BOOKING
        ) VALUES (
            p_company_id, v_client_id, v_year, v_sequence_number, v_quote_number, v_service.name, 
            'Reserva Online: ' || p_start_time::text,
            'accepted', CURRENT_DATE, CURRENT_DATE + INTERVAL '30 days', 'EUR',
            v_base_price, v_tax_amount, v_total_amount, v_user_id,
            v_booking_id -- Set booking_id
        ) RETURNING id INTO v_quote_id;

        -- Create Quote Item
        INSERT INTO public.quote_items (
            quote_id, company_id, line_number, description, quantity, unit_price, subtotal, tax_rate, tax_amount, total, service_id
        ) VALUES (
            v_quote_id, p_company_id, 1, v_service.name, 1, v_base_price, v_base_price, v_tax_rate, v_tax_amount, v_total_amount, p_service_id
        );

        -- Update Booking with Quote ID
        UPDATE public.bookings SET quote_id = v_quote_id WHERE id = v_booking_id;

    END IF;

    RETURN jsonb_build_object('success', true, 'booking_id', v_booking_id, 'quote_id', v_quote_id);

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."client_create_booking"("p_company_id" "uuid", "p_service_id" "uuid", "p_start_time" timestamp with time zone, "p_end_time" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."client_get_preferences"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_user_id UUID := auth.uid();
    v_prefs JSONB;
BEGIN
    SELECT row_to_json(up) INTO v_prefs
    FROM public.user_preferences up
    WHERE up.user_id = v_user_id;

    -- Return default if null
    IF v_prefs IS NULL THEN
        v_prefs := jsonb_build_object(
            'email_notifications', true,
            'sms_notifications', false,
            'marketing_accepted', false
        );
    END IF;

    RETURN v_prefs;
END;
$$;


ALTER FUNCTION "public"."client_get_preferences"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."quotes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "quote_number" character varying(50) NOT NULL,
    "year" integer DEFAULT EXTRACT(year FROM CURRENT_DATE) NOT NULL,
    "sequence_number" integer NOT NULL,
    "status" "public"."quote_status" DEFAULT 'draft'::"public"."quote_status" NOT NULL,
    "quote_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "valid_until" "date" NOT NULL,
    "accepted_at" timestamp with time zone,
    "rejected_at" timestamp with time zone,
    "invoiced_at" timestamp with time zone,
    "invoice_id" "uuid",
    "title" character varying(500) NOT NULL,
    "description" "text",
    "notes" "text",
    "terms_conditions" "text",
    "subtotal" numeric(12,2) DEFAULT 0 NOT NULL,
    "tax_amount" numeric(12,2) DEFAULT 0 NOT NULL,
    "total_amount" numeric(12,2) DEFAULT 0 NOT NULL,
    "discount_percent" numeric(5,2) DEFAULT 0,
    "discount_amount" numeric(12,2) DEFAULT 0,
    "currency" character varying(3) DEFAULT 'EUR'::character varying,
    "language" character varying(5) DEFAULT 'es'::character varying,
    "client_viewed_at" timestamp with time zone,
    "client_ip_address" "inet",
    "client_user_agent" "text",
    "pdf_url" "text",
    "pdf_generated_at" timestamp with time zone,
    "digital_signature" "text",
    "signature_timestamp" timestamp with time zone,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_anonymized" boolean DEFAULT false,
    "anonymized_at" timestamp with time zone,
    "retention_until" "date" GENERATED ALWAYS AS (("quote_date" + '7 years'::interval)) STORED,
    "convert_policy" "text",
    "deposit_percentage" numeric(5,2),
    "invoice_on_date" "date",
    "conversion_status" "text" DEFAULT 'not_converted'::"text" NOT NULL,
    "ticket_id" "uuid",
    "recurrence_type" "text" DEFAULT 'none'::"text" NOT NULL,
    "recurrence_interval" integer DEFAULT 1 NOT NULL,
    "recurrence_day" integer,
    "recurrence_start_date" "date",
    "recurrence_end_date" "date",
    "next_run_at" timestamp with time zone,
    "last_run_at" timestamp with time zone,
    "quote_month" "date",
    "rectifies_invoice_id" "uuid",
    "scheduled_conversion_date" "date",
    "rectification_reason" "text",
    "full_quote_number" character varying(100) GENERATED ALWAYS AS ((("year" || '-P-'::"text") || "lpad"(("sequence_number")::"text", 5, '0'::"text"))) STORED,
    "rejection_reason" "text",
    "booking_id" "uuid",
    CONSTRAINT "quotes_conversion_status_check" CHECK (("conversion_status" = ANY (ARRAY['not_converted'::"text", 'scheduled'::"text", 'converted'::"text", 'partial'::"text"]))),
    CONSTRAINT "quotes_convert_policy_check" CHECK (("convert_policy" = ANY (ARRAY['manual'::"text", 'on_accept'::"text", 'automatic'::"text", 'scheduled'::"text"]))),
    CONSTRAINT "valid_dates" CHECK (("valid_until" >= "quote_date")),
    CONSTRAINT "valid_discount" CHECK ((("discount_percent" >= (0)::numeric) AND ("discount_percent" <= (100)::numeric))),
    CONSTRAINT "valid_totals_consistency" CHECK (("total_amount" = ("subtotal" + "tax_amount")))
);


ALTER TABLE "public"."quotes" OWNER TO "postgres";


COMMENT ON TABLE "public"."quotes" IS 'Presupuestos enviados a clientes con posibilidad de conversión a factura';



COMMENT ON COLUMN "public"."quotes"."valid_until" IS 'Fecha hasta la cual el presupuesto es válido';



COMMENT ON COLUMN "public"."quotes"."invoice_id" IS 'ID de la factura generada si el presupuesto fue aceptado';



COMMENT ON COLUMN "public"."quotes"."ticket_id" IS 'Referencia al ticket origen del presupuesto (si aplica)';



COMMENT ON COLUMN "public"."quotes"."scheduled_conversion_date" IS 'Fecha programada para la conversión automática a factura. Null si no hay conversión programada.';



COMMENT ON COLUMN "public"."quotes"."rectification_reason" IS 'Motivo de rectificación cuando el presupuesto es una rectificativa de una factura. Se copia a la factura resultante.';



CREATE OR REPLACE FUNCTION "public"."client_get_visible_quotes"() RETURNS SETOF "public"."quotes"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  WITH user_mapping AS (
    SELECT company_id, client_id
    FROM public.client_portal_users
    WHERE is_active = true
      AND lower(email) = public.auth_user_email()
    LIMIT 1
  )
  SELECT q.*
  FROM public.quotes q
  JOIN user_mapping m ON m.company_id = q.company_id AND m.client_id = q.client_id
$$;


ALTER FUNCTION "public"."client_get_visible_quotes"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."client_get_visible_quotes"() IS 'Returns quotes for the client mapped to the current auth email.';



CREATE TABLE IF NOT EXISTS "public"."tickets" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ticket_number" integer NOT NULL,
    "client_id" "uuid",
    "company_id" "uuid",
    "stage_id" "uuid",
    "title" character varying(200) NOT NULL,
    "description" "text",
    "priority" character varying(20) DEFAULT 'normal'::character varying,
    "due_date" "date",
    "comments" "text"[],
    "total_amount" numeric(10,2) DEFAULT 0.00,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone,
    "estimated_hours" numeric(5,2) DEFAULT 0,
    "actual_hours" numeric(5,2) DEFAULT 0,
    "is_opened" boolean DEFAULT false NOT NULL,
    "ticket_month" "date",
    "assigned_to" "uuid",
    "closed_at" timestamp with time zone,
    "first_response_at" timestamp with time zone,
    "resolution_time_mins" integer,
    "sla_status" "text" DEFAULT 'ok'::"text",
    "custom_fields" "jsonb" DEFAULT '{}'::"jsonb",
    "created_by" "uuid",
    "ticket_type" "text" DEFAULT 'incident'::"text",
    "status" "text" DEFAULT 'open'::"text"
);


ALTER TABLE "public"."tickets" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."client_get_visible_tickets"() RETURNS SETOF "public"."tickets"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  WITH user_mapping AS (
    SELECT company_id, client_id
    FROM public.client_portal_users
    WHERE is_active = true
      AND lower(email) = public.auth_user_email()
    LIMIT 1
  )
  SELECT t.*
  FROM public.tickets t
  JOIN user_mapping m ON m.company_id = t.company_id AND m.client_id = t.client_id
$$;


ALTER FUNCTION "public"."client_get_visible_tickets"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."client_get_visible_tickets"() IS 'Returns tickets for the client mapped to the current auth email.';



CREATE OR REPLACE FUNCTION "public"."client_reschedule_booking"("p_booking_id" "uuid", "p_new_start_time" timestamp with time zone, "p_new_end_time" timestamp with time zone) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_booking RECORD;
    v_user_id UUID;
    v_client_id UUID;
    v_count INTEGER;
BEGIN
    v_user_id := auth.uid();

    -- 1. Find Client ID
    SELECT id INTO v_client_id FROM public.clients WHERE auth_user_id = v_user_id;
    IF v_client_id IS NULL THEN
        SELECT c.id INTO v_client_id
        FROM public.clients c
        JOIN public.client_portal_users cpu ON c.id = cpu.client_id
        WHERE cpu.email = (SELECT email FROM auth.users WHERE id = v_user_id);
    END IF;

    IF v_client_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Client profile not found');
    END IF;

    -- 2. Verify Ownership
    SELECT * INTO v_booking FROM public.bookings WHERE id = p_booking_id AND client_id = v_client_id;

    IF v_booking IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Booking not found or access denied');
    END IF;

    -- 3. Check for Conflicts (Simple time check)
    -- Ignore self
    SELECT count(*) INTO v_count
    FROM public.bookings
    WHERE resource_id IS NOT DISTINCT FROM v_booking.resource_id -- If resource assigned, check for conflict
      AND status NOT IN ('cancelled', 'rejected')
      AND id != p_booking_id
      AND (
          (start_time <= p_new_start_time AND end_time > p_new_start_time) OR
          (start_time < p_new_end_time AND end_time >= p_new_end_time) OR
          (start_time >= p_new_start_time AND end_time <= p_new_end_time)
      );
    
    -- Note: This is a basic check. Full check would require checking professional availability schedules.
    -- For now, we trust the frontend Wizard to picked a valid slot via `find_available_slots`.
    -- If we enforce strict backend check, we'd need to call `check_availability` logic here.
    -- Letting it pass if simple conflict check passes.

    IF v_count > 0 THEN
         -- RETURN jsonb_build_object('success', false, 'error', 'Selected time slot is not available');
         -- For MVP, warn but maybe allow if it's just a simple rescheduling? No, conflict is bad.
         RETURN jsonb_build_object('success', false, 'error', 'Time slot conflict detected');
    END IF;

    -- 4. Update Booking
    UPDATE public.bookings
    SET start_time = p_new_start_time,
        end_time = p_new_end_time,
        status = 'rescheduled', -- Or keep 'confirmed'? 'rescheduled' is better for history tracking.
        updated_at = NOW()
    WHERE id = p_booking_id;

    -- 5. Update Link in Quote? 
    -- Quote description often has the date. We might want to append a note.
    IF v_booking.quote_id IS NOT NULL THEN
        UPDATE public.quotes
        SET description = description || E'\n[Rescheduled to ' || p_new_start_time::text || ']',
            updated_at = NOW()
        WHERE id = v_booking.quote_id;
    END IF;

    RETURN jsonb_build_object('success', true);

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."client_reschedule_booking"("p_booking_id" "uuid", "p_new_start_time" timestamp with time zone, "p_new_end_time" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."client_update_preferences"("p_email_notifications" boolean, "p_sms_notifications" boolean, "p_marketing_accepted" boolean) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_user_id UUID := auth.uid();
BEGIN
    IF v_user_id IS NULL THEN
        RAISE EXCEPTION 'Not authenticated';
    END IF;

    -- Upsert preferences
    INSERT INTO public.user_preferences (user_id, email_notifications, sms_notifications, marketing_accepted, updated_at)
    VALUES (v_user_id, p_email_notifications, p_sms_notifications, p_marketing_accepted, NOW())
    ON CONFLICT (user_id)
    DO UPDATE SET
        email_notifications = EXCLUDED.email_notifications,
        sms_notifications = EXCLUDED.sms_notifications,
        marketing_accepted = EXCLUDED.marketing_accepted,
        updated_at = NOW();

    RETURN jsonb_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."client_update_preferences"("p_email_notifications" boolean, "p_sms_notifications" boolean, "p_marketing_accepted" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."client_update_profile"("p_full_name" "text", "p_phone" "text", "p_avatar_url" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_user_id UUID := auth.uid();
    v_client_id UUID;
    v_result JSONB;
BEGIN
    IF v_user_id IS NULL THEN
        RAISE EXCEPTION 'Not authenticated';
    END IF;

    -- Update public.users
    UPDATE public.users
    SET
        name = p_full_name,
        phone = p_phone,
        avatar_url = COALESCE(p_avatar_url, avatar_url),
        updated_at = NOW()
    WHERE id = v_user_id;

    -- Update public.clients (Sync by email)
    UPDATE public.clients
    SET
        name = p_full_name,
        phone = p_phone,
        updated_at = NOW()
    WHERE email = (SELECT email FROM auth.users WHERE id = v_user_id);

    v_result := jsonb_build_object(
        'success', true,
        'user_id', v_user_id
    );

    RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."client_update_profile"("p_full_name" "text", "p_phone" "text", "p_avatar_url" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."column_exists"("table_name" "text", "column_name" "text") RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = column_exists.table_name 
        AND column_name = column_exists.column_name
    );
END;
$$;


ALTER FUNCTION "public"."column_exists"("table_name" "text", "column_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."company_has_module"("p_company_id" "uuid", "p_module_key" "text") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.company_modules
    WHERE company_id = p_company_id
      AND module_key = p_module_key
      AND status = 'active'
  );
$$;


ALTER FUNCTION "public"."company_has_module"("p_company_id" "uuid", "p_module_key" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."confirm_user_registration"("p_auth_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_pending RECORD;
    v_company_id UUID;
    v_user_id UUID;
    v_existing_company RECORD;
BEGIN
    -- 1. Buscar registro pendiente
    SELECT * INTO v_pending
    FROM pending_users
    WHERE auth_user_id = p_auth_user_id
      AND confirmed_at IS NULL
      AND (expires_at IS NULL OR expires_at > NOW())
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_pending IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'No pending registration found');
    END IF;

    -- 2. Verificar si ya existe usuario en la tabla users
    SELECT id INTO v_user_id
    FROM users
    WHERE auth_user_id = p_auth_user_id;

    IF v_user_id IS NOT NULL THEN
        UPDATE pending_users SET confirmed_at = NOW() WHERE id = v_pending.id;
        RETURN jsonb_build_object('success', true, 'already_exists', true);
    END IF;

    -- 3. Verificar si la empresa ya existe
    SELECT id INTO v_existing_company
    FROM companies
    WHERE LOWER(TRIM(name)) = LOWER(TRIM(v_pending.company_name))
    LIMIT 1;

    IF v_existing_company.id IS NOT NULL THEN
        RETURN jsonb_build_object(
            'success', false, 
            'requires_invitation_approval', true,
            'company_id', v_existing_company.id,
            'company_name', v_pending.company_name
        );
    END IF;

    -- 4. Crear empresa nueva CON NIF
    INSERT INTO companies (name, slug, nif)
    VALUES (
        COALESCE(v_pending.company_name, 'Mi Empresa'),
        LOWER(REGEXP_REPLACE(COALESCE(v_pending.company_name, 'mi-empresa'), '[^a-zA-Z0-9]+', '-', 'g')) || '-' || FLOOR(RANDOM() * 1000000000)::TEXT,
        v_pending.company_nif
    )
    RETURNING id INTO v_company_id;

    -- 5. Crear usuario como owner
    INSERT INTO users (email, name, surname, role, active, company_id, auth_user_id, permissions)
    VALUES (
        v_pending.email,
        COALESCE(v_pending.given_name, SPLIT_PART(v_pending.full_name, ' ', 1), 'Usuario'),
        v_pending.surname,
        'owner',
        true,
        v_company_id,
        p_auth_user_id,
        '{}'::JSONB
    )
    RETURNING id INTO v_user_id;

    -- 6. Marcar como confirmado
    UPDATE pending_users SET confirmed_at = NOW() WHERE id = v_pending.id;

    RETURN jsonb_build_object(
        'success', true,
        'company_id', v_company_id,
        'user_id', v_user_id
    );
END;
$$;


ALTER FUNCTION "public"."confirm_user_registration"("p_auth_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."confirm_user_registration"("p_auth_user_id" "uuid", "p_confirmation_token" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  pending_user_data public.pending_users;
  existing_company_info RECORD;
  new_company_id UUID;
  new_user_id UUID;
  owner_user_id UUID;
  v_owner_role_id UUID;
  v_member_role_id UUID;
BEGIN
  IF auth.uid() IS DISTINCT FROM p_auth_user_id THEN
    RETURN json_build_object('success', false, 'error', 'Unauthorized');
  END IF;

  SELECT * INTO pending_user_data
  FROM public.pending_users
  WHERE auth_user_id = p_auth_user_id
    AND (p_confirmation_token IS NULL OR confirmation_token = p_confirmation_token)
    AND confirmed_at IS NULL
    AND expires_at > NOW();

  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Invalid or expired confirmation');
  END IF;

  SELECT id INTO v_owner_role_id FROM public.app_roles WHERE name = 'owner';
  SELECT id INTO v_member_role_id FROM public.app_roles WHERE name = 'member';

  IF pending_user_data.company_name IS NOT NULL AND TRIM(pending_user_data.company_name) <> '' THEN
    SELECT * INTO existing_company_info
    FROM check_company_exists(pending_user_data.company_name);

    IF existing_company_info.company_exists THEN
      -- Find Owner using company_members + app_roles
      SELECT cm.user_id INTO owner_user_id
      FROM public.company_members cm
      JOIN public.app_roles ar ON cm.role_id = ar.id
      WHERE cm.company_id = existing_company_info.company_id 
        AND ar.name = 'owner' 
        AND cm.status = 'active'
      LIMIT 1;

      IF owner_user_id IS NOT NULL THEN
        -- Create Pending Invitation
        INSERT INTO public.company_invitations (company_id, email, invited_by_user_id, role, status, message)
        VALUES (existing_company_info.company_id, pending_user_data.email, owner_user_id, 'member', 'pending',
                'Solicitud automática generada durante el registro');

        UPDATE public.pending_users
        SET confirmed_at = NOW()
        WHERE auth_user_id = p_auth_user_id;

        RETURN json_build_object(
          'success', true,
          'requires_invitation_approval', true,
          'company_name', existing_company_info.company_name,
          'owner_email', existing_company_info.owner_email,
          'message', 'Company already exists. Invitation sent to company owner for approval.'
        );
      END IF;
    END IF;
  END IF;

  -- Create New Company
  INSERT INTO public.companies (name, slug, is_active)
  VALUES (
    COALESCE(NULLIF(TRIM(pending_user_data.company_name), ''), SPLIT_PART(pending_user_data.email, '@', 1)),
    LOWER(COALESCE(NULLIF(TRIM(pending_user_data.company_name), ''), SPLIT_PART(pending_user_data.email, '@', 1))) 
      || '-' || EXTRACT(EPOCH FROM NOW())::BIGINT,
    true
  )
  RETURNING id INTO new_company_id;

  -- Create New User
  INSERT INTO public.users (email, name, surname, active, company_id, auth_user_id, permissions)
  VALUES (
    pending_user_data.email,
    COALESCE(NULLIF(pending_user_data.given_name, ''), split_part(pending_user_data.full_name, ' ', 1), split_part(pending_user_data.email, '@', 1)),
    COALESCE(NULLIF(pending_user_data.surname, ''), NULLIF(regexp_replace(pending_user_data.full_name, '^[^\\s]+\\s*', ''), '')),
    true,
    new_company_id,
    pending_user_data.auth_user_id,
    '{}'::jsonb
  )
  RETURNING id INTO new_user_id;
  
  -- Create Owner Membership
  INSERT INTO public.company_members (user_id, company_id, role_id, status)
  VALUES (new_user_id, new_company_id, v_owner_role_id, 'active');

  UPDATE public.pending_users
  SET confirmed_at = NOW()
  WHERE auth_user_id = p_auth_user_id;

  RETURN json_build_object('success', true, 'company_id', new_company_id, 'user_id', new_user_id, 'is_owner', true, 'message', 'Registration confirmed successfully. New company created.');
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."confirm_user_registration"("p_auth_user_id" "uuid", "p_confirmation_token" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."contract_service_rpc"("p_service_id" "uuid", "p_variant_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_user_id uuid := auth.uid();
    v_client_id uuid;
    v_company_id uuid;
    v_service_name text;
    v_variant_name text;
    v_ticket_id uuid;
    v_description text;
    v_stage_id uuid;
BEGIN
    -- 1. Identify Client & Company from Auth User
    SELECT id, company_id INTO v_client_id, v_company_id
    FROM public.clients
    WHERE auth_user_id = v_user_id
    LIMIT 1;

    IF v_client_id IS NULL THEN
        RAISE EXCEPTION 'User is not a registered client' USING ERRCODE = 'P0001';
    END IF;

    -- 2. Get Service Info
    SELECT name INTO v_service_name
    FROM public.services
    WHERE id = p_service_id;

    IF v_service_name IS NULL THEN
        RAISE EXCEPTION 'Service not found' USING ERRCODE = 'P0002';
    END IF;

    -- 3. Get Variant Info (Optional)
    IF p_variant_id IS NOT NULL THEN
        SELECT name INTO v_variant_name
        FROM public.service_variants
        WHERE id = p_variant_id;
    END IF;

    -- 4. Construct Description
    v_description := 'Solicitud de contratación de servicio: ' || v_service_name;
    IF v_variant_name IS NOT NULL THEN
        v_description := v_description || E'\nVariante: ' || v_variant_name;
    END IF;
    v_description := v_description || E'\n\n(Generado automáticamente por RPC. Por favor, procesar manualmente la factura/presupuesto).';

    -- 5. Find Default Stage (lowest position)
    SELECT id INTO v_stage_id
    FROM public.ticket_stages
    WHERE deleted_at IS NULL
    ORDER BY position ASC, created_at ASC
    LIMIT 1;

    -- 6. Create Ticket
    INSERT INTO public.tickets (
        company_id,
        client_id,
        title,
        description,
        priority,
        stage_id,
        is_opened,
        created_at,
        updated_at
        -- device_id not relevant for services usually
    ) VALUES (
        v_company_id,
        v_client_id,
        'Contratación: ' || v_service_name,
        v_description,
        'normal',
        v_stage_id,
        true,
        NOW(),
        NOW()
    )
    RETURNING id INTO v_ticket_id;

    -- 7. Return Success JSON
    RETURN jsonb_build_object(
        'success', true,
        'action', 'ticket_created',
        'ticket_id', v_ticket_id,
        'message', 'Solicitud recibida correctamente. Nos pondremos en contacto contigo.'
    );
END;
$$;


ALTER FUNCTION "public"."contract_service_rpc"("p_service_id" "uuid", "p_variant_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."convert_quote_to_invoice"("p_quote_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_quote record;
    v_invoice_id UUID;
    v_user_company_id UUID;
    v_client_id UUID; -- ID del usuario autenticado si es cliente
BEGIN
    -- Obtener company_id del usuario actual (si es staff)
    SELECT company_id INTO v_user_company_id
    FROM public.users
    WHERE auth_user_id = auth.uid();

    -- Si no es staff, verificar si es cliente (Portal)
    IF v_user_company_id IS NULL THEN
        SELECT id INTO v_client_id
        FROM public.clients
        WHERE email = (SELECT email FROM auth.users WHERE id = auth.uid())
        LIMIT 1;
    END IF;

    -- Cargar el presupuesto
    SELECT * INTO v_quote FROM public.quotes WHERE id = p_quote_id;

    IF v_quote IS NULL THEN
        RAISE EXCEPTION 'Presupuesto no encontrado';
    END IF;

    -- VALIDACIÓN DE SEGURIDAD
    IF v_user_company_id IS NOT NULL THEN
        -- Caso Staff: Debe pertenecer a la misma empresa
        IF v_quote.company_id != v_user_company_id THEN
             RAISE EXCEPTION 'Acceso denegado: El presupuesto pertenece a otra organización';
        END IF;
    ELSIF v_client_id IS NOT NULL THEN
        -- Caso Cliente: Debe ser el dueño del presupuesto
        IF v_quote.client_id != v_client_id THEN
             RAISE EXCEPTION 'Acceso denegado: No eres el titular de este presupuesto';
        END IF;
    ELSE
        RAISE EXCEPTION 'Usuario no autorizado para esta operación';
    END IF;

    -- Lógica original de conversión (simplificada para asegurar integridad)
    INSERT INTO public.invoices (
        company_id, client_id, invoice_date, status, total, currency,
        invoice_type, notes
    ) VALUES (
        v_quote.company_id,
        v_quote.client_id,
        CURRENT_DATE,
        'draft', -- Siempre iniciar como borrador para seguridad
        v_quote.total_amount,
        'EUR', -- Default o tomar de quote si existe columna currency
        'normal',
        'Generado desde presupuesto ' || v_quote.quote_number
    ) RETURNING id INTO v_invoice_id;

    -- Copiar items
    INSERT INTO public.invoice_items (
        invoice_id, description, quantity, unit_price, tax_rate, total
    )
    SELECT 
        v_invoice_id,
        description,
        quantity,
        unit_price,
        0, -- Asumir 0 o calcular si existe tax en quote_items
        total
    FROM public.quote_items
    WHERE quote_id = p_quote_id;

    -- Marcar presupuesto como facturado
    UPDATE public.quotes 
    SET status = 'invoiced', invoice_id = v_invoice_id 
    WHERE id = p_quote_id;

    RETURN v_invoice_id;
END;
$$;


ALTER FUNCTION "public"."convert_quote_to_invoice"("p_quote_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."convert_quote_to_invoice"("p_quote_id" "uuid", "p_invoice_series_id" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_quote public.quotes%rowtype;
  v_invoice_id uuid;
  v_series_id uuid;
  v_series_label text;
  v_invoice_number text;
  v_item record;
  v_invoice_type invoice_type;
  v_recurrence_period text;
  v_is_recurring boolean;
  v_created_by uuid;
BEGIN
  -- Load quote
  SELECT * INTO v_quote FROM public.quotes WHERE id = p_quote_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Quote % not found', p_quote_id;
  END IF;

  -- Validate state
  IF v_quote.status <> 'accepted' AND v_quote.status <> 'invoiced' AND v_quote.status <> 'active' THEN
    RAISE EXCEPTION 'Solo se pueden convertir presupuestos aceptados o activos';
  END IF;
  
  -- Allow conversion if recurring (even if already has invoice_id, as it generates multiple)
  -- BUT strict check: for non-recurring, prevent duplicates
  v_is_recurring := v_quote.recurrence_type IS NOT NULL AND v_quote.recurrence_type <> 'none';

  IF NOT v_is_recurring AND v_quote.invoice_id IS NOT NULL THEN
    RAISE EXCEPTION 'Este presupuesto ya fue convertido a factura';
  END IF;

  -- Determinar el tipo de factura
  IF v_quote.rectifies_invoice_id IS NOT NULL OR (v_quote.total_amount < 0) THEN
    v_invoice_type := 'rectificative'::invoice_type;
  ELSE
    v_invoice_type := 'normal'::invoice_type;
  END IF;

  -- Calculate recurrence_period
  IF v_is_recurring THEN
    v_recurrence_period := to_char(current_date, 'YYYY-MM');
  ELSE
    v_recurrence_period := NULL;
  END IF;

  -- Resolve series
  IF p_invoice_series_id IS NULL THEN
    SELECT id INTO v_series_id
      FROM public.invoice_series
     WHERE company_id = v_quote.company_id
       AND is_active = true
       AND is_default = true
     ORDER BY year DESC
     LIMIT 1;
  ELSE
    v_series_id := p_invoice_series_id;
  END IF;
  
  IF v_series_id IS NULL THEN
    RAISE EXCEPTION 'No hay serie de factura por defecto configurada';
  END IF;

  -- Build series label and get next number
  SELECT (year::text || '-' || series_code) INTO v_series_label 
    FROM public.invoice_series WHERE id = v_series_id;
  SELECT get_next_invoice_number(v_series_id) INTO v_invoice_number;

  -- VALIDAR created_by
  IF v_quote.created_by IS NULL OR NOT EXISTS (SELECT 1 FROM public.users WHERE id = v_quote.created_by) THEN
    SELECT id INTO v_created_by 
      FROM public.users 
     WHERE company_id = v_quote.company_id 
       AND role = 'owner'
     LIMIT 1;
    IF v_created_by IS NULL THEN
      SELECT id INTO v_created_by 
        FROM public.users 
       WHERE company_id = v_quote.company_id 
       LIMIT 1;
    END IF;
  ELSE
    v_created_by := v_quote.created_by;
  END IF;

  -- INSERT using 'draft' status
  INSERT INTO public.invoices (
    company_id,
    client_id,
    series_id,
    invoice_number,
    invoice_series,
    invoice_type,
    invoice_date,
    due_date,
    subtotal,
    tax_amount,
    total,
    currency,
    status,           -- 'draft'
    notes,
    rectifies_invoice_id,
    rectification_reason,
    created_by,
    source_quote_id,
    recurrence_period
  ) VALUES (
    v_quote.company_id,
    v_quote.client_id,
    v_series_id,
    v_invoice_number,
    v_series_label,
    v_invoice_type,
    current_date,
    current_date + interval '30 days',
    v_quote.subtotal,
    v_quote.tax_amount,
    v_quote.total_amount,
    v_quote.currency,
    'draft',          
    'Generada desde presupuesto: ' || coalesce(v_quote.full_quote_number, v_quote.quote_number),
    v_quote.rectifies_invoice_id,
    v_quote.rectification_reason,
    v_created_by,
    CASE WHEN v_is_recurring THEN p_quote_id ELSE NULL END,
    v_recurrence_period
  ) RETURNING id INTO v_invoice_id;

  -- Copy items
  FOR v_item IN
    SELECT * FROM public.quote_items WHERE quote_id = p_quote_id ORDER BY line_number
  LOOP
    INSERT INTO public.invoice_items (
      invoice_id,
      line_order,
      description,
      quantity,
      unit_price,
      discount_percent,
      tax_rate,
      tax_amount,
      subtotal,
      total
    ) VALUES (
      v_invoice_id,
      v_item.line_number,
      v_item.description,
      v_item.quantity,
      v_item.unit_price,
      coalesce(v_item.discount_percent, 0),
      v_item.tax_rate,
      v_item.tax_amount,
      v_item.subtotal,
      v_item.total
    );
  END LOOP;

  -- Update quote
  -- KEY CHANGE: If recurring, do NOT set status to 'invoiced' (which essentially closes it).
  -- Keep it as is (accepted) or let the Payment Trigger upgrade it to 'active'.
  UPDATE public.quotes
     SET invoice_id = v_invoice_id,
         status = CASE WHEN v_is_recurring THEN status ELSE 'invoiced' END,
         invoiced_at = now(),
         updated_at = now(),
         last_run_at = CASE WHEN v_is_recurring THEN now() ELSE last_run_at END
   WHERE id = p_quote_id;

  RETURN v_invoice_id;
END
$$;


ALTER FUNCTION "public"."convert_quote_to_invoice"("p_quote_id" "uuid", "p_invoice_series_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."count_customers_by_user"("target_user_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    customer_count INTEGER;
    user_company_id uuid;
BEGIN
    -- Obtener company_id del usuario
    SELECT company_id INTO user_company_id 
    FROM public.users 
    WHERE auth_user_id = target_user_id;
    
    -- Contar clientes de la empresa del usuario
    SELECT COUNT(*)
    INTO customer_count
    FROM public.clients c
    WHERE c.company_id = user_company_id
    AND c.deleted_at IS NULL
    AND c.anonymized_at IS NULL;  -- No contar anonimizados
    
    RETURN COALESCE(customer_count, 0);
END;
$$;


ALTER FUNCTION "public"."count_customers_by_user"("target_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_address_dev"("target_user_id" "uuid", "p_direccion" character varying, "p_numero" character varying DEFAULT NULL::character varying, "p_piso" character varying DEFAULT NULL::character varying, "p_puerta" character varying DEFAULT NULL::character varying, "p_codigo_postal" character varying DEFAULT NULL::character varying, "p_locality_id" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    new_address_id uuid;
BEGIN
    INSERT INTO public.addresses (
        usuario_id,
        direccion,
        numero,
        piso,
        puerta,
        codigo_postal,
        locality_id
    ) VALUES (
        target_user_id,
        p_direccion,
        p_numero,
        p_piso,
        p_puerta,
        p_codigo_postal,
        p_locality_id
    )
    RETURNING id INTO new_address_id;
    
    RETURN new_address_id;
END;
$$;


ALTER FUNCTION "public"."create_address_dev"("target_user_id" "uuid", "p_direccion" character varying, "p_numero" character varying, "p_piso" character varying, "p_puerta" character varying, "p_codigo_postal" character varying, "p_locality_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_address_dev"("target_user_id" "uuid", "p_direccion" character varying, "p_numero" character varying, "p_piso" character varying, "p_puerta" character varying, "p_codigo_postal" character varying, "p_locality_id" "uuid") IS 'Función RPC para crear direcciones en modo desarrollo';



CREATE OR REPLACE FUNCTION "public"."create_address_rpc"("p_direccion" "text", "p_locality_id" "uuid", "p_numero" "text" DEFAULT NULL::"text", "p_piso" "text" DEFAULT NULL::"text", "p_puerta" "text" DEFAULT NULL::"text", "p_bloque" "text" DEFAULT NULL::"text", "p_escalera" "text" DEFAULT NULL::"text", "p_cod_postal" "text" DEFAULT NULL::"text", "p_provincia" "text" DEFAULT NULL::"text", "p_pais" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_user_id uuid;
  v_address_id uuid;
BEGIN
  -- Validate Auth
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Insert
  INSERT INTO addresses (
    usuario_id, 
    direccion, 
    locality_id, 
    numero, 
    piso, 
    puerta, 
    bloque, 
    escalera, 
    cod_postal, 
    provincia, 
    pais
  ) VALUES (
    v_user_id,
    p_direccion,
    p_locality_id,
    p_numero,
    p_piso,
    p_puerta,
    p_bloque,
    p_escalera,
    p_cod_postal,
    p_provincia,
    p_pais
  )
  RETURNING id INTO v_address_id;

  RETURN json_build_object('id', v_address_id);
END;
$$;


ALTER FUNCTION "public"."create_address_rpc"("p_direccion" "text", "p_locality_id" "uuid", "p_numero" "text", "p_piso" "text", "p_puerta" "text", "p_bloque" "text", "p_escalera" "text", "p_cod_postal" "text", "p_provincia" "text", "p_pais" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_attachment"("p_company_id" "uuid", "p_job_id" "uuid", "p_file_name" "text", "p_file_size" integer DEFAULT NULL::integer, "p_mime_type" "text" DEFAULT NULL::"text", "p_subfolder" "text" DEFAULT 'attachments'::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  attachment_id uuid;
  file_path text;
BEGIN
  -- Validar que el job pertenece a la company
  IF NOT EXISTS (
    SELECT 1 FROM public.jobs 
    WHERE id = p_job_id 
    AND company_id = p_company_id 
    AND deleted_at IS NULL
  ) THEN
    RAISE EXCEPTION 'Job does not belong to company or does not exist';
  END IF;
  
  -- Generar ruta segura
  file_path := public.generate_file_path(p_company_id, p_file_name, p_subfolder);
  
  -- Crear registro
  INSERT INTO public.attachments (
    company_id, job_id, file_name, file_path, file_size, mime_type
  ) VALUES (
    p_company_id, p_job_id, p_file_name, file_path, p_file_size, p_mime_type
  ) RETURNING id INTO attachment_id;
  
  RETURN attachment_id;
END;
$$;


ALTER FUNCTION "public"."create_attachment"("p_company_id" "uuid", "p_job_id" "uuid", "p_file_name" "text", "p_file_size" integer, "p_mime_type" "text", "p_subfolder" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_clinical_note"("p_client_id" "uuid", "p_content" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_note_id uuid;
    v_encrypted_content text;
    v_encryption_key text; 
    v_company_id uuid;
BEGIN
    -- 1. Permission Check: Is the user an active member?
    SELECT c.company_id INTO v_company_id
    FROM public.clients c
    JOIN public.company_members cm ON c.company_id = cm.company_id
    WHERE c.id = p_client_id
    AND cm.user_id = auth.uid()
    AND cm.status = 'active';

    IF v_company_id IS NULL THEN
        RAISE EXCEPTION 'Access denied: User is not an active member of the client company';
    END IF;

    v_encryption_key := 'simplifica-secure-key-2026';

    -- 3. Encrypt
    v_encrypted_content := extensions.pgp_sym_encrypt(p_content, v_encryption_key);

    -- 4. Insert
    INSERT INTO public.client_clinical_notes (client_id, content, created_by)
    VALUES (p_client_id, v_encrypted_content, auth.uid())
    RETURNING id INTO v_note_id;

    RETURN jsonb_build_object(
        'id', v_note_id,
        'success', true
    );
END;
$$;


ALTER FUNCTION "public"."create_clinical_note"("p_client_id" "uuid", "p_content" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_company_with_owner"("p_name" "text", "p_slug" "text", "p_nif" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
  v_auth_user_id uuid;
  v_app_user_id uuid;
  v_owner_role_id uuid;
  v_auth_email text;
  v_given_name text;
  v_surname text;
BEGIN
  -- Get current auth user
  v_auth_user_id := auth.uid();
  IF v_auth_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get auth user metadata
  SELECT 
    au.email,
    COALESCE(au.raw_user_meta_data->>'given_name', split_part(au.raw_user_meta_data->>'full_name', ' ', 1), split_part(au.email, '@', 1)),
    COALESCE(au.raw_user_meta_data->>'surname', NULLIF(regexp_replace(au.raw_user_meta_data->>'full_name', '^[^\s]+\s*', ''), ''))
  INTO v_auth_email, v_given_name, v_surname
  FROM auth.users au
  WHERE au.id = v_auth_user_id;

  -- Ensure user exists in public.users (create if not)
  SELECT id INTO v_app_user_id FROM public.users WHERE auth_user_id = v_auth_user_id;
  
  IF v_app_user_id IS NULL THEN
    INSERT INTO public.users (email, name, surname, active, auth_user_id, permissions)
    VALUES (v_auth_email, COALESCE(v_given_name, 'Usuario'), v_surname, true, v_auth_user_id, '{}'::jsonb)
    RETURNING id INTO v_app_user_id;
  END IF;

  -- Get owner role id
  SELECT id INTO v_owner_role_id FROM app_roles WHERE name = 'owner';
  IF v_owner_role_id IS NULL THEN
    RAISE EXCEPTION 'Owner role not found in app_roles';
  END IF;

  -- Insert Company
  INSERT INTO companies (name, slug, nif, is_active)
  VALUES (p_name, p_slug, p_nif, true)
  RETURNING id INTO v_company_id;

  -- Insert Member
  INSERT INTO company_members (user_id, company_id, role_id, status)
  VALUES (v_app_user_id, v_company_id, v_owner_role_id, 'active');
  
  -- Update User's primary company
  UPDATE users SET company_id = v_company_id WHERE id = v_app_user_id AND company_id IS NULL;

  RETURN json_build_object(
    'success', true,
    'id', v_company_id,
    'name', p_name,
    'slug', p_slug,
    'user_id', v_app_user_id
  );
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."create_company_with_owner"("p_name" "text", "p_slug" "text", "p_nif" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying DEFAULT NULL::character varying, "p_dni" character varying DEFAULT NULL::character varying) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    new_client_id uuid;
    user_company_id uuid;
BEGIN
    -- Obtener company_id del usuario
    SELECT company_id INTO user_company_id 
    FROM public.users 
    WHERE auth_user_id = target_user_id;
    
    IF user_company_id IS NULL THEN
        RAISE EXCEPTION 'Usuario no tiene empresa asignada';
    END IF;
    
    -- Insertar en clients (no customers)
    INSERT INTO public.clients (
        company_id,
        name,
        apellidos,
        email,
        phone,
        dni,
        -- Campos GDPR obligatorios
        marketing_consent,
        data_processing_consent,
        data_processing_consent_date,
        data_processing_legal_basis,
        is_minor,
        access_count
    ) VALUES (
        user_company_id,
        p_nombre,
        p_apellidos,
        p_email,
        p_telefono,
        p_dni,
        false,  -- Marketing consent por defecto NO
        true,   -- Processing consent por defecto SÍ
        now(),
        'contract',
        false,
        0
    )
    RETURNING id INTO new_client_id;
    
    RETURN new_client_id;
END;
$$;


ALTER FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" "text", "p_apellidos" "text", "p_email" "text", "p_telefono" "text" DEFAULT NULL::"text", "p_dni" "text" DEFAULT NULL::"text", "p_fecha_nacimiento" "date" DEFAULT NULL::"date", "p_profesion" "text" DEFAULT NULL::"text", "p_empresa" "text" DEFAULT NULL::"text", "p_avatar_url" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    new_client_id uuid;
    user_company_id uuid;
BEGIN
    -- Obtener company_id del usuario
    SELECT company_id INTO user_company_id 
    FROM public.users 
    WHERE auth_user_id = target_user_id;
    
    IF user_company_id IS NULL THEN
        RAISE EXCEPTION 'Usuario no tiene empresa asignada';
    END IF;
    
    -- Insertar en clients (no customers)
    INSERT INTO public.clients (
        company_id,
        name,
        surname, -- RENAMED
        email,
        phone,
        dni,
        -- Campos GDPR obligatorios
        marketing_consent,
        data_processing_consent,
        data_processing_consent_date,
        data_processing_legal_basis,
        is_minor,
        access_count
    ) VALUES (
        user_company_id,
        p_nombre,
        p_apellidos, -- Parameter still named p_apellidos to avoid breaking signature if called elsewhere by name, but maps to surname column
        p_email,
        p_telefono,
        p_dni,
        false,  -- Marketing consent por defecto NO
        true,   -- Processing consent por defecto SÍ
        now(),
        'contract',
        false,
        0
    )
    RETURNING id INTO new_client_id;
    
    RETURN new_client_id;
END;
$$;


ALTER FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" "text", "p_apellidos" "text", "p_email" "text", "p_telefono" "text", "p_dni" "text", "p_fecha_nacimiento" "date", "p_profesion" "text", "p_empresa" "text", "p_avatar_url" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying DEFAULT NULL::character varying, "p_dni" character varying DEFAULT NULL::character varying, "p_fecha_nacimiento" "date" DEFAULT NULL::"date", "p_profesion" character varying DEFAULT NULL::character varying, "p_empresa" character varying DEFAULT NULL::character varying, "p_notas" "text" DEFAULT NULL::"text", "p_avatar_url" "text" DEFAULT NULL::"text", "p_direccion_id" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    new_customer_id uuid;
BEGIN
    INSERT INTO public.customers (
        usuario_id,
        nombre,
        apellidos,
        email,
        telefono,
        dni,
        fecha_nacimiento,
        profesion,
        empresa,
        notas,
        avatar_url,
        direccion_id,
        activo
    ) VALUES (
        target_user_id,
        p_nombre,
        p_apellidos,
        p_email,
        p_telefono,
        p_dni,
        p_fecha_nacimiento,
        p_profesion,
        p_empresa,
        p_notas,
        p_avatar_url,
        p_direccion_id,
        true
    )
    RETURNING id INTO new_customer_id;
    
    RETURN new_customer_id;
END;
$$;


ALTER FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying, "p_fecha_nacimiento" "date", "p_profesion" character varying, "p_empresa" character varying, "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying, "p_fecha_nacimiento" "date", "p_profesion" character varying, "p_empresa" character varying, "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid") IS 'Función RPC para crear clientes asignados a un usuario específico en modo desarrollo';



CREATE OR REPLACE FUNCTION "public"."create_default_project_stages"("company_uuid" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    INSERT INTO public.project_stages (company_id, name, position) VALUES
    (company_uuid, 'Por hacer', 0),
    (company_uuid, 'En progreso', 1),
    (company_uuid, 'Revisión', 2),
    (company_uuid, 'Terminado', 3);
END;
$$;


ALTER FUNCTION "public"."create_default_project_stages"("company_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_device_rpc"("p_company_id" "uuid", "p_client_id" "uuid", "p_brand" "text", "p_model" "text", "p_device_type" "text", "p_reported_issue" "text", "p_serial_number" "text" DEFAULT NULL::"text", "p_password" "text" DEFAULT NULL::"text", "p_imei" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_user_id uuid;
  v_user_company_id uuid;
  v_device_id uuid;
BEGIN
  -- Validate Auth
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Validate permissions (User must belong to company)
  SELECT company_id INTO v_user_company_id FROM users WHERE auth_user_id = v_user_id;
  
  -- If not staff, check if user IS the client (portal access)
  IF v_user_company_id IS NULL OR v_user_company_id != p_company_id THEN
     IF NOT EXISTS (SELECT 1 FROM clients WHERE auth_user_id = v_user_id AND id = p_client_id AND company_id = p_company_id) THEN
        RAISE EXCEPTION 'Permission denied for this company/client';
     END IF;
  END IF;

  -- Insert
  INSERT INTO devices (
    company_id,
    client_id,
    brand,
    model,
    device_type,
    reported_issue,
    serial_number,
    password,
    imei,
    status
  ) VALUES (
    p_company_id,
    p_client_id,
    p_brand,
    p_model,
    p_device_type,
    p_reported_issue,
    p_serial_number,
    p_password,
    p_imei,
    'received' -- Default status
  )
  RETURNING id INTO v_device_id;

  RETURN json_build_object('id', v_device_id);
END;
$$;


ALTER FUNCTION "public"."create_device_rpc"("p_company_id" "uuid", "p_client_id" "uuid", "p_brand" "text", "p_model" "text", "p_device_type" "text", "p_reported_issue" "text", "p_serial_number" "text", "p_password" "text", "p_imei" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_device_rpc"("p_company_id" "uuid", "p_client_id" "uuid", "p_brand" "text", "p_model" "text", "p_device_type" "text", "p_reported_issue" "text", "p_priority" "text" DEFAULT 'normal'::"text", "p_received_at" timestamp with time zone DEFAULT "now"(), "p_serial_number" "text" DEFAULT NULL::"text", "p_imei" "text" DEFAULT NULL::"text", "p_color" "text" DEFAULT NULL::"text", "p_condition_on_arrival" "text" DEFAULT NULL::"text", "p_operating_system" "text" DEFAULT NULL::"text", "p_storage_capacity" "text" DEFAULT NULL::"text", "p_estimated_cost" numeric DEFAULT NULL::numeric, "p_final_cost" numeric DEFAULT NULL::numeric) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_user_id uuid := auth.uid();
    v_user_valid boolean;
    v_client_company_id uuid;
    v_new_device_id uuid;
    v_result jsonb;
BEGIN
    -- 1. Validate User Membership
    SELECT EXISTS (
        SELECT 1 FROM public.users
        WHERE auth_user_id = v_user_id
          AND company_id = p_company_id
          AND active = true
    ) INTO v_user_valid;

    IF NOT v_user_valid THEN
        RAISE EXCEPTION 'User not allowed for this company' USING ERRCODE = 'P0001';
    END IF;

    -- 2. Validate Client belongs to Company
    SELECT company_id INTO v_client_company_id
    FROM public.clients
    WHERE id = p_client_id;

    IF v_client_company_id IS NULL OR v_client_company_id != p_company_id THEN
        RAISE EXCEPTION 'Client does not belong to the provided company' USING ERRCODE = 'P0002';
    END IF;

    -- 3. Insert Device
    INSERT INTO public.devices (
        company_id,
        client_id,
        brand,
        model,
        device_type,
        reported_issue,
        status,
        priority,
        received_at,
        serial_number,
        imei,
        color,
        condition_on_arrival,
        operating_system,
        storage_capacity,
        estimated_cost,
        final_cost,
        created_by
        -- created_at and updated_at handled by defaults/triggers
    ) VALUES (
        p_company_id,
        p_client_id,
        TRIM(p_brand),
        TRIM(p_model),
        TRIM(p_device_type),
        TRIM(p_reported_issue),
        'received',
        COALESCE(p_priority, 'normal'),
        COALESCE(p_received_at, NOW()),
        p_serial_number,
        p_imei,
        p_color,
        p_condition_on_arrival,
        p_operating_system,
        p_storage_capacity,
        p_estimated_cost,
        p_final_cost,
        v_user_id -- Assuming created_by maps to auth_user_id or we need to find internal user id?
                  -- The edge function used authUserId which is the Auth ID.
                  -- But devices.created_by might refer to public.users.id or auth ID.
                  -- Let's check schema or assume Auth ID if column type allows.
                  -- If devices.created_by is UUID references auth.users, it is fine.
                  -- If it references public.users, we need to fetch it.
    )
    RETURNING id INTO v_new_device_id;

    -- 4. Return the new device
    SELECT to_jsonb(d.*) INTO v_result
    FROM public.devices d
    WHERE d.id = v_new_device_id;

    RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."create_device_rpc"("p_company_id" "uuid", "p_client_id" "uuid", "p_brand" "text", "p_model" "text", "p_device_type" "text", "p_reported_issue" "text", "p_priority" "text", "p_received_at" timestamp with time zone, "p_serial_number" "text", "p_imei" "text", "p_color" "text", "p_condition_on_arrival" "text", "p_operating_system" "text", "p_storage_capacity" "text", "p_estimated_cost" numeric, "p_final_cost" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_gdpr_access_request"("p_subject_email" "text", "p_request_type" "text", "p_subject_name" "text" DEFAULT NULL::"text", "p_request_details" "jsonb" DEFAULT '{}'::"jsonb", "p_requesting_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_company_id uuid;
    v_request_id uuid;
    v_deadline_date timestamp with time zone;
BEGIN
    -- Validar tipo de solicitud
    IF p_request_type NOT IN ('access', 'rectification', 'erasure', 'portability', 'restriction', 'objection') THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Tipo de solicitud inválido. Valores permitidos: access, rectification, erasure, portability, restriction, objection'
        );
    END IF;
    
    -- Obtener company_id del usuario solicitante
    SELECT company_id INTO v_company_id
    FROM users
    WHERE auth_user_id = COALESCE(p_requesting_user_id, auth.uid());
    
    -- Calcular fecha límite (30 días por defecto según GDPR Art. 12.3)
    v_deadline_date := now() + INTERVAL '30 days';
    
    -- Crear solicitud
    INSERT INTO gdpr_access_requests (
        request_type,
        subject_email,
        subject_name,
        company_id,
        requested_by,
        request_details,
        verification_status,
        processing_status,
        deadline_date,
        created_at,
        updated_at
    ) VALUES (
        p_request_type,
        p_subject_email,
        p_subject_name,
        v_company_id,
        COALESCE(p_requesting_user_id, auth.uid()),
        p_request_details,
        'pending',
        'received',
        v_deadline_date,
        now(),
        now()
    )
    RETURNING id INTO v_request_id;
    
    -- Registrar en audit log
    INSERT INTO gdpr_audit_log (
        user_id,
        company_id,
        action_type,
        table_name,
        record_id,
        subject_email,
        purpose,
        new_values,
        created_at
    ) VALUES (
        COALESCE(p_requesting_user_id, auth.uid()),
        v_company_id,
        'access_request',
        'gdpr_access_requests',
        v_request_id,
        p_subject_email,
        'GDPR ' || p_request_type || ' request created',
        jsonb_build_object(
            'request_type', p_request_type,
            'deadline', v_deadline_date
        ),
        now()
    );
    
    RETURN jsonb_build_object(
        'success', true,
        'message', 'Solicitud GDPR creada correctamente',
        'request_id', v_request_id,
        'request_type', p_request_type,
        'subject_email', p_subject_email,
        'deadline_date', v_deadline_date,
        'status', 'received'
    );
    
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'error_detail', SQLSTATE
    );
END;
$$;


ALTER FUNCTION "public"."create_gdpr_access_request"("p_subject_email" "text", "p_request_type" "text", "p_subject_name" "text", "p_request_details" "jsonb", "p_requesting_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_gdpr_access_request"("p_subject_email" "text", "p_request_type" "text", "p_subject_name" "text", "p_request_details" "jsonb", "p_requesting_user_id" "uuid") IS 'Crea una solicitud de acceso GDPR (Art. 15-22)';



CREATE OR REPLACE FUNCTION "public"."create_locality_rpc"("p_name" "text", "p_postal_code" "text", "p_province" "text" DEFAULT NULL::"text", "p_country" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_locality_id uuid;
  v_normalized_cp text;
BEGIN
  -- Validate Auth
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Normalize Postal Code (digits only)
  v_normalized_cp := regexp_replace(p_postal_code, '\D', '', 'g');

  IF length(v_normalized_cp) = 0 THEN
      RAISE EXCEPTION 'Invalid postal code';
  END IF;

  -- Insert or Return Existing
  -- Assuming 'localities' table constraint on (postal_code, name) or similar unique key
  -- If not unique, we just insert. The edge function implied a potential "get" logic.
  
  SELECT id INTO v_locality_id 
  FROM localities 
  WHERE lower(name) = lower(p_name) AND postal_code = v_normalized_cp
  LIMIT 1;

  IF v_locality_id IS NOT NULL THEN
     RETURN json_build_object('id', v_locality_id, 'is_new', false);
  END IF;

  INSERT INTO localities (
    name,
    postal_code,
    province,
    country
  ) VALUES (
    p_name,
    v_normalized_cp,
    p_province,
    p_country
  )
  RETURNING id INTO v_locality_id;
  
  RETURN json_build_object('id', v_locality_id, 'is_new', true);
END;
$$;


ALTER FUNCTION "public"."create_locality_rpc"("p_name" "text", "p_postal_code" "text", "p_province" "text", "p_country" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_notification"("p_company_id" "uuid", "p_recipient_id" "uuid", "p_type" "text", "p_title" "text", "p_content" "text", "p_reference_id" "uuid", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_id UUID;
BEGIN
    INSERT INTO public.notifications (company_id, recipient_id, type, title, content, reference_id, metadata)
    VALUES (p_company_id, p_recipient_id, p_type, p_title, p_content, p_reference_id, p_metadata)
    RETURNING id INTO v_id;
    RETURN v_id;
EXCEPTION WHEN OTHERS THEN
    -- Prevent notification errors from blocking the main transaction
    RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."create_notification"("p_company_id" "uuid", "p_recipient_id" "uuid", "p_type" "text", "p_title" "text", "p_content" "text", "p_reference_id" "uuid", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_notification"("p_company_id" "uuid", "p_recipient_id" "uuid", "p_type" "text", "p_reference_id" "uuid", "p_title" "text", "p_content" "text", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_id UUID;
BEGIN
    INSERT INTO public.notifications (company_id, recipient_id, type, reference_id, title, content, metadata)
    VALUES (p_company_id, p_recipient_id, p_type, p_reference_id, p_title, p_content, p_metadata)
    RETURNING id INTO v_id;
    RETURN v_id;
END;
$$;


ALTER FUNCTION "public"."create_notification"("p_company_id" "uuid", "p_recipient_id" "uuid", "p_type" "text", "p_reference_id" "uuid", "p_title" "text", "p_content" "text", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_rectification_quote"("p_invoice_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_invoice RECORD;
  v_quote_id UUID;
  v_item RECORD;
  v_quote_number TEXT;
  v_sequence_number INTEGER;
  v_year INTEGER;
BEGIN
  -- 1. Obtener datos de la factura original
  SELECT * INTO v_invoice FROM public.invoices WHERE id = p_invoice_id;
  
  IF v_invoice IS NULL THEN
    RAISE EXCEPTION 'Factura no encontrada';
  END IF;

  -- 2. Calcular nuevo número de presupuesto (para la rectificativa)
  v_year := EXTRACT(YEAR FROM CURRENT_DATE);
  
  SELECT COALESCE(MAX(sequence_number), 0) + 1
  INTO v_sequence_number
  FROM public.quotes
  WHERE company_id = v_invoice.company_id AND year = v_year;
  
  -- CORRECCIÓN: Formato estándar YYYY-P-XXXXX (5 dígitos)
  v_quote_number := v_year || '-P-' || LPAD(v_sequence_number::TEXT, 5, '0');

  -- 3. Crear el presupuesto de rectificación
  INSERT INTO public.quotes (
    company_id,
    client_id,
    quote_number,
    sequence_number,
    year,
    quote_date,
    valid_until,
    status,
    title,
    subtotal,
    tax_amount,
    total_amount,
    notes,
    created_by
  ) VALUES (
    v_invoice.company_id,
    v_invoice.client_id,
    v_quote_number,
    v_sequence_number,
    v_year,
    CURRENT_DATE,
    CURRENT_DATE + INTERVAL '30 days',
    'draft', -- Se crea en borrador para revisión
    'Rectificación de factura ' || coalesce(v_invoice.full_invoice_number, v_invoice.invoice_series || '-' || v_invoice.invoice_number),
    v_invoice.subtotal * -1, -- Importes negativos por defecto para rectificativa
    v_invoice.tax_amount * -1,
    v_invoice.total * -1,
    'Rectificación de la factura ' || coalesce(v_invoice.full_invoice_number, v_invoice.invoice_series || '-' || v_invoice.invoice_number) || '. Motivo: ',
    auth.uid()
  ) RETURNING id INTO v_quote_id;

  -- 4. Copiar líneas de la factura al presupuesto (con importes negativos)
  FOR v_item IN SELECT * FROM public.invoice_items WHERE invoice_id = p_invoice_id LOOP
    INSERT INTO public.quote_items (
      quote_id,
      company_id,
      line_number,
      description,
      quantity,
      unit_price,
      discount_percent,
      tax_rate,
      tax_amount,
      subtotal,
      total
    ) VALUES (
      v_quote_id,
      v_invoice.company_id,
      v_item.line_order,
      v_item.description,
      v_item.quantity * -1, -- Cantidad negativa para rectificación
      v_item.unit_price,
      v_item.discount_percent,
      v_item.tax_rate,
      v_item.tax_amount * -1,
      v_item.subtotal * -1,
      v_item.total * -1
    );
  END LOOP;

  -- 5. Actualizar estado de la factura original a 'rectified'
  UPDATE public.invoices 
  SET status = 'rectified',
      updated_at = NOW()
  WHERE id = p_invoice_id;

  RETURN v_quote_id;
END;
$$;


ALTER FUNCTION "public"."create_rectification_quote"("p_invoice_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_rectification_quote"("p_invoice_id" "uuid", "p_rectification_reason" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_invoice RECORD;
  v_quote_id UUID;
  v_item RECORD;
  v_quote_number TEXT;
  v_sequence_number INTEGER;
  v_year INTEGER;
  v_company_id UUID;
  v_line_number INTEGER := 0;
BEGIN
  -- 1. Obtener datos de la factura original
  SELECT * INTO v_invoice FROM public.invoices WHERE id = p_invoice_id;
  
  IF v_invoice IS NULL THEN
    RAISE EXCEPTION 'Factura no encontrada';
  END IF;

  v_company_id := v_invoice.company_id;

  -- 2. Calcular nuevo número de presupuesto
  v_year := EXTRACT(YEAR FROM CURRENT_DATE);
  
  SELECT COALESCE(MAX(sequence_number), 0) + 1
  INTO v_sequence_number
  FROM public.quotes
  WHERE company_id = v_company_id 
    AND year = v_year;
  
  v_quote_number := v_year || '-P-' || LPAD(v_sequence_number::TEXT, 5, '0');

  -- 3. Crear el presupuesto rectificativo (con valores negativos)
  INSERT INTO public.quotes (
    company_id,
    client_id,
    quote_number,
    year,
    sequence_number,
    quote_date,
    valid_until,
    status,
    title,
    subtotal,
    tax_amount,
    total_amount,
    currency,
    notes,
    rectifies_invoice_id,
    rectification_reason,
    created_by
  ) VALUES (
    v_company_id,
    v_invoice.client_id,
    v_quote_number,
    v_year,
    v_sequence_number,
    CURRENT_DATE,
    CURRENT_DATE + INTERVAL '30 days',
    'accepted',
    'Rectificación de factura ' || v_invoice.full_invoice_number,
    v_invoice.subtotal * -1,
    v_invoice.tax_amount * -1,
    v_invoice.total * -1,
    v_invoice.currency,
    COALESCE(
      'Rectificación de la factura ' || v_invoice.full_invoice_number || '. Motivo: ' || p_rectification_reason,
      'Rectificación de la factura ' || v_invoice.full_invoice_number
    ),
    p_invoice_id,
    p_rectification_reason,
    auth.uid()
  ) RETURNING id INTO v_quote_id;

  -- 4. Copiar líneas de factura (con valores negativos)
  -- NOTA: invoice_items usa "line_order", quote_items usa "line_number"
  v_line_number := 0;
  FOR v_item IN 
    SELECT * FROM public.invoice_items WHERE invoice_id = p_invoice_id ORDER BY line_order
  LOOP
    v_line_number := v_line_number + 1;
    INSERT INTO public.quote_items (
      company_id,
      quote_id,
      line_number,
      description,
      quantity,
      unit_price,
      discount_percent,
      tax_rate,
      tax_amount,
      subtotal,
      total
    ) VALUES (
      v_company_id,
      v_quote_id,
      v_line_number,
      v_item.description,
      v_item.quantity * -1,
      v_item.unit_price,
      COALESCE(v_item.discount_percent, 0),
      v_item.tax_rate,
      v_item.tax_amount * -1,
      v_item.subtotal * -1,
      v_item.total * -1
    );
  END LOOP;

  -- 5. Actualizar estado de la factura original a 'rectified'
  UPDATE public.invoices 
  SET status = 'rectified',
      updated_at = NOW()
  WHERE id = p_invoice_id;

  RETURN v_quote_id;
END;
$$;


ALTER FUNCTION "public"."create_rectification_quote"("p_invoice_id" "uuid", "p_rectification_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_service_variant_rpc"("p_service_id" "uuid", "p_variant_name" "text", "p_pricing" "jsonb", "p_features" "jsonb" DEFAULT NULL::"jsonb", "p_display_config" "jsonb" DEFAULT NULL::"jsonb", "p_is_active" boolean DEFAULT true, "p_sort_order" integer DEFAULT 0) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_variant_id uuid;
  v_company_id uuid;
  v_user_company_id uuid;
BEGIN
  -- Validate Auth
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get Service Company
  SELECT company_id INTO v_company_id FROM services WHERE id = p_service_id;
  
  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'Service not found';
  END IF;

  -- Validate Permissions
  SELECT company_id INTO v_user_company_id FROM users WHERE auth_user_id = auth.uid();
  
  IF v_user_company_id IS NULL OR v_user_company_id != v_company_id THEN
    -- Check for superadmin or other roles if needed, but for now strict company match
    RAISE EXCEPTION 'Permission denied';
  END IF;

  -- Insert
  INSERT INTO service_variants (
    service_id,
    variant_name,
    pricing,
    features,
    display_config,
    is_active,
    sort_order
  ) VALUES (
    p_service_id,
    p_variant_name,
    p_pricing,
    COALESCE(p_features, '{}'::jsonb),
    COALESCE(p_display_config, '{}'::jsonb),
    p_is_active,
    p_sort_order
  )
  RETURNING id INTO v_variant_id;

  RETURN json_build_object('id', v_variant_id);
END;
$$;


ALTER FUNCTION "public"."create_service_variant_rpc"("p_service_id" "uuid", "p_variant_name" "text", "p_pricing" "jsonb", "p_features" "jsonb", "p_display_config" "jsonb", "p_is_active" boolean, "p_sort_order" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_ticket"("p_company_id" "uuid", "p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_due_date" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_stage_id" "uuid" DEFAULT NULL::"uuid", "p_assigned_to" "uuid" DEFAULT NULL::"uuid", "p_initial_comment" "text" DEFAULT NULL::"text", "p_initial_attachment_url" "text" DEFAULT NULL::"text", "p_device_id" "uuid" DEFAULT NULL::"uuid", "p_services" "jsonb" DEFAULT '[]'::"jsonb", "p_products" "jsonb" DEFAULT '[]'::"jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_auth_user_id uuid;
  v_role_id uuid;
  v_is_staff boolean := false;
  v_acting_client_id uuid;
  v_ticket_id uuid;
  v_ticket_number int;
  v_final_stage_id uuid;
  v_total_amount numeric := 0;
  v_service_item jsonb;
  v_product_item jsonb;
  v_unit_price numeric;
  v_quantity numeric;
  v_line_total numeric;
  v_full_comment text;
  v_ret_ticket jsonb;
BEGIN
  v_auth_user_id := auth.uid();
  IF v_auth_user_id IS NULL THEN RAISE EXCEPTION 'Not authenticated'; END IF;

  -- Resolve Effective Role
  v_role_id := public.get_effective_role_id(p_company_id, v_auth_user_id);

  IF v_role_id IS NOT NULL THEN
     -- Check Staff Permission: Either high-level role OR explicit 'tickets.create' permission
     SELECT EXISTS (
       SELECT 1 FROM public.app_roles ar
       WHERE ar.id = v_role_id
       AND (
         ar.name IN ('super_admin', 'owner', 'admin', 'agent', 'professional', 'member')
         OR 
         EXISTS (
           SELECT 1 FROM public.role_permissions rp 
           WHERE rp.role_id = v_role_id 
           AND rp.company_id = p_company_id
           AND rp.permission = 'tickets.create'
           AND rp.granted = true
         )
       )
     ) INTO v_is_staff;
  END IF;

  IF NOT v_is_staff THEN
    -- Check Client Access
    SELECT id INTO v_acting_client_id
    FROM public.clients
    WHERE auth_user_id = v_auth_user_id 
    AND company_id = p_company_id
    AND is_active = true;

    IF v_acting_client_id IS NULL THEN
      RAISE EXCEPTION 'User not allowed for this company (Not Staff, Not Client)';
    END IF;

    IF p_client_id != v_acting_client_id THEN
      RAISE EXCEPTION 'Clients can only create tickets for themselves';
    END IF;
  END IF;

  -- 3. Determine Stage
  IF p_stage_id IS NOT NULL THEN
    SELECT id INTO v_final_stage_id 
    FROM public.ticket_stages 
    WHERE id = p_stage_id 
    AND deleted_at IS NULL 
    AND (company_id = p_company_id OR company_id IS NULL);
    
    IF v_final_stage_id IS NULL THEN
       RAISE EXCEPTION 'Invalid stage_id provided';
    END IF;
  ELSE
    SELECT id INTO v_final_stage_id 
    FROM public.ticket_stages 
    WHERE (company_id = p_company_id OR company_id IS NULL)
    AND deleted_at IS NULL 
    ORDER BY position ASC 
    LIMIT 1;
    
    IF v_final_stage_id IS NULL THEN
      RAISE EXCEPTION 'No ticket stages defined for this company';
    END IF;
  END IF;

  -- 4. Create Ticket
  INSERT INTO public.tickets (
    company_id, client_id, title, description, priority, due_date, stage_id, assigned_to, created_at, updated_at, is_opened
  ) VALUES (
    p_company_id, p_client_id, p_title, p_description, p_priority, p_due_date, v_final_stage_id, p_assigned_to, now(), now(), true
  ) RETURNING id, ticket_number INTO v_ticket_id, v_ticket_number;

  -- 5. Add Services
  IF p_services IS NOT NULL AND jsonb_array_length(p_services) > 0 THEN
    FOR v_service_item IN SELECT * FROM jsonb_array_elements(p_services) LOOP
      v_quantity := COALESCE((v_service_item->>'quantity')::numeric, 1);
      v_unit_price := COALESCE((v_service_item->>'unit_price')::numeric, 0);
      v_line_total := v_quantity * v_unit_price;
      v_total_amount := v_total_amount + v_line_total;
      INSERT INTO public.ticket_products (id, ticket_id, service_id, quantity, unit_price, total_price, company_id) 
      VALUES (gen_random_uuid(), v_ticket_id, (v_service_item->>'service_id')::uuid, v_quantity, v_unit_price, v_line_total, p_company_id);
    END LOOP;
  END IF;

  -- 6. Add Products
  IF p_products IS NOT NULL AND jsonb_array_length(p_products) > 0 THEN
    FOR v_product_item IN SELECT * FROM jsonb_array_elements(p_products) LOOP
      v_quantity := COALESCE((v_product_item->>'quantity')::numeric, 1);
      v_unit_price := COALESCE((v_product_item->>'unit_price')::numeric, 0);
      v_line_total := v_quantity * v_unit_price;
      v_total_amount := v_total_amount + v_line_total;
      INSERT INTO public.ticket_products (id, ticket_id, product_id, quantity, unit_price, total_price, company_id) 
      VALUES (gen_random_uuid(), v_ticket_id, (v_product_item->>'product_id')::uuid, v_quantity, v_unit_price, v_line_total, p_company_id);
    END LOOP;
  END IF;

  -- 7. Update Total Amount
  UPDATE public.tickets SET total_amount = v_total_amount WHERE id = v_ticket_id;

  -- 8. Initial Comment
  IF p_initial_comment IS NOT NULL AND length(trim(p_initial_comment)) > 0 THEN
    v_full_comment := trim(p_initial_comment);
    IF p_initial_attachment_url IS NOT NULL AND length(p_initial_attachment_url) > 0 THEN
       v_full_comment := v_full_comment || E'\n\n![Adjunto](' || p_initial_attachment_url || ')';
    END IF;
    INSERT INTO public.ticket_comments (ticket_id, comment, user_id, company_id, is_internal, created_at) 
    VALUES (v_ticket_id, v_full_comment, (SELECT id FROM public.users WHERE auth_user_id = v_auth_user_id LIMIT 1), p_company_id, false, now());
  END IF;

  -- 9. Link Device
  IF p_device_id IS NOT NULL THEN
    INSERT INTO public.ticket_devices (ticket_id, device_id) VALUES (v_ticket_id, p_device_id);
  END IF;

  -- 10. Return Result
  SELECT to_jsonb(sub) INTO v_ret_ticket
  FROM (
    SELECT t.*, row_to_json(c) as client, row_to_json(s) as stage
    FROM public.tickets t
    LEFT JOIN public.clients c ON t.client_id = c.id
    LEFT JOIN public.ticket_stages s ON t.stage_id = s.id
    WHERE t.id = v_ticket_id
  ) sub;
  
  RETURN v_ret_ticket;
END;
$$;


ALTER FUNCTION "public"."create_ticket"("p_company_id" "uuid", "p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_due_date" timestamp with time zone, "p_stage_id" "uuid", "p_assigned_to" "uuid", "p_initial_comment" "text", "p_initial_attachment_url" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_products" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_ticket_rpc"("p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text" DEFAULT 'normal'::"text", "p_stage_id" "uuid" DEFAULT NULL::"uuid", "p_ticket_type" "text" DEFAULT 'incident'::"text", "p_device_id" "uuid" DEFAULT NULL::"uuid", "p_services" "jsonb" DEFAULT '[]'::"jsonb", "p_custom_fields" "jsonb" DEFAULT '{}'::"jsonb") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
  v_user_id uuid;
  v_ticket_id uuid;
  v_ticket_number int;
  v_stage_id uuid;
  v_service text; -- For looping json
  v_service_id uuid;
  v_base_price numeric;
  v_total_services numeric := 0;
  v_created_at timestamptz := now();
BEGIN
  -- 1. Identify User & Company
  SELECT company_id, id INTO v_company_id, v_user_id 
  FROM users 
  WHERE auth_user_id = auth.uid();

  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'User not associated with a company';
  END IF;

  -- 2. Validate Client
  IF NOT EXISTS (SELECT 1 FROM clients WHERE id = p_client_id AND company_id = v_company_id) THEN
    RAISE EXCEPTION 'Client not found or access denied';
  END IF;

  -- 3. Determine Stage (Default logic)
  IF p_stage_id IS NOT NULL THEN
    -- Verify stage exists and is either generic or belongs to company
    IF NOT EXISTS (
      SELECT 1 FROM ticket_stages 
      WHERE id = p_stage_id 
        AND deleted_at IS NULL 
        AND (company_id IS NULL OR company_id = v_company_id)
    ) THEN
      RAISE EXCEPTION 'Invalid stage_id';
    END IF;
    v_stage_id := p_stage_id;
  ELSE
    -- Pick lowest position stage
    SELECT id INTO v_stage_id
    FROM ticket_stages
    WHERE deleted_at IS NULL AND (company_id IS NULL OR company_id = v_company_id)
    ORDER BY position ASC, created_at ASC
    LIMIT 1;

    IF v_stage_id IS NULL THEN
      RAISE EXCEPTION 'No active stages configured system-wide';
    END IF;
  END IF;

  -- 4. Create Ticket
  INSERT INTO tickets (
    company_id,
    client_id,
    stage_id,
    title,
    description,
    priority,
    ticket_type,
    custom_fields,
    created_by,
    status
  ) VALUES (
    v_company_id,
    p_client_id,
    v_stage_id,
    p_title,
    p_description,
    p_priority,
    p_ticket_type,
    p_custom_fields,
    v_user_id,
    'open'
  )
  RETURNING id, ticket_number INTO v_ticket_id, v_ticket_number;

  -- 5. Optional Device Link
  IF p_device_id IS NOT NULL THEN
    -- Validate device
    IF EXISTS (SELECT 1 FROM devices WHERE id = p_device_id AND company_id = v_company_id) THEN
      INSERT INTO ticket_devices (ticket_id, device_id, relation_type)
      VALUES (v_ticket_id, p_device_id, 'primary');
    END IF;
  END IF;

  -- 6. Process Services (Transactional!)
  IF jsonb_array_length(p_services) > 0 THEN
     FOR v_service IN SELECT * FROM jsonb_array_elements(p_services)
     LOOP
        v_service_id := (v_service::jsonb->>'service_id')::uuid;
        
        -- Get price
        SELECT base_price INTO v_base_price 
        FROM services 
        WHERE id = v_service_id AND company_id = v_company_id;

        IF v_base_price IS NULL THEN
           RAISE EXCEPTION 'Service % not found in company', v_service_id;
        END IF;

        -- Link Service to Ticket
        INSERT INTO ticket_services (ticket_id, service_id, unit_price, quantity)
        VALUES (
          v_ticket_id, 
          v_service_id, 
          v_base_price, 
          COALESCE((v_service::jsonb->>'quantity')::int, 1)
        );

        -- Add to running total (simplified, assumed quantity 1 for base checks)
        v_total_services := v_total_services + (v_base_price * COALESCE((v_service::jsonb->>'quantity')::int, 1));
        
        -- Copy tags from Service to Ticket (logic from Edge Function)
        INSERT INTO ticket_tags (ticket_id, tag_id)
        SELECT v_ticket_id, tag_id
        FROM service_tag_relations
        WHERE service_id = v_service_id
        ON CONFLICT DO NOTHING;
     END LOOP;
  END IF;

  -- 7. Create System Comment (Initial Log)
  INSERT INTO ticket_comments (
    ticket_id,
    user_id,
    content,
    is_internal,
    comment_type
  ) VALUES (
    v_ticket_id,
    v_user_id,
    'Ticket creado automáticamente',
    true,
    'system'
  );

  RETURN json_build_object(
    'id', v_ticket_id, 
    'ticket_number', v_ticket_number,
    'status', 'success'
  );
END;
$$;


ALTER FUNCTION "public"."create_ticket_rpc"("p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_stage_id" "uuid", "p_ticket_type" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_custom_fields" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_ticket_rpc"("p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text" DEFAULT 'normal'::"text", "p_stage_id" "uuid" DEFAULT NULL::"uuid", "p_ticket_type" "text" DEFAULT 'incident'::"text", "p_device_id" "uuid" DEFAULT NULL::"uuid", "p_services" "jsonb" DEFAULT '[]'::"jsonb", "p_custom_fields" "jsonb" DEFAULT '{}'::"jsonb", "p_due_date" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_estimated_hours" numeric DEFAULT 0, "p_total_amount" numeric DEFAULT 0, "p_ticket_address" "text" DEFAULT NULL::"text", "p_ticket_contact_name" "text" DEFAULT NULL::"text", "p_ticket_contact_email" "text" DEFAULT NULL::"text", "p_ticket_contact_phone" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
  v_user_id uuid;
  v_ticket_id uuid;
  v_ticket_number int;
  v_stage_id uuid;
  v_service text;
  v_service_id uuid;
  v_base_price numeric;
  v_total_services numeric := 0;
  v_created_at timestamptz := now();
  v_final_custom_fields jsonb;
BEGIN
  -- 1. Identify User & Company
  SELECT company_id, id INTO v_company_id, v_user_id 
  FROM users 
  WHERE auth_user_id = auth.uid();

  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'User not associated with a company';
  END IF;

  -- 2. Validate Client
  IF NOT EXISTS (SELECT 1 FROM clients WHERE id = p_client_id AND company_id = v_company_id) THEN
    RAISE EXCEPTION 'Client not found or access denied';
  END IF;

  -- 3. Determine Stage (Default logic)
  IF p_stage_id IS NOT NULL THEN
    IF NOT EXISTS (
      SELECT 1 FROM ticket_stages 
      WHERE id = p_stage_id 
        AND deleted_at IS NULL 
        AND (company_id IS NULL OR company_id = v_company_id)
    ) THEN
      RAISE EXCEPTION 'Invalid stage_id';
    END IF;
    v_stage_id := p_stage_id;
  ELSE
    SELECT id INTO v_stage_id
    FROM ticket_stages
    WHERE deleted_at IS NULL AND (company_id IS NULL OR company_id = v_company_id)
    ORDER BY position ASC, created_at ASC
    LIMIT 1;

    IF v_stage_id IS NULL THEN
      RAISE EXCEPTION 'No active stages configured system-wide';
    END IF;
  END IF;

  -- Merge contact fields into custom_fields
  v_final_custom_fields := p_custom_fields;
  IF p_ticket_address IS NOT NULL THEN
    v_final_custom_fields := v_final_custom_fields || jsonb_build_object('address', p_ticket_address);
  END IF;
  IF p_ticket_contact_name IS NOT NULL THEN
    v_final_custom_fields := v_final_custom_fields || jsonb_build_object('contact_name', p_ticket_contact_name);
  END IF;
  IF p_ticket_contact_email IS NOT NULL THEN
    v_final_custom_fields := v_final_custom_fields || jsonb_build_object('contact_email', p_ticket_contact_email);
  END IF;
  IF p_ticket_contact_phone IS NOT NULL THEN
    v_final_custom_fields := v_final_custom_fields || jsonb_build_object('contact_phone', p_ticket_contact_phone);
  END IF;

  -- 4. Create Ticket
  INSERT INTO tickets (
    company_id,
    client_id,
    stage_id,
    title,
    description,
    priority,
    custom_fields,
    created_by,
    status,
    due_date,
    estimated_hours,
    total_amount
  ) VALUES (
    v_company_id,
    p_client_id,
    v_stage_id,
    p_title,
    p_description,
    p_priority,
    v_final_custom_fields,
    v_user_id,
    'open',
    p_due_date,
    p_estimated_hours,
    p_total_amount
  )
  RETURNING id, ticket_number INTO v_ticket_id, v_ticket_number;

  -- 5. Optional Device Link
  IF p_device_id IS NOT NULL THEN
    IF EXISTS (SELECT 1 FROM devices WHERE id = p_device_id AND company_id = v_company_id) THEN
      INSERT INTO ticket_devices (ticket_id, device_id, relation_type)
      VALUES (v_ticket_id, p_device_id, 'primary');
    END IF;
  END IF;

  -- 6. Process Services
  IF jsonb_array_length(p_services) > 0 THEN
     FOR v_service IN SELECT * FROM jsonb_array_elements(p_services)
     LOOP
        v_service_id := (v_service::jsonb->>'service_id')::uuid;
        
        SELECT base_price INTO v_base_price 
        FROM services 
        WHERE id = v_service_id AND company_id = v_company_id;

        IF v_base_price IS NULL THEN
           RAISE EXCEPTION 'Service % not found in company', v_service_id;
        END IF;

        INSERT INTO ticket_services (ticket_id, service_id, unit_price, quantity)
        VALUES (
          v_ticket_id, 
          v_service_id, 
          v_base_price, 
          COALESCE((v_service::jsonb->>'quantity')::int, 1)
        );

        INSERT INTO ticket_tags (ticket_id, tag_id)
        SELECT v_ticket_id, tag_id
        FROM service_tag_relations
        WHERE service_id = v_service_id
        ON CONFLICT DO NOTHING;
     END LOOP;
  END IF;

  RETURN json_build_object(
    'id', v_ticket_id, 
    'ticket_number', v_ticket_number,
    'status', 'success'
  );
END;
$$;


ALTER FUNCTION "public"."create_ticket_rpc"("p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_stage_id" "uuid", "p_ticket_type" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_custom_fields" "jsonb", "p_due_date" timestamp with time zone, "p_estimated_hours" numeric, "p_total_amount" numeric, "p_ticket_address" "text", "p_ticket_contact_name" "text", "p_ticket_contact_email" "text", "p_ticket_contact_phone" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."current_company_id"() RETURNS "uuid"
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
  select nullif((current_setting('request.jwt.claims', true)::jsonb ->> 'company_id')::uuid, null)
$$;


ALTER FUNCTION "public"."current_company_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."current_user_is_admin"("p_company_id" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM app_roles
    WHERE id = public.get_effective_role_id(p_company_id, auth.uid())
    AND name IN ('owner', 'admin', 'super_admin')
  );
$$;


ALTER FUNCTION "public"."current_user_is_admin"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."debug_admin_access"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_uid uuid;
    v_user_record jsonb;
    v_role_name text;
    v_role_id uuid;
BEGIN
    v_uid := auth.uid();
    
    SELECT to_jsonb(u), u.app_role_id
    INTO v_user_record, v_role_id
    FROM public.users u 
    WHERE u.id = v_uid;
    
    SELECT name INTO v_role_name FROM public.app_roles WHERE id = v_role_id;
    
    RETURN jsonb_build_object(
        'auth_uid', v_uid,
        'user_found', v_user_record IS NOT NULL,
        'user_role_id', v_role_id,
        'role_name_resolved', v_role_name
    );
END;
$$;


ALTER FUNCTION "public"."debug_admin_access"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."debug_auth_status"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_uid uuid;
    v_user_record jsonb;
    v_is_super boolean;
BEGIN
    v_uid := auth.uid();
    
    SELECT to_jsonb(u) INTO v_user_record 
    FROM public.users u 
    WHERE u.id = v_uid;
    
    v_is_super := public.is_super_admin(v_uid);
    
    RETURN jsonb_build_object(
        'auth_uid', v_uid,
        'public_user', v_user_record,
        'is_super_admin_check', v_is_super
    );
END;
$$;


ALTER FUNCTION "public"."debug_auth_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."debug_client_modules"("p_auth_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_found_client record;
    v_modules jsonb;
BEGIN
    SELECT * INTO v_found_client FROM public.clients WHERE auth_user_id = p_auth_user_id;
    
    SELECT jsonb_agg(
            jsonb_build_object(
                'key', m.key,
                'name', m.label,
                'enabled', (cm.status = 'active')
            ) ORDER BY m.key
        ) INTO v_modules
        FROM public.modules_catalog m
        LEFT JOIN public.company_modules cm 
            ON m.key = cm.module_key 
            AND cm.company_id = v_found_client.company_id;

    RETURN jsonb_build_object(
        'client', row_to_json(v_found_client),
        'modules', v_modules
    );
END;
$$;


ALTER FUNCTION "public"."debug_client_modules"("p_auth_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_customer_dev"("client_id" "uuid", "target_user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    deleted_rows INTEGER;
    user_company_id uuid;
BEGIN
    -- Obtener company_id del usuario
    SELECT company_id INTO user_company_id 
    FROM public.users 
    WHERE auth_user_id = target_user_id;
    
    -- Borrado suave con marca GDPR
    UPDATE public.clients 
    SET 
        deleted_at = now(),
        deletion_reason = 'User deletion request'
    WHERE 
        id = client_id 
        AND company_id = user_company_id
        AND deleted_at IS NULL;
    
    GET DIAGNOSTICS deleted_rows = ROW_COUNT;
    
    RETURN deleted_rows > 0;
END;
$$;


ALTER FUNCTION "public"."delete_customer_dev"("client_id" "uuid", "target_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_stage_safe_rpc"("p_stage_id" "uuid", "p_reassign_to" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_user_id uuid := auth.uid();
    v_company_id uuid;
    v_ticket_count int;
BEGIN
    -- 1. Resolve Company
    SELECT company_id INTO v_company_id
    FROM public.users
    WHERE auth_user_id = v_user_id
      AND active = true
    LIMIT 1;

    IF v_company_id IS NULL THEN
        RAISE EXCEPTION 'User not authorized';
    END IF;

    -- 2. Pre-check: references
    IF p_reassign_to IS NULL THEN
        SELECT count(*) INTO v_ticket_count
        FROM public.tickets
        WHERE stage_id = p_stage_id
          AND company_id = v_company_id;

        IF v_ticket_count > 0 THEN
            -- Throw specific error code so frontend can catch it
            RAISE EXCEPTION 'Tickets reference this stage; reassignment required'
            USING ERRCODE = 'P0002'; -- Using custom error code or P0002 for logic error
        END IF;
    END IF;

    -- 3. Call underlying RPC if exists, or do the delete manually here if reliable.
    -- Since safe_delete_ticket_stage exists, we call it.
    -- Assuming signature: safe_delete_ticket_stage(p_stage_id uuid, p_company_id uuid, p_reassign_to uuid)
    
    PERFORM safe_delete_ticket_stage(p_stage_id, v_company_id, p_reassign_to);

    RETURN jsonb_build_object(
        'deleted', true,
        'stageId', p_stage_id,
        'companyId', v_company_id
    );
EXCEPTION
    WHEN SQLSTATE 'P0002' THEN
        RETURN jsonb_build_object(
            'error', 'Tickets reference this stage; reassignment required',
            'code', 'REASSIGN_REQUIRED',
            'tickets_count', v_ticket_count
        );
    WHEN OTHERS THEN
        -- Catch re-raised errors from the inner procedure if needed or let them bubble up
        RAISE;
END;
$$;


ALTER FUNCTION "public"."delete_stage_safe_rpc"("p_stage_id" "uuid", "p_reassign_to" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."enqueue_verifactu_dispatch"("pinvoiceid" "uuid") RETURNS "void"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  INSERT INTO public.scheduled_jobs (job_type, payload)
  VALUES ('verifactu_dispatch', jsonb_build_object('invoice_id', pinvoiceid));
$$;


ALTER FUNCTION "public"."enqueue_verifactu_dispatch"("pinvoiceid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."enqueue_verifactu_dispatch"("pinvoice_id" "uuid", "pcompany_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Insertar evento en tabla verifactu_events o similar
  INSERT INTO public.verifactu_events (
    invoice_id,
    company_id,
    status,
    attempts,
    created_at
  ) VALUES (
    pinvoice_id,
    pcompany_id,
    'pending',
    0,
    NOW()
  )
  ON CONFLICT (invoice_id) DO UPDATE
  SET 
    status = 'pending',
    attempts = 0,
    updated_at = NOW();
END;
$$;


ALTER FUNCTION "public"."enqueue_verifactu_dispatch"("pinvoice_id" "uuid", "pcompany_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."ensure_all_companies"() RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
    result_text TEXT := '';
    michinanny_id UUID;
    satpcgo_id UUID;
    libera_id UUID;
    empresa_count INTEGER;
BEGIN
    result_text := result_text || '=== VERIFICANDO EMPRESAS EXISTENTES ===' || E'\n';
    
    -- Contar empresas actuales
    SELECT COUNT(*) INTO empresa_count FROM companies WHERE deleted_at IS NULL;
    result_text := result_text || 'Empresas actuales en BD: ' || empresa_count::text || E'\n\n';
    
    -- Mostrar empresas existentes
    result_text := result_text || '📋 Empresas existentes:' || E'\n';
    FOR michinanny_id IN 
        SELECT id FROM companies WHERE deleted_at IS NULL ORDER BY name
    LOOP
        SELECT name INTO result_text FROM companies WHERE id = michinanny_id;
        result_text := result_text || '  ✅ ' || (SELECT name FROM companies WHERE id = michinanny_id) || ' (ID: ' || michinanny_id::text || ')' || E'\n';
    END LOOP;
    
    result_text := result_text || E'\n=== CREANDO EMPRESAS FALTANTES ===' || E'\n';
    
    -- Verificar y crear SatPCGo
    SELECT id INTO satpcgo_id FROM companies WHERE name = 'SatPCGo' AND deleted_at IS NULL;
    IF satpcgo_id IS NULL THEN
        INSERT INTO companies (id, name, website, legacy_negocio_id, created_at, updated_at)
        VALUES (
            gen_random_uuid(),
            'SatPCGo',
            'satpcgo.com',
            1, -- ID del negocio original
            NOW(),
            NOW()
        )
        RETURNING id INTO satpcgo_id;
        
        result_text := result_text || '✅ SatPCGo creado: ' || satpcgo_id::text || E'\n';
    ELSE
        result_text := result_text || '✅ SatPCGo ya existe: ' || satpcgo_id::text || E'\n';
    END IF;
    
    -- Verificar y crear Michinanny
    SELECT id INTO michinanny_id FROM companies WHERE name = 'Michinanny' AND deleted_at IS NULL;
    IF michinanny_id IS NULL THEN
        INSERT INTO companies (id, name, website, legacy_negocio_id, created_at, updated_at)
        VALUES (
            gen_random_uuid(),
            'Michinanny',
            'michinanny.com',
            2, -- Nuevo negocio
            NOW(),
            NOW()
        )
        RETURNING id INTO michinanny_id;
        
        result_text := result_text || '✅ Michinanny creado: ' || michinanny_id::text || E'\n';
    ELSE
        result_text := result_text || '✅ Michinanny ya existe: ' || michinanny_id::text || E'\n';
    END IF;
    
    -- Verificar y crear Libera Tus Creencias
    SELECT id INTO libera_id FROM companies WHERE name = 'Libera Tus Creencias' AND deleted_at IS NULL;
    IF libera_id IS NULL THEN
        INSERT INTO companies (id, name, website, legacy_negocio_id, created_at, updated_at)
        VALUES (
            gen_random_uuid(),
            'Libera Tus Creencias',
            'liberatuscreencias.com',
            3, -- Nuevo negocio
            NOW(),
            NOW()
        )
        RETURNING id INTO libera_id;
        
        result_text := result_text || '✅ Libera Tus Creencias creado: ' || libera_id::text || E'\n';
    ELSE
        result_text := result_text || '✅ Libera Tus Creencias ya existe: ' || libera_id::text || E'\n';
    END IF;
    
    -- Resumen final
    result_text := result_text || E'\n=== RESUMEN ===' || E'\n';
    SELECT COUNT(*) INTO empresa_count FROM companies WHERE deleted_at IS NULL;
    result_text := result_text || 'Total empresas en BD: ' || empresa_count::text || E'\n';
    result_text := result_text || 'SatPCGo ID: ' || satpcgo_id::text || E'\n';
    result_text := result_text || 'Michinanny ID: ' || michinanny_id::text || E'\n';
    result_text := result_text || 'Libera Tus Creencias ID: ' || libera_id::text || E'\n';
    result_text := result_text || E'\n✅ Todas las empresas están disponibles' || E'\n';
    
    RETURN result_text;
END;
$$;


ALTER FUNCTION "public"."ensure_all_companies"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."ensure_min_one_stage_per_category"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  cats TEXT[] := ARRAY['waiting','analysis','action','final','cancel'];
  cat TEXT;
  cnt INT;
  comp UUID;
BEGIN
  -- Determine affected company (works for UPDATE/DELETE)
  comp := COALESCE(NEW.company_id, OLD.company_id);

  -- If company cannot be determined, allow (no-op)
  IF comp IS NULL THEN
    RETURN COALESCE(NEW, OLD);
  END IF;

  FOREACH cat IN ARRAY cats LOOP
    -- Count VISIBLE stages for this company and category
    -- visible = company-owned OR (generic and NOT hidden by this company)
    SELECT COUNT(*) INTO cnt
    FROM ticket_stages s
    WHERE s.deleted_at IS NULL
      AND s.workflow_category::text = cat
      AND (
        s.company_id = comp
        OR (
          s.company_id IS NULL
          AND NOT EXISTS (
            SELECT 1 FROM hidden_stages h
             WHERE h.company_id = comp AND h.stage_id = s.id
          )
        )
      );

    IF cnt = 0 THEN
      RAISE EXCEPTION 'Debe existir al menos un estado visible de la categoría % para la empresa %', cat, comp;
    END IF;
  END LOOP;

  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."ensure_min_one_stage_per_category"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."export_client_gdpr_data"("p_client_id" "uuid", "p_requesting_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_client record;
    v_company_id uuid;
    v_result jsonb;
    v_services jsonb;
    v_tickets jsonb;
    v_devices jsonb;
    v_consent_records jsonb;
    v_access_requests jsonb;
BEGIN
    -- Verificar que el usuario tenga acceso
    SELECT company_id INTO v_company_id
    FROM users
    WHERE auth_user_id = COALESCE(p_requesting_user_id, auth.uid());
    
    -- Obtener datos del cliente
    SELECT * INTO v_client
    FROM clients
    WHERE id = p_client_id
    AND company_id = v_company_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Cliente no encontrado o sin acceso'
        );
    END IF;
    
    -- Obtener servicios relacionados
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
        'id', s.id,
        'name', s.name,
        'description', s.description,
        'price', s.base_price,
        'created_at', s.created_at
    )), '[]'::jsonb) INTO v_services
    FROM services s
    WHERE s.company_id = v_company_id AND (s.id IS NOT NULL); -- Simplified check for export
    
    -- Obtener tickets relacionados
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
        'id', t.id,
        'title', t.title,
        'description', t.description,
        'status', t.sla_status, -- Adjusted column name check
        'priority', t.priority,
        'created_at', t.created_at,
        'updated_at', t.updated_at
    )), '[]'::jsonb) INTO v_tickets
    FROM tickets t
    WHERE t.client_id = p_client_id;
    
    -- Obtener dispositivos relacionados
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
        'id', d.id,
        'brand', d.brand,
        'model', d.model,
        'device_type', d.device_type,
        'serial_number', d.serial_number,
        'status', d.status,
        'created_at', d.created_at
    )), '[]'::jsonb) INTO v_devices
    FROM devices d
    WHERE d.client_id = p_client_id;
    
    -- Obtener registros de consentimiento
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
        'consent_type', cr.consent_type,
        'purpose', cr.purpose,
        'consent_given', cr.consent_given,
        'consent_method', cr.consent_method,
        'created_at', cr.created_at,
        'withdrawn_at', cr.withdrawn_at,
        'is_active', cr.is_active
    )), '[]'::jsonb) INTO v_consent_records
    FROM gdpr_consent_records cr
    WHERE cr.subject_email = v_client.email;
    
    -- Obtener solicitudes de acceso GDPR
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
        'request_type', ar.request_type,
        'processing_status', ar.processing_status,
        'created_at', ar.created_at,
        'completed_at', ar.completed_at
    )), '[]'::jsonb) INTO v_access_requests
    FROM gdpr_access_requests ar
    WHERE ar.subject_email = v_client.email;
    
    -- Construir resultado completo (UPDATED apellidos -> surname)
    v_result := jsonb_build_object(
        'export_info', jsonb_build_object(
            'exported_at', now(),
            'exported_by', COALESCE(p_requesting_user_id, auth.uid()),
            'export_format', 'JSON',
            'gdpr_article', 'Article 20 - Right to Data Portability'
        ),
        'personal_data', jsonb_build_object(
            'id', v_client.id,
            'name', v_client.name,
            'email', v_client.email,
            'phone', v_client.phone,
            'address', v_client.address,
            'surname', v_client.surname,
            'dni', v_client.dni,
            'created_at', v_client.created_at,
            'updated_at', v_client.updated_at
        ),
        'consent_information', jsonb_build_object(
            'marketing_consent', v_client.marketing_consent,
            'marketing_consent_date', v_client.marketing_consent_date,
            'data_processing_consent', v_client.data_processing_consent,
            'data_processing_consent_date', v_client.data_processing_consent_date,
            'data_processing_legal_basis', v_client.data_processing_legal_basis
        ),
        'data_retention', jsonb_build_object(
            'retention_until', v_client.data_retention_until,
            'is_active', v_client.is_active
        ),
        'related_data', jsonb_build_object(
            'services', v_services,
            'tickets', v_tickets,
            'devices', v_devices
        ),
        'gdpr_records', jsonb_build_object(
            'consent_records', v_consent_records,
            'access_requests', v_access_requests
        ),
        'metadata', v_client.metadata
    );
    
    -- Registrar en audit log
    INSERT INTO gdpr_audit_log (
        user_id, 
        company_id,
        action_type, 
        table_name, 
        record_id,
        subject_email, 
        purpose,
        created_at
    ) VALUES (
        COALESCE(p_requesting_user_id, auth.uid()),
        v_company_id,
        'export',
        'clients',
        p_client_id,
        v_client.email,
        'GDPR Art. 20 - Data Portability Request',
        now()
    );
    
    RETURN jsonb_build_object(
        'success', true,
        'data', v_result
    );
    
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'error_detail', SQLSTATE
    );
END;
$$;


ALTER FUNCTION "public"."export_client_gdpr_data"("p_client_id" "uuid", "p_requesting_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."export_client_gdpr_data"("p_client_id" "uuid", "p_requesting_user_id" "uuid") IS 'Exporta todos los datos personales de un cliente en formato JSON (Art. 20 GDPR)';



CREATE OR REPLACE FUNCTION "public"."f_analytics_occupancy_heatmap"("p_company_id" "uuid", "p_start_date" timestamp with time zone DEFAULT ("now"() - '30 days'::interval), "p_end_date" timestamp with time zone DEFAULT "now"()) RETURNS TABLE("day_of_week" integer, "hour_of_day" integer, "booking_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    EXTRACT(DOW FROM start_time)::INTEGER as day_of_week,
    EXTRACT(HOUR FROM start_time)::INTEGER as hour_of_day,
    COUNT(*) as booking_count
  FROM bookings
  WHERE company_id = p_company_id
    AND start_time >= p_start_date
    AND start_time <= p_end_date
    AND status NOT IN ('cancelled', 'no_show')
  GROUP BY 1, 2
  ORDER BY 1, 2;
END;
$$;


ALTER FUNCTION "public"."f_analytics_occupancy_heatmap"("p_company_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_analytics_revenue_forecast"("p_company_id" "uuid") RETURNS TABLE("period" "text", "total_revenue" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 'past_30d' as period, COALESCE(SUM(total_price), 0)
  FROM bookings
  WHERE company_id = p_company_id
    AND start_time >= (now() - interval '30 days')
    AND start_time < now()
    AND status IN ('completed', 'confirmed', 'paid')
  UNION ALL
  SELECT 'next_30d' as period, COALESCE(SUM(total_price), 0)
  FROM bookings
  WHERE company_id = p_company_id
    AND start_time >= now()
    AND start_time <= (now() + interval '30 days')
    AND status IN ('confirmed', 'pending_payment');
END;
$$;


ALTER FUNCTION "public"."f_analytics_revenue_forecast"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_analytics_top_performers"("p_company_id" "uuid", "p_month_date" "date" DEFAULT CURRENT_DATE) RETURNS TABLE("professional_id" "uuid", "professional_name" "text", "bookings_count" bigint, "total_revenue" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    b.professional_id,
    u.name as professional_name,
    COUNT(*) as bookings_count,
    COALESCE(SUM(b.total_price), 0) as total_revenue
  FROM bookings b
  JOIN company_members cm ON b.professional_id = cm.id
  JOIN users u ON cm.user_id = u.id
  WHERE b.company_id = p_company_id
    AND date_trunc('month', b.start_time) = date_trunc('month', p_month_date)
    AND b.status NOT IN ('cancelled')
  GROUP BY b.professional_id, u.name
  ORDER BY total_revenue DESC
  LIMIT 5;
END;
$$;


ALTER FUNCTION "public"."f_analytics_top_performers"("p_company_id" "uuid", "p_month_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_analytics_top_services"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date", "p_limit" integer DEFAULT 5) RETURNS TABLE("service_id" "uuid", "service_name" "text", "bookings_count" bigint, "total_revenue" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT
    b.service_id,
    s.name as service_name,
    COUNT(*)::bigint as bookings_count,
    COALESCE(SUM(b.total_price), 0) as total_revenue
  FROM bookings b
  LEFT JOIN services s ON b.service_id = s.id
  WHERE b.company_id = public.get_company_id_from_jwt()
    AND b.status != 'cancelled'
    AND s.name IS NOT NULL -- Exclude deleted/null services if needed
    AND (p_start IS NULL OR b.start_time::date >= p_start)
    AND (p_end IS NULL OR b.start_time::date <= p_end)
  GROUP BY b.service_id, s.name
  ORDER BY total_revenue DESC
  LIMIT p_limit;
$$;


ALTER FUNCTION "public"."f_analytics_top_services"("p_start" "date", "p_end" "date", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_booking_analytics_monthly"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "period_month" "date", "bookings_count" bigint, "confirmed_count" bigint, "cancelled_count" bigint, "total_revenue" numeric, "total_hours" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT
    b.company_id,
    DATE_TRUNC('month', b.start_time)::date as period_month,
    COUNT(*)::bigint as bookings_count,
    COUNT(*) FILTER (WHERE b.status = 'confirmed')::bigint as confirmed_count,
    COUNT(*) FILTER (WHERE b.status = 'cancelled')::bigint as cancelled_count,
    COALESCE(SUM(b.total_price) FILTER (WHERE b.status != 'cancelled'), 0) as total_revenue,
    -- Calculate hours: (end - start) extracted as epoch / 3600
    COALESCE(SUM(EXTRACT(EPOCH FROM (b.end_time - b.start_time))/3600) FILTER (WHERE b.status != 'cancelled'), 0) as total_hours
  FROM bookings b
  WHERE b.company_id = public.get_company_id_from_jwt()
    AND (p_start IS NULL OR DATE_TRUNC('month', b.start_time)::date >= p_start)
    AND (p_end IS NULL OR DATE_TRUNC('month', b.start_time)::date <= p_end)
  GROUP BY b.company_id, DATE_TRUNC('month', b.start_time)::date
  ORDER BY period_month DESC;
$$;


ALTER FUNCTION "public"."f_booking_analytics_monthly"("p_start" "date", "p_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_invoice_collection_status"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "created_by" "uuid", "total_invoiced" numeric, "total_collected" numeric, "total_pending" numeric, "total_overdue" numeric, "overdue_count" bigint, "avg_days_overdue" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT 
    ib.company_id,
    ib.created_by,
    SUM(ib.total_amount) AS total_invoiced,
    SUM(ib.paid_amount) AS total_collected,
    SUM(ib.pending_amount) AS total_pending,
    SUM(ib.pending_amount) FILTER (WHERE ib.is_overdue) AS total_overdue,
    COUNT(*) FILTER (WHERE ib.is_overdue) AS overdue_count,
    AVG(ABS(ib.days_to_due)) FILTER (WHERE ib.is_overdue)::numeric AS avg_days_overdue
  FROM analytics.invoice_base ib
  WHERE ib.company_id = public.get_user_company_id()
    AND ib.created_by = auth.uid()
    AND ib.status NOT IN ('cancelled', 'draft')
    AND (p_start IS NULL OR ib.period_month >= p_start)
    AND (p_end   IS NULL OR ib.period_month <= p_end)
  GROUP BY ib.company_id, ib.created_by;
$$;


ALTER FUNCTION "public"."f_invoice_collection_status"("p_start" "date", "p_end" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."f_invoice_collection_status"("p_start" "date", "p_end" "date") IS 'Retorna estado de cobro agregado para el período especificado';



CREATE OR REPLACE FUNCTION "public"."f_invoice_kpis_monthly"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "created_by" "uuid", "period_month" "date", "invoices_count" bigint, "paid_count" bigint, "pending_count" bigint, "overdue_count" bigint, "cancelled_count" bigint, "draft_count" bigint, "subtotal_sum" numeric, "tax_sum" numeric, "total_sum" numeric, "collected_sum" numeric, "pending_sum" numeric, "paid_total_sum" numeric, "receivable_sum" numeric, "avg_invoice_value" numeric, "collection_rate" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  WITH 
  real_invoices AS (
    SELECT 
      i.company_id,
      i.created_by,
      DATE_TRUNC('month', i.invoice_date)::date as period_month,
      i.status::text as status,
      COALESCE(i.subtotal, 0) as subtotal,
      COALESCE(i.tax_amount, 0) as tax_amount,
      COALESCE(i.total, 0) as total_amount,
      COALESCE(i.paid_amount, 0) as paid_amount
    FROM public.invoices i
    WHERE i.company_id = public.get_company_id_from_jwt()
  ),
  legacy_recurring AS (
    SELECT 
      q.company_id,
      q.created_by,
      DATE_TRUNC('month', q.last_run_at)::date as period_month,
      'paid'::text as status,
      COALESCE(q.subtotal, 0) as subtotal,
      COALESCE(q.tax_amount, 0) as tax_amount,
      COALESCE(q.total_amount, 0) as total_amount,
      COALESCE(q.total_amount, 0) as paid_amount
    FROM public.quotes q
    WHERE q.company_id = public.get_company_id_from_jwt()
      AND q.status = 'invoiced'
      AND q.recurrence_type IS NOT NULL 
      AND q.recurrence_type != 'none'
      AND q.last_run_at IS NOT NULL
      AND NOT EXISTS (
        SELECT 1 FROM public.invoices inv
        WHERE inv.source_quote_id = q.id
          AND DATE_TRUNC('month', inv.invoice_date)::date = DATE_TRUNC('month', q.last_run_at)::date
      )
  ),
  legacy_first_invoice AS (
    SELECT 
      q.company_id,
      q.created_by,
      DATE_TRUNC('month', q.invoiced_at)::date as period_month,
      'paid'::text as status,
      COALESCE(q.subtotal, 0) as subtotal,
      COALESCE(q.tax_amount, 0) as tax_amount,
      COALESCE(q.total_amount, 0) as total_amount,
      COALESCE(q.total_amount, 0) as paid_amount
    FROM public.quotes q
    WHERE q.company_id = public.get_company_id_from_jwt()
      AND q.status = 'invoiced'
      AND q.recurrence_type IS NOT NULL 
      AND q.recurrence_type != 'none'
      AND q.invoiced_at IS NOT NULL
      AND (q.last_run_at IS NULL OR DATE_TRUNC('month', q.invoiced_at)::date != DATE_TRUNC('month', q.last_run_at)::date)
      AND NOT EXISTS (
        SELECT 1 FROM public.invoices inv
        WHERE inv.source_quote_id = q.id
          AND DATE_TRUNC('month', inv.invoice_date)::date = DATE_TRUNC('month', q.invoiced_at)::date
      )
  ),
  all_invoices AS (
    SELECT * FROM real_invoices
    UNION ALL
    SELECT * FROM legacy_recurring
    UNION ALL
    SELECT * FROM legacy_first_invoice
  ),
  filtered_invoices AS (
    SELECT *
    FROM all_invoices
    WHERE (p_start IS NULL OR period_month >= p_start)
      AND (p_end IS NULL OR period_month <= p_end)
  )
  SELECT 
    fi.company_id,
    fi.created_by,
    fi.period_month,
    COUNT(*)::bigint as invoices_count,
    COUNT(*) FILTER (WHERE fi.status = 'paid')::bigint as paid_count,
    COUNT(*) FILTER (WHERE fi.status IN ('sent', 'draft'))::bigint as pending_count,
    COUNT(*) FILTER (WHERE fi.status = 'overdue')::bigint as overdue_count,
    COUNT(*) FILTER (WHERE fi.status = 'cancelled')::bigint as cancelled_count,
    COUNT(*) FILTER (WHERE fi.status = 'draft')::bigint as draft_count,
    COALESCE(SUM(fi.subtotal), 0) as subtotal_sum,
    COALESCE(SUM(fi.tax_amount), 0) as tax_sum,
    COALESCE(SUM(fi.total_amount), 0) as total_sum,
    COALESCE(SUM(fi.paid_amount), 0) as collected_sum,
    COALESCE(SUM(fi.total_amount) FILTER (WHERE fi.status IN ('sent', 'draft')), 0) as pending_sum,
    COALESCE(SUM(fi.total_amount) FILTER (WHERE fi.status = 'paid'), 0) as paid_total_sum,
    COALESCE(SUM(fi.total_amount) FILTER (WHERE fi.status IN ('sent', 'draft', 'overdue')), 0) as receivable_sum,
    AVG(fi.total_amount) as avg_invoice_value,
    (COUNT(*) FILTER (WHERE fi.status = 'paid')::numeric / NULLIF(COUNT(*), 0)) as collection_rate
  FROM filtered_invoices fi
  GROUP BY fi.company_id, fi.created_by, fi.period_month
  ORDER BY fi.period_month DESC;
$$;


ALTER FUNCTION "public"."f_invoice_kpis_monthly"("p_start" "date", "p_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_invoice_kpis_monthly_debug"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "created_by" "uuid", "period_month" "date", "invoices_count" bigint, "total_sum" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT m.company_id, m.created_by, m.period_month,
         m.invoices_count, m.total_sum
  FROM analytics.mv_invoice_kpis_monthly m
  WHERE m.company_id = 'cd830f43-f6f0-4b78-a2a4-505e4e0976b5'::uuid
    AND (p_start IS NULL OR m.period_month >= p_start)
    AND (p_end   IS NULL OR m.period_month <= p_end)
  ORDER BY m.period_month DESC;
$$;


ALTER FUNCTION "public"."f_invoice_kpis_monthly_debug"("p_start" "date", "p_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_invoice_kpis_monthly_temp"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "created_by" "uuid", "period_month" "date", "invoices_count" bigint, "paid_count" bigint, "pending_count" bigint, "overdue_count" bigint, "cancelled_count" bigint, "draft_count" bigint, "subtotal_sum" numeric, "tax_sum" numeric, "total_sum" numeric, "collected_sum" numeric, "pending_sum" numeric, "paid_total_sum" numeric, "receivable_sum" numeric, "avg_invoice_value" numeric, "collection_rate" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT m.company_id, m.created_by, m.period_month,
         m.invoices_count, m.paid_count, m.pending_count, m.overdue_count, 
         m.cancelled_count, m.draft_count,
         m.subtotal_sum, m.tax_sum, m.total_sum,
         m.collected_sum, m.pending_sum, m.paid_total_sum, m.receivable_sum,
         m.avg_invoice_value, m.collection_rate
  FROM analytics.mv_invoice_kpis_monthly m
  WHERE m.company_id = 'cd830f43-f6f0-4b78-a2a4-505e4e0976b5'
    AND (p_start IS NULL OR m.period_month >= p_start)
    AND (p_end   IS NULL OR m.period_month <= p_end)
  ORDER BY m.period_month DESC;
$$;


ALTER FUNCTION "public"."f_invoice_kpis_monthly_temp"("p_start" "date", "p_end" "date") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mail_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "account_id" "uuid" NOT NULL,
    "thread_id" "uuid",
    "folder_id" "uuid",
    "from" "jsonb",
    "to" "jsonb"[],
    "cc" "jsonb"[],
    "bcc" "jsonb"[],
    "subject" "text",
    "body_html" "text",
    "body_text" "text",
    "snippet" "text",
    "is_read" boolean DEFAULT false,
    "is_starred" boolean DEFAULT false,
    "is_archived" boolean DEFAULT false,
    "received_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."mail_messages" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_mail_get_thread_messages"("p_thread_id" "uuid") RETURNS SETOF "public"."mail_messages"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
  SELECT *
  FROM mail_messages
  WHERE thread_id = p_thread_id
  ORDER BY received_at ASC;
$$;


ALTER FUNCTION "public"."f_mail_get_thread_messages"("p_thread_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_mail_get_thread_messages"("p_thread_id" "uuid", "p_account_id" "uuid") RETURNS SETOF "public"."mail_messages"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM public.mail_messages
    WHERE thread_id = p_thread_id
    AND account_id = p_account_id
    ORDER BY received_at ASC;
END;
$$;


ALTER FUNCTION "public"."f_mail_get_thread_messages"("p_thread_id" "uuid", "p_account_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_name" "text", "p_limit" integer DEFAULT 20, "p_offset" integer DEFAULT 0) RETURNS TABLE("thread_id" "uuid", "subject" "text", "snippet" "text", "last_message_at" timestamp with time zone, "message_count" bigint, "participants" "text"[], "is_read" boolean, "has_attachments" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_folder_id uuid;
BEGIN
  -- Attempt to lookup folder by name OR ID
  SELECT id INTO v_folder_id
  FROM mail_folders
  WHERE (name = p_folder_name OR id::text = p_folder_name)
  LIMIT 1;

  IF v_folder_id IS NULL THEN
    RETURN;
  END IF;

  RETURN QUERY
  WITH thread_stats AS (
    SELECT
      m.thread_id,
      MAX(m.received_at) as max_date,
      COUNT(*) as cnt,
      BOOL_AND(m.is_read) as all_read,
      BOOL_OR( COALESCE(jsonb_array_length(m.metadata->'attachments') > 0, false) ) as has_att
    FROM mail_messages m
    WHERE m.folder_id = v_folder_id
    GROUP BY m.thread_id
  ),
  latest_msg AS (
    SELECT DISTINCT ON (m.thread_id)
      m.thread_id,
      m.subject,
      m.snippet,
      m.from #>> '{name}' as from_name,
      m.from #>> '{email}' as from_email
    FROM mail_messages m
    WHERE m.folder_id = v_folder_id
    ORDER BY m.thread_id, m.received_at DESC
  ),
  participants_agg AS (
    SELECT 
      m.thread_id,
      array_agg(DISTINCT 
        CASE 
           WHEN (m.from->>'name') IS NOT NULL AND (m.from->>'name') != '' THEN (m.from->>'name')
           ELSE (m.from->>'email')
        END
      ) as senders
    FROM mail_messages m
    WHERE m.folder_id = v_folder_id
    GROUP BY m.thread_id
  )
  SELECT
    ts.thread_id,
    lm.subject,
    lm.snippet,
    ts.max_date as last_message_at,
    ts.cnt as message_count,
    pa.senders as participants,
    ts.all_read as is_read,
    ts.has_att as has_attachments
  FROM thread_stats ts
  JOIN latest_msg lm ON lm.thread_id = ts.thread_id
  LEFT JOIN participants_agg pa ON pa.thread_id = ts.thread_id
  ORDER BY ts.max_date DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;


ALTER FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_name" "text", "p_limit" integer, "p_offset" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_role" "text", "p_limit" integer DEFAULT 20, "p_offset" integer DEFAULT 0, "p_search" "text" DEFAULT NULL::"text") RETURNS TABLE("thread_id" "uuid", "subject" "text", "snippet" "text", "last_message_at" timestamp with time zone, "message_count" bigint, "participants" "jsonb"[], "has_attachments" boolean, "is_read" boolean)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_folder_id UUID;
BEGIN
    -- Get folder ID from role (and account)
    SELECT id INTO v_folder_id
    FROM public.mail_folders
    WHERE account_id = p_account_id AND system_role = p_folder_role;

    IF v_folder_id IS NULL THEN
        RETURN;
    END IF;

    RETURN QUERY
    WITH thread_stats AS (
        SELECT 
            m.thread_id,
            COUNT(m.id) as msg_count,
            MAX(m.received_at) as last_msg_date,
            bool_or(m.is_read = false) as has_unread,
            array_agg(DISTINCT m."from" ORDER BY m."from") as senders
        FROM public.mail_messages m
        WHERE m.account_id = p_account_id
        AND m.folder_id = v_folder_id
        AND (p_search IS NULL OR m.subject ILIKE '%' || p_search || '%' OR m.body_text ILIKE '%' || p_search || '%')
        GROUP BY m.thread_id
    )
    SELECT 
        t.id as thread_id,
        t.subject,
        t.snippet,
        ts.last_msg_date as last_message_at,
        ts.msg_count as message_count,
        ts.senders as participants,
        false as has_attachments, -- TODO: Calculate
        NOT ts.has_unread as is_read
    FROM public.mail_threads t
    JOIN thread_stats ts ON ts.thread_id = t.id
    ORDER BY ts.last_msg_date DESC
    LIMIT p_limit OFFSET p_offset;
END;
$$;


ALTER FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_role" "text", "p_limit" integer, "p_offset" integer, "p_search" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_id" "uuid", "p_limit" integer DEFAULT 20, "p_offset" integer DEFAULT 0, "p_search" "text" DEFAULT NULL::"text") RETURNS TABLE("thread_id" "uuid", "subject" "text", "snippet" "text", "last_message_at" timestamp with time zone, "message_count" bigint, "participants" "jsonb"[], "has_attachments" boolean, "is_read" boolean)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    RETURN QUERY
    WITH thread_stats AS (
        SELECT 
            m.thread_id,
            COUNT(m.id) as msg_count,
            MAX(m.received_at) as last_msg_date,
            bool_or(m.is_read = false) as has_unread,
            array_agg(DISTINCT m."from" ORDER BY m."from") as senders
        FROM public.mail_messages m
        WHERE m.account_id = p_account_id
        AND m.folder_id = p_folder_id -- Direct ID match
        AND (p_search IS NULL OR m.subject ILIKE '%' || p_search || '%' OR m.body_text ILIKE '%' || p_search || '%')
        GROUP BY m.thread_id
    )
    SELECT 
        t.id as thread_id,
        t.subject,
        t.snippet,
        ts.last_msg_date as last_message_at,
        ts.msg_count as message_count,
        ts.senders as participants,
        false as has_attachments, 
        NOT ts.has_unread as is_read
    FROM public.mail_threads t
    JOIN thread_stats ts ON ts.thread_id = t.id
    ORDER BY ts.last_msg_date DESC
    LIMIT p_limit OFFSET p_offset;
END;
$$;


ALTER FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_id" "uuid", "p_limit" integer, "p_offset" integer, "p_search" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_marketing_get_audience"("p_company_id" "uuid", "p_criteria" "jsonb") RETURNS TABLE("client_id" "uuid", "name" "text", "email" "text", "phone" "text", "last_booking_date" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_inactive_days INT;
    v_birthday_month INT;
BEGIN
    v_inactive_days := (p_criteria->>'inactive_days')::INT;
    v_birthday_month := (p_criteria->>'birthday_month')::INT;

    RETURN QUERY
    SELECT 
        c.id as client_id,
        c.name,
        c.email,
        c.phone,
        MAX(b.start_time) as last_booking_date
    FROM public.clients c
    LEFT JOIN public.bookings b ON c.id = b.client_id
    WHERE c.company_id = p_company_id
    GROUP BY c.id
    HAVING 
        (v_inactive_days IS NULL OR 
         (MAX(b.start_time) < (now() - (v_inactive_days || ' days')::INTERVAL) OR MAX(b.start_time) IS NULL))
        AND
        (v_birthday_month IS NULL OR 
         EXTRACT(MONTH FROM c.birth_date) = v_birthday_month);
END;
$$;


ALTER FUNCTION "public"."f_marketing_get_audience"("p_company_id" "uuid", "p_criteria" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_marketing_get_automation_audience"("p_company_id" "uuid", "p_trigger_type" "public"."campaign_trigger_type", "p_config" "jsonb") RETURNS TABLE("client_id" "uuid", "name" "text", "email" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_days_inactive INT;
BEGIN
    -- Birthday Trigger
    IF p_trigger_type = 'birthday' THEN
        RETURN QUERY
        SELECT 
            c.id, c.name, c.email
        FROM public.clients c
        WHERE c.company_id = p_company_id
        AND c.marketing_consent = true
        AND EXTRACT(MONTH FROM c.birth_date) = EXTRACT(MONTH FROM CURRENT_DATE)
        AND EXTRACT(DAY FROM c.birth_date) = EXTRACT(DAY FROM CURRENT_DATE);
    
    -- Inactivity Trigger
    ELSIF p_trigger_type = 'inactivity' THEN
        v_days_inactive := (p_config->>'days')::INT;
        
        RETURN QUERY
        SELECT 
            c.id, c.name, c.email
        FROM public.clients c
        LEFT JOIN public.bookings b ON c.id = b.client_id
        WHERE c.company_id = p_company_id
        GROUP BY c.id
        HAVING 
            MAX(b.start_time) < (now() - (v_days_inactive || ' days')::INTERVAL);
    END IF;
END;
$$;


ALTER FUNCTION "public"."f_marketing_get_automation_audience"("p_company_id" "uuid", "p_trigger_type" "public"."campaign_trigger_type", "p_config" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_quote_cube"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "created_by" "uuid", "period_month" "date", "status" "text", "conversion_status" "text", "group_id" integer, "quotes_count" bigint, "subtotal_sum" numeric, "tax_sum" numeric, "total_sum" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT c.company_id, c.created_by, c.period_month, c.status, c.conversion_status, c.group_id,
         c.quotes_count, c.subtotal_sum, c.tax_sum, c.total_sum
  FROM analytics.mv_quote_cube c
  WHERE c.company_id = public.get_user_company_id()
    AND c.created_by = auth.uid()
    AND (p_start IS NULL OR c.period_month >= p_start)
    AND (p_end   IS NULL OR c.period_month <= p_end)
  ORDER BY c.period_month NULLS LAST, c.status NULLS LAST, c.conversion_status NULLS LAST;
$$;


ALTER FUNCTION "public"."f_quote_cube"("p_start" "date", "p_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_quote_kpis_monthly"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "period_month" "date", "quotes_count" bigint, "draft_count" bigint, "converted_count" bigint, "pending_count" bigint, "subtotal_sum" numeric, "tax_sum" numeric, "total_sum" numeric, "avg_days_to_accept" numeric, "conversion_rate" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  WITH current_month AS (
    SELECT DATE_TRUNC('month', CURRENT_DATE)::date as start_date
  ),
  pending_quotes AS (
    SELECT 
      q.company_id,
      (SELECT start_date FROM current_month) as period_month,
      q.status,
      q.conversion_status,
      COALESCE(q.subtotal, 0) as subtotal,
      COALESCE(q.tax_amount, 0) as tax_amount,
      COALESCE(q.total_amount, 0) as total_amount,
      CASE 
        WHEN q.accepted_at IS NOT NULL 
        THEN EXTRACT(DAY FROM (q.accepted_at - COALESCE(q.quote_date, q.created_at)))
        ELSE NULL 
      END as days_to_accept
    FROM public.quotes q
    WHERE q.company_id = public.get_company_id_from_jwt()
      AND q.status IN ('draft', 'sent', 'accepted', 'expired')
      AND (q.conversion_status IS NULL OR q.conversion_status = 'not_converted')
  )
  SELECT 
    pq.company_id,
    pq.period_month,
    COUNT(*)::bigint as quotes_count,
    COUNT(*) FILTER (WHERE pq.status = 'draft')::bigint as draft_count,
    0::bigint as converted_count,
    COUNT(*)::bigint as pending_count,
    COALESCE(SUM(pq.subtotal), 0) as subtotal_sum,
    COALESCE(SUM(pq.tax_amount), 0) as tax_sum,
    COALESCE(SUM(pq.total_amount), 0) as total_sum,
    AVG(pq.days_to_accept) as avg_days_to_accept,
    0::numeric as conversion_rate
  FROM pending_quotes pq
  WHERE (p_start IS NULL OR pq.period_month >= p_start)
    AND (p_end IS NULL OR pq.period_month <= p_end)
  GROUP BY pq.company_id, pq.period_month
  ORDER BY pq.period_month DESC;
$$;


ALTER FUNCTION "public"."f_quote_kpis_monthly"("p_start" "date", "p_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_quote_kpis_monthly_enhanced"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "period_month" "date", "quotes_count" bigint, "draft_count" bigint, "converted_count" bigint, "pending_count" bigint, "subtotal_sum" numeric, "tax_sum" numeric, "total_sum" numeric, "avg_days_to_accept" numeric, "conversion_rate" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  WITH current_month_start AS (
    SELECT DATE_TRUNC('month', CURRENT_DATE)::date as month_start
  ),
  quote_data AS (
    SELECT 
      q.company_id,
      CASE 
        WHEN DATE_TRUNC('month', COALESCE(q.quote_date, q.created_at))::date < (SELECT month_start FROM current_month_start)
          AND q.status IN ('draft', 'sent', 'accepted')
          AND (q.conversion_status IS NULL OR q.conversion_status NOT IN ('converted', 'invoiced'))
        THEN (SELECT month_start FROM current_month_start)
        ELSE DATE_TRUNC('month', COALESCE(q.quote_date, q.created_at))::date
      END as period_month,
      q.status,
      q.conversion_status,
      COALESCE(q.subtotal, 0) as subtotal,
      COALESCE(q.tax_amount, 0) as tax_amount,
      COALESCE(q.total_amount, 0) as total_amount,
      CASE 
        WHEN q.accepted_at IS NOT NULL 
        THEN EXTRACT(DAY FROM (q.accepted_at - COALESCE(q.quote_date, q.created_at)))
        ELSE NULL 
      END as days_to_accept
    FROM public.quotes q
    WHERE q.company_id = public.get_company_id_from_jwt()
      AND (
        q.status IN ('draft', 'sent', 'accepted')
        OR q.conversion_status IN ('converted', 'invoiced')
      )
  ),
  filtered_data AS (
    SELECT *
    FROM quote_data
    WHERE (p_start IS NULL OR period_month >= p_start)
      AND (p_end IS NULL OR period_month <= p_end)
  )
  SELECT 
    qd.company_id,
    qd.period_month,
    COUNT(*)::bigint as quotes_count,
    COUNT(*) FILTER (WHERE qd.status = 'draft')::bigint as draft_count,
    COUNT(*) FILTER (WHERE qd.conversion_status IN ('converted', 'invoiced'))::bigint as converted_count,
    COUNT(*) FILTER (WHERE qd.status IN ('draft', 'sent', 'accepted') 
                      AND (qd.conversion_status IS NULL OR qd.conversion_status NOT IN ('converted', 'invoiced')))::bigint as pending_count,
    SUM(CASE 
      WHEN qd.status IN ('draft', 'sent', 'accepted')
        AND (qd.conversion_status IS NULL OR qd.conversion_status NOT IN ('converted', 'invoiced'))
      THEN qd.subtotal 
      ELSE 0 
    END) as subtotal_sum,
    SUM(CASE 
      WHEN qd.status IN ('draft', 'sent', 'accepted')
        AND (qd.conversion_status IS NULL OR qd.conversion_status NOT IN ('converted', 'invoiced'))
      THEN qd.tax_amount 
      ELSE 0 
    END) as tax_sum,
    SUM(CASE 
      WHEN qd.status IN ('draft', 'sent', 'accepted')
        AND (qd.conversion_status IS NULL OR qd.conversion_status NOT IN ('converted', 'invoiced'))
      THEN qd.total_amount 
      ELSE 0 
    END) as total_sum,
    AVG(qd.days_to_accept) as avg_days_to_accept,
    (COUNT(*) FILTER (WHERE qd.conversion_status IN ('converted', 'invoiced'))::numeric / NULLIF(COUNT(*), 0)) as conversion_rate
  FROM filtered_data qd
  GROUP BY qd.company_id, qd.period_month
  ORDER BY qd.period_month DESC;
$$;


ALTER FUNCTION "public"."f_quote_kpis_monthly_enhanced"("p_start" "date", "p_end" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."f_quote_kpis_monthly_enhanced"("p_start" "date", "p_end" "date") IS 'Retorna KPIs mejorados de presupuestos por mes';



CREATE OR REPLACE FUNCTION "public"."f_quote_pipeline_current"() RETURNS TABLE("company_id" "uuid", "quotes_count" bigint, "draft_count" bigint, "sent_count" bigint, "accepted_count" bigint, "expired_count" bigint, "subtotal_sum" numeric, "tax_sum" numeric, "total_sum" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT 
    q.company_id,
    COUNT(*)::bigint as quotes_count,
    COUNT(*) FILTER (WHERE q.status = 'draft')::bigint as draft_count,
    COUNT(*) FILTER (WHERE q.status = 'sent')::bigint as sent_count,
    COUNT(*) FILTER (WHERE q.status = 'accepted')::bigint as accepted_count,
    COUNT(*) FILTER (WHERE q.status = 'expired')::bigint as expired_count,
    COALESCE(SUM(q.subtotal), 0) as subtotal_sum,
    COALESCE(SUM(q.tax_amount), 0) as tax_sum,
    COALESCE(SUM(q.total_amount), 0) as total_sum
  FROM public.quotes q
  WHERE q.company_id = public.get_company_id_from_jwt()
    AND q.status IN ('draft', 'sent', 'accepted', 'expired')
    AND (q.conversion_status IS NULL OR q.conversion_status = 'not_converted')
  GROUP BY q.company_id;
$$;


ALTER FUNCTION "public"."f_quote_pipeline_current"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_quote_projected_revenue"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "period_month" "date", "draft_count" bigint, "subtotal" numeric, "tax_amount" numeric, "grand_total" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT
    q.company_id,
    q.quote_month as period_month,
    COUNT(*)::bigint as draft_count,
    COALESCE(SUM(q.subtotal), 0) as subtotal,
    COALESCE(SUM(q.tax_amount), 0) as tax_amount,
    COALESCE(SUM(q.total_amount), 0) as grand_total
  FROM public.quotes q
  WHERE q.company_id = public.get_company_id_from_jwt()
    AND q.status = 'draft'
    AND (p_start IS NULL OR q.quote_month >= p_start)
    AND (p_end IS NULL OR q.quote_month <= p_end)
  GROUP BY q.company_id, q.quote_month
  ORDER BY q.quote_month DESC;
$$;


ALTER FUNCTION "public"."f_quote_projected_revenue"("p_start" "date", "p_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_quote_recurring_monthly"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "period_month" "date", "recurring_count" bigint, "subtotal" numeric, "tax_amount" numeric, "grand_total" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  WITH target_period AS (
    SELECT 
      COALESCE(p_start, DATE_TRUNC('month', CURRENT_DATE)::date) as start_date,
      COALESCE(p_end, (DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month - 1 day')::date) as end_date
  ),
  recurring_with_calculated_date AS (
    SELECT 
      q.company_id,
      q.subtotal,
      q.tax_amount,
      q.total_amount,
      -- Calcular next_run_at si es NULL basándose en recurrence_day y recurrence_type
      COALESCE(
        q.next_run_at::date,
        q.invoice_on_date,  -- CORREGIDO: era scheduled_conversion_date
        -- Si es mensual y tiene recurrence_day, usar ese día del mes actual/siguiente
        CASE 
          WHEN q.recurrence_type = 'monthly' AND q.recurrence_day IS NOT NULL THEN
            CASE
              -- Si el día ya pasó este mes, usar el próximo mes
              WHEN q.recurrence_day < EXTRACT(DAY FROM CURRENT_DATE) THEN
                (DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month' + (q.recurrence_day - 1 || ' days')::INTERVAL)::date
              -- Si el día es hoy o futuro, usar este mes
              ELSE
                (DATE_TRUNC('month', CURRENT_DATE) + (q.recurrence_day - 1 || ' days')::INTERVAL)::date
            END
          -- Si es trimestral, calcular 3 meses después de la última factura
          WHEN q.recurrence_type = 'quarterly' AND q.last_run_at IS NOT NULL THEN
            (q.last_run_at + INTERVAL '3 months')::date
          -- Si es anual, calcular 1 año después
          WHEN q.recurrence_type = 'yearly' AND q.last_run_at IS NOT NULL THEN
            (q.last_run_at + INTERVAL '1 year')::date
          -- Default: usar el día de hoy
          ELSE CURRENT_DATE
        END
      ) as calculated_next_run
    FROM public.quotes q, target_period tp
    WHERE q.company_id = public.get_company_id_from_jwt()
      AND q.recurrence_type != 'none'
      -- CORREGIDO: solo estados válidos (sin 'pending')
      AND q.status IN ('draft', 'sent', 'accepted', 'invoiced')
      -- ELIMINADO: deleted_at no existe en quotes
      -- Si tiene fecha de fin, verificar que no haya expirado
      AND (q.recurrence_end_date IS NULL OR q.recurrence_end_date >= tp.start_date)
  )
  SELECT 
    r.company_id,
    DATE_TRUNC('month', r.calculated_next_run)::date as period_month,
    COUNT(*)::bigint as recurring_count,
    COALESCE(SUM(r.subtotal), 0) as subtotal,
    COALESCE(SUM(r.tax_amount), 0) as tax_amount,
    COALESCE(SUM(r.total_amount), 0) as grand_total
  FROM recurring_with_calculated_date r, target_period tp
  WHERE r.calculated_next_run BETWEEN tp.start_date AND tp.end_date
  GROUP BY r.company_id, period_month
  ORDER BY period_month DESC;
$$;


ALTER FUNCTION "public"."f_quote_recurring_monthly"("p_start" "date", "p_end" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."f_quote_recurring_monthly"("p_start" "date", "p_end" "date") IS 'Retorna presupuestos recurrentes que deben convertirse a factura en el período especificado. Calcula next_run_at dinámicamente si es NULL.';



CREATE OR REPLACE FUNCTION "public"."f_quote_top_items_monthly"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date", "p_limit" integer DEFAULT 50) RETURNS TABLE("company_id" "uuid", "created_by" "uuid", "period_month" "date", "item_id" "uuid", "qty_sum" numeric, "subtotal_sum" numeric, "total_sum" numeric, "rn_by_amount" bigint, "rn_by_qty" bigint)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT t.company_id, t.created_by, t.period_month, t.item_id,
         t.qty_sum, t.subtotal_sum, t.total_sum, t.rn_by_amount, t.rn_by_qty
  FROM analytics.mv_quote_top_items_monthly t
  WHERE t.company_id = public.get_user_company_id()
    AND t.created_by = auth.uid()
    AND (p_start IS NULL OR t.period_month >= p_start)
    AND (p_end   IS NULL OR t.period_month <= p_end)
    AND (t.rn_by_amount <= p_limit OR t.rn_by_qty <= p_limit)
  ORDER BY t.period_month DESC, t.total_sum DESC;
$$;


ALTER FUNCTION "public"."f_quote_top_items_monthly"("p_start" "date", "p_end" "date", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_refresh_analytics_views"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Refresh Ticket KPIs (Materialized Views)
  -- Use CONCURRENTLY to avoid locking table for reads
  IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'analytics' AND matviewname = 'mv_ticket_kpis_monthly') THEN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_ticket_kpis_monthly;
  END IF;
  
  IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'analytics' AND matviewname = 'mv_ticket_kpis_daily') THEN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_ticket_kpis_daily;
  END IF;

  -- Refresh Invoice/Quote KPIs
  IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'analytics' AND matviewname = 'mv_invoice_kpis_monthly') THEN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_invoice_kpis_monthly;
  END IF;

  IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'analytics' AND matviewname = 'mv_quote_kpis_monthly') THEN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_quote_kpis_monthly;
  END IF;
   
  IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'analytics' AND matviewname = 'mv_quote_top_items_monthly') THEN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_quote_top_items_monthly;
  END IF;
  
   IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'analytics' AND matviewname = 'mv_quote_cube') THEN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_quote_cube;
  END IF;
END;
$$;


ALTER FUNCTION "public"."f_refresh_analytics_views"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_ticket_current_status"() RETURNS TABLE("company_id" "uuid", "total_open" bigint, "total_in_progress" bigint, "total_completed" bigint, "total_overdue" bigint, "critical_open" bigint, "high_open" bigint, "avg_age_days" numeric, "oldest_ticket_days" integer)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT 
    tb.company_id,
    COUNT(*) FILTER (WHERE tb.workflow_category = 'waiting' 
      OR (tb.workflow_category IS NULL AND tb.stage_category = 'open')) AS total_open,
    COUNT(*) FILTER (WHERE tb.workflow_category IN ('analysis', 'action')
      OR (tb.workflow_category IS NULL AND tb.stage_category = 'in_progress')) AS total_in_progress,
    COUNT(*) FILTER (WHERE tb.is_completed) AS total_completed,
    COUNT(*) FILTER (WHERE tb.is_overdue) AS total_overdue,
    COUNT(*) FILTER (WHERE NOT tb.is_completed AND (tb.priority = 'critical' OR tb.priority = 'urgent')) AS critical_open,
    COUNT(*) FILTER (WHERE NOT tb.is_completed AND tb.priority = 'high') AS high_open,
    AVG(EXTRACT(EPOCH FROM (NOW() - tb.created_at)) / 86400.0) 
      FILTER (WHERE NOT tb.is_completed)::numeric AS avg_age_days,
    MAX((CURRENT_DATE - tb.created_at::date)) 
      FILTER (WHERE NOT tb.is_completed)::integer AS oldest_ticket_days
  FROM analytics.ticket_base tb
  WHERE tb.company_id = public.get_company_id_from_jwt()
  GROUP BY tb.company_id;
$$;


ALTER FUNCTION "public"."f_ticket_current_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_ticket_kpis_monthly"("p_start" "date" DEFAULT NULL::"date", "p_end" "date" DEFAULT NULL::"date") RETURNS TABLE("company_id" "uuid", "period_month" "date", "tickets_created" bigint, "critical_count" bigint, "high_priority_count" bigint, "normal_priority_count" bigint, "low_priority_count" bigint, "open_count" bigint, "in_progress_count" bigint, "completed_count" bigint, "completed_this_month" bigint, "overdue_count" bigint, "total_amount_sum" numeric, "invoiced_amount_sum" numeric, "avg_resolution_days" numeric, "min_resolution_days" numeric, "max_resolution_days" numeric, "resolution_rate" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT 
    m.company_id, 
    m.period_month,
    m.tickets_created, 
    m.critical_count, 
    m.high_priority_count, 
    m.normal_priority_count, 
    m.low_priority_count,
    m.open_count, 
    m.in_progress_count, 
    m.completed_count, 
    m.completed_this_month, 
    m.overdue_count,
    m.total_amount_sum, 
    m.invoiced_amount_sum,
    m.avg_resolution_days, 
    m.min_resolution_days, 
    m.max_resolution_days,
    m.resolution_rate
  FROM analytics.mv_ticket_kpis_monthly m
  WHERE m.company_id = public.get_company_id_from_jwt()
    AND (p_start IS NULL OR m.period_month >= p_start)
    AND (p_end   IS NULL OR m.period_month <= p_end)
  ORDER BY m.period_month DESC;
$$;


ALTER FUNCTION "public"."f_ticket_kpis_monthly"("p_start" "date", "p_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."finalize_invoice"("p_invoice_id" "uuid", "p_series" "text", "p_device_id" "text" DEFAULT NULL::"text", "p_software_id" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_company_id uuid;
  v_user uuid := auth.uid();
  v_number bigint;
  v_prev text;
  v_payload jsonb;
  v_hash text;
  v_vat jsonb;
  v_qr text;
  v_invoice_type text;
  v_rectifies_id uuid;
  v_rectified_series text;
  v_rectified_number text;
  v_rectified_date date;
BEGIN
  SELECT company_id, invoice_type, rectifies_invoice_id 
    INTO v_company_id, v_invoice_type, v_rectifies_id 
    FROM public.invoices WHERE id = p_invoice_id;
    
  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'Invoice % not found or missing company_id', p_invoice_id;
  END IF;

  -- Get sequential number & previous hash
  SELECT number, previous_hash INTO v_number, v_prev FROM verifactu.get_next_invoice_number(v_company_id, p_series);

  -- VAT breakdown
  BEGIN
    v_vat := verifactu.compute_vat_breakdown(p_invoice_id);
  EXCEPTION WHEN undefined_function THEN
    v_vat := '[]'::jsonb;
  END;

  -- Canonical payload for hash
  v_payload := jsonb_build_object(
    'invoice_id', p_invoice_id,
    'company_id', v_company_id,
    'series', p_series,
    'number', v_number,
    'currency', (SELECT currency FROM public.invoices WHERE id=p_invoice_id),
    'totals', jsonb_build_object(
      'base', (SELECT total_tax_base FROM public.invoices WHERE id=p_invoice_id),
      'vat', (SELECT total_vat FROM public.invoices WHERE id=p_invoice_id),
      'gross', (SELECT total_gross FROM public.invoices WHERE id=p_invoice_id)
    ),
    'vat_breakdown', COALESCE(v_vat, '[]'::jsonb)
  );

  -- Add Rectification details if applicable
  IF v_invoice_type = 'rectificative' AND v_rectifies_id IS NOT NULL THEN
    -- Fetch rectified invoice details
    SELECT series, number::text, issue_time::date 
      INTO v_rectified_series, v_rectified_number, v_rectified_date
      FROM verifactu.invoice_meta 
     WHERE invoice_id = v_rectifies_id;
     
    -- Fallback to invoices table if not in meta
    IF v_rectified_series IS NULL THEN
       SELECT invoice_series, invoice_number, invoice_date 
         INTO v_rectified_series, v_rectified_number, v_rectified_date
         FROM public.invoices WHERE id = v_rectifies_id;
    END IF;

    v_payload := v_payload || jsonb_build_object(
      'invoice_type', 'R',
      'rectified_invoice', jsonb_build_object(
        'series', v_rectified_series,
        'number', v_rectified_number,
        'issue_date', v_rectified_date
      ),
      'rectification_type', 'S'
    );
  END IF;

  v_hash := verifactu.compute_invoice_hash(v_payload, v_prev);
  v_qr := 'SERIE:'||p_series||'|NUM:'||v_number||'|HASH:'||v_hash;

  -- Persist meta
  INSERT INTO verifactu.invoice_meta(invoice_id, company_id, series, number, chained_hash, previous_hash, device_id, software_id, qr_payload, status, created_by)
  VALUES (p_invoice_id, v_company_id, p_series, v_number, v_hash, v_prev, p_device_id, p_software_id, v_qr, 'pending', v_user)
  ON CONFLICT (invoice_id) DO UPDATE
    SET chained_hash = excluded.chained_hash,
        previous_hash = excluded.previous_hash,
        series = excluded.series,
        number = excluded.number,
        device_id = excluded.device_id,
        software_id = excluded.software_id,
        qr_payload = excluded.qr_payload,
        status = 'pending';

  -- Mark invoice as final
  UPDATE public.invoices
     SET state='final',
         finalized_at = COALESCE(finalized_at, now()),
         canonical_payload = v_payload,
         hash_prev = v_prev,
         hash_current = v_hash
   WHERE id=p_invoice_id;

  -- Advance sequence
  UPDATE verifactu.invoice_sequence
     SET last_hash = v_hash,
         updated_at = now()
   WHERE company_id=v_company_id AND series=p_series;

  -- Enqueue event
  INSERT INTO verifactu.events(company_id, invoice_id, event_type, payload)
  VALUES (v_company_id, p_invoice_id, 'alta', v_payload)
  ON CONFLICT (invoice_id, event_type) DO NOTHING;

  RETURN json_build_object('invoice_id', p_invoice_id, 'series', p_series, 'number', v_number, 'hash', v_hash, 'qr', v_qr, 'vat_breakdown', COALESCE(v_vat, '[]'::jsonb));
END;
$$;


ALTER FUNCTION "public"."finalize_invoice"("p_invoice_id" "uuid", "p_series" "text", "p_device_id" "text", "p_software_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fix_bet_drop_link"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_user_id uuid;
    v_client_id uuid;
BEGIN
    -- 1. Find User ID for 'servicio.pcgo@gmail.com'
    -- (Assuming this is the email of the logged in user in the screenshot)
    SELECT id INTO v_user_id FROM auth.users WHERE email = 'servicio.pcgo@gmail.com';
    
    IF v_user_id IS NULL THEN
        -- Fallback: Check 'contacto@sincronia.agency' just in case
        SELECT id INTO v_user_id FROM auth.users WHERE email = 'contacto@sincronia.agency';
    END IF;

    IF v_user_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Could not find any auth user for known emails');
    END IF;

    -- 2. Update 'BET DROPSHIPPING' client (ID 0737...) to be owned by this user
    UPDATE public.clients
    SET auth_user_id = v_user_id
    WHERE id = '0737c4bf-4d57-47ce-ac8c-fe01f3f884ec'
    RETURNING id INTO v_client_id;

    RETURN jsonb_build_object(
        'success', true, 
        'client_id', v_client_id, 
        'user_id', v_user_id,
        'message', 'Linked Bet Dropshipping to User'
    );
END;
$$;


ALTER FUNCTION "public"."fix_bet_drop_link"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_invoice_immutable_after_issue"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF OLD.state = 'final' OR OLD.status IN ('sent','paid') THEN
    IF (NEW.subtotal, NEW.tax_amount, NEW.total) IS DISTINCT FROM (OLD.subtotal, OLD.tax_amount, OLD.total)
       OR NEW.client_id <> OLD.client_id THEN
      RAISE EXCEPTION 'Immutable invoice after emission (amounts/client)';
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_invoice_immutable_after_issue"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_is_variant_visible"("p_variant_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_auth_uid uuid := auth.uid();
  v_service_id uuid;
  v_is_hidden boolean;
  v_service_is_public boolean;
  v_service_is_active boolean;
  v_has_assignment boolean;
  v_has_other_assignment boolean;
BEGIN
  -- If no user is logged in, denied
  IF v_auth_uid IS NULL THEN
    RETURN false;
  END IF;

  -- Get variant and service info
  SELECT sv.service_id, COALESCE(sv.is_hidden, false), COALESCE(s.is_public, false), COALESCE(s.is_active, false)
  INTO v_service_id, v_is_hidden, v_service_is_public, v_service_is_active
  FROM service_variants sv
  JOIN services s ON s.id = sv.service_id
  WHERE sv.id = p_variant_id;

  -- If variant not found, return false
  IF v_service_id IS NULL THEN
    RETURN false;
  END IF;

  -- 1. Check if user has specific assignment to THIS variant
  SELECT EXISTS (
    SELECT 1 
    FROM client_variant_assignments cva
    JOIN clients c ON c.id = cva.client_id
    WHERE cva.variant_id = p_variant_id
    AND c.auth_user_id = v_auth_uid
  ) INTO v_has_assignment;

  IF v_has_assignment THEN
    RETURN true;
  END IF;

  -- 2. Check general visibility conditions
  -- Must not be hidden
  IF v_is_hidden THEN
    RETURN false;
  END IF;

  -- Must be public and active service
  IF NOT (v_service_is_public AND v_service_is_active) THEN
    RETURN false;
  END IF;

  -- Must NOT have assignment to ANY OTHER variant of this service
  -- (If you are assigned a specific variant, you shouldn't see the public ones for that service)
  SELECT EXISTS (
    SELECT 1 
    FROM client_variant_assignments cva
    JOIN clients c ON c.id = cva.client_id
    WHERE cva.service_id = v_service_id
    AND c.auth_user_id = v_auth_uid
  ) INTO v_has_other_assignment;

  IF v_has_other_assignment THEN
    RETURN false;
  END IF;

  RETURN true;
END;
$$;


ALTER FUNCTION "public"."fn_is_variant_visible"("p_variant_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_ticket_comments_maintain_integrity"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_company uuid;
BEGIN
  IF TG_OP = 'UPDATE' THEN
    IF NEW.ticket_id IS DISTINCT FROM OLD.ticket_id THEN
      RAISE EXCEPTION 'ticket_id cannot be changed for a comment';
    END IF;
    IF NEW.user_id IS DISTINCT FROM OLD.user_id THEN
      RAISE EXCEPTION 'user_id cannot be changed for a comment';
    END IF;
  END IF;

  SELECT t.company_id INTO v_company FROM public.tickets t WHERE t.id = NEW.ticket_id;
  IF v_company IS NULL THEN
    RAISE EXCEPTION 'Invalid ticket reference on ticket_comments (ticket not found)';
  END IF;
  NEW.company_id := v_company;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_ticket_comments_maintain_integrity"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_touch_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
begin
  new.updated_at = now();
  return new;
end; $$;


ALTER FUNCTION "public"."fn_touch_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_verifactu_settings_enforce_modes"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF NEW.cert_pem_enc IS NOT NULL OR NEW.key_pem_enc IS NOT NULL THEN
    NEW.cert_pem := NULL;
    NEW.key_pem := NULL;
    NEW.key_passphrase := NULL;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_verifactu_settings_enforce_modes"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gdpr_accept_consent"("p_token" "text", "p_preferences" "jsonb", "p_evidence" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  r public.gdpr_consent_requests;
  v_now timestamptz := now();
  v_type text;
  v_given boolean;
BEGIN
  SELECT * INTO r FROM public.gdpr_consent_requests WHERE token = p_token FOR UPDATE;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'invalid_token');
  END IF;
  IF r.status <> 'pending' OR r.expires_at < v_now THEN
    RETURN jsonb_build_object('success', false, 'error', 'not_pending');
  END IF;

  -- Insert one consent record per requested type
  FOREACH v_type IN ARRAY r.consent_types LOOP
    v_given := COALESCE((p_preferences ->> v_type)::boolean, false);
    INSERT INTO public.gdpr_consent_records (
      subject_id, subject_email, consent_type, purpose, consent_given, consent_method,
      consent_evidence, company_id, processed_by, legal_basis
    ) VALUES (
      r.client_id,
      r.subject_email,
      v_type,
      COALESCE(r.purpose, 'consent_portal'),
      v_given,
      'website',
      jsonb_build_object('source','consent_portal','token',p_token,'evidence',p_evidence),
      r.company_id,
      NULL,
      CASE WHEN v_type = 'data_processing' THEN 'consent' ELSE NULL END
    );
  END LOOP;

  -- Update convenience fields on clients when present
  IF r.client_id IS NOT NULL THEN
    UPDATE public.clients SET
      data_processing_consent = COALESCE((p_preferences->>'data_processing')::boolean, data_processing_consent),
      data_processing_consent_date = CASE WHEN (p_preferences->>'data_processing')::boolean IS NOT NULL THEN v_now ELSE data_processing_consent_date END,
      marketing_consent = COALESCE((p_preferences->>'marketing')::boolean, marketing_consent),
      marketing_consent_date = CASE WHEN (p_preferences->>'marketing')::boolean IS NOT NULL THEN v_now ELSE marketing_consent_date END,
      marketing_consent_method = 'website'
    WHERE id = r.client_id;
  END IF;

  UPDATE public.gdpr_consent_requests
  SET status = 'accepted', accepted_at = v_now, evidence = p_evidence
  WHERE id = r.id;

  RETURN jsonb_build_object('success', true);
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."gdpr_accept_consent"("p_token" "text", "p_preferences" "jsonb", "p_evidence" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gdpr_anonymize_client"("client_id" "uuid", "requesting_user_id" "uuid", "anonymization_reason" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    affected_client_name TEXT;
    affected_client_email TEXT;
    v_company_id UUID;
BEGIN
    -- 1. Fetch current data
    SELECT name, email, company_id INTO affected_client_name, affected_client_email, v_company_id
    FROM public.clients
    WHERE id = client_id;

    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Client not found');
    END IF;

    -- 2. Update the client record
    -- (UPDATED apellidos -> surname)
    UPDATE public.clients
    SET
        name = 'ANONYMIZED',
        surname = NULL,
        email = 'anonymized-' || client_id || '@deleted.com',
        phone = NULL,
        dni = NULL,
        address = NULL,
        direccion_id = NULL,
        metadata = jsonb_build_object('anonymized', true, 'original_deleted_at', NOW()),
        updated_at = NOW(),
        
        -- Business fields
        business_name = 'ANONYMIZED',
        cif_nif = NULL,
        trade_name = NULL,
        legal_representative_name = NULL,
        legal_representative_dni = NULL,
        mercantile_registry_data = '{}'::jsonb,
        
        -- GDPR specific fields
        marketing_consent = false,
        marketing_consent_date = NULL,
        data_processing_consent = false,
        deletion_requested_at = NOW(),
        deletion_reason = anonymization_reason,
        anonymized_at = NOW(),
        
        -- Security/Access
        auth_user_id = NULL,
        is_active = false,
        deleted_at = NOW()
    WHERE id = client_id;

    RETURN jsonb_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."gdpr_anonymize_client"("client_id" "uuid", "requesting_user_id" "uuid", "anonymization_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gdpr_audit_clients_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    audit_action TEXT;
    current_user_id UUID;
    subject_email TEXT;
BEGIN
    -- Determine User ID (fallback to NEW.auth_user_id or NULL)
    current_user_id := auth.uid();
    
    -- Determine Action Type
    IF TG_OP = 'INSERT' THEN
        audit_action := 'create';
        subject_email := NEW.email;
    ELSIF TG_OP = 'UPDATE' THEN
        -- Check for Anonymization
        IF NEW.name = 'ANONYMIZED' AND (NEW.email LIKE 'anonymized-%' OR NEW.email IS NULL) THEN
            audit_action := 'anonymization';
            -- For anonymization, we want to preserve the OLD email in the log so we know who was anonymized
            subject_email := OLD.email; 
        ELSE
            audit_action := 'update';
            subject_email := NEW.email;
        END IF;
    ELSIF TG_OP = 'DELETE' THEN
        audit_action := 'delete';
        subject_email := OLD.email;
    END IF;

    -- Insert into Audit Log
    INSERT INTO public.gdpr_audit_log (
        action_type,
        table_name,
        record_id,
        subject_email,
        purpose,
        old_values,
        new_values,
        user_id,
        company_id
    ) VALUES (
        audit_action,
        'clients',
        COALESCE(NEW.id, OLD.id),
        subject_email,
        CASE 
            WHEN audit_action = 'anonymization' THEN 'User Requested Anonymization / Inactivity Cleanup'
            ELSE 'Client Record Change'
        END,
        CASE WHEN TG_OP = 'UPDATE' OR TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE NULL END,
        CASE WHEN TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN to_jsonb(NEW) ELSE NULL END,
        current_user_id,
        COALESCE(NEW.company_id, OLD.company_id)
    );

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."gdpr_audit_clients_changes"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gdpr_audit_clients_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        PERFORM gdpr_log_access(
            auth.uid(),
            NEW.company_id, -- Added company_id
            'create',
            'clients',
            NEW.id,
            NEW.email,
            'client_creation',
            NULL,
            to_jsonb(NEW)
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        PERFORM gdpr_log_access(
            auth.uid(),
            NEW.company_id, -- Added company_id
            'update',
            'clients',
            NEW.id,
            NEW.email,
            'client_modification',
            to_jsonb(OLD),
            to_jsonb(NEW)
        );
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        PERFORM gdpr_log_access(
            auth.uid(),
            OLD.company_id, -- Added company_id
            'delete',
            'clients',
            OLD.id,
            OLD.email,
            'client_deletion',
            to_jsonb(OLD),
            NULL
        );
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."gdpr_audit_clients_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gdpr_audit_trigger"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
declare
  payload jsonb;
  tbl text := tg_table_schema || '.' || tg_table_name;
  act text := tg_op;
  rec_id text := coalesce((to_jsonb(new)->>'id'), (to_jsonb(old)->>'id'));
begin
  payload := jsonb_build_object(
    'table', tbl,
    'op', act,
    'when', now(),
    'user', auth.uid(),
    'pk', rec_id,
    'new', case when tg_op in ('INSERT','UPDATE') then to_jsonb(new) else null end,
    'old', case when tg_op in ('UPDATE','DELETE') then to_jsonb(old) else null end
  );
  perform pg_notify('gdpr_audit', payload::text);
  begin
    execute 'insert into public.gdpr_audit_log(action, details) values ($1,$2)'
      using concat('TRIGGER ', tbl, ' ', act), payload;
  exception when undefined_table or undefined_column then
    -- ignore if audit table/columns differ or do not exist
    null;
  end;
  return coalesce(new, old);
end$_$;


ALTER FUNCTION "public"."gdpr_audit_trigger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gdpr_create_consent_request"("p_client_id" "uuid", "p_subject_email" "text", "p_consent_types" "text"[], "p_purpose" "text" DEFAULT NULL::"text", "p_expires" interval DEFAULT '30 days'::interval) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_company_id uuid;
  v_request_id uuid;
  v_token text;
BEGIN
  -- Determine company of current user
  SELECT company_id INTO v_company_id FROM public.users WHERE auth_user_id = auth.uid() AND active = true LIMIT 1;
  IF v_company_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Unauthorized');
  END IF;

  INSERT INTO public.gdpr_consent_requests (client_id, subject_email, company_id, consent_types, purpose, expires_at)
  VALUES (p_client_id, lower(trim(p_subject_email)), v_company_id, p_consent_types, p_purpose, now() + COALESCE(p_expires, interval '30 days'))
  RETURNING id, token INTO v_request_id, v_token;

  -- Log audit
  PERFORM gdpr_log_access(auth.uid(), 'consent', 'gdpr_consent_requests', v_request_id, p_subject_email, 'consent_request_created');

  RETURN jsonb_build_object('success', true, 'request_id', v_request_id, 'token', v_token, 'path', '/consent?t='||v_token);
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."gdpr_create_consent_request"("p_client_id" "uuid", "p_subject_email" "text", "p_consent_types" "text"[], "p_purpose" "text", "p_expires" interval) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gdpr_decline_consent"("p_token" "text", "p_evidence" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  r public.gdpr_consent_requests;
BEGIN
  SELECT * INTO r FROM public.gdpr_consent_requests WHERE token = p_token FOR UPDATE;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'invalid_token');
  END IF;

  UPDATE public.gdpr_consent_requests
  SET status = 'declined', accepted_at = now(), evidence = p_evidence
  WHERE id = r.id;

  -- Optional: record explicit refusal entries for traceability (consent_given = false)
  INSERT INTO public.gdpr_consent_records (
    subject_id, subject_email, consent_type, purpose, consent_given, consent_method,
    consent_evidence, company_id, processed_by, legal_basis
  )
  SELECT r.client_id, r.subject_email, ct, COALESCE(r.purpose,'consent_portal'), false, 'website',
         jsonb_build_object('source','consent_portal','token',p_token,'evidence',p_evidence), r.company_id, NULL, NULL
  FROM unnest(r.consent_types) AS ct;

  RETURN jsonb_build_object('success', true);
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."gdpr_decline_consent"("p_token" "text", "p_evidence" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gdpr_export_client_data"("client_email" "text", "requesting_user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    client_data JSONB;
    client_record RECORD;
    v_company_id UUID;
    v_encryption_key text := 'simplifica-secure-key-2026'; -- Matching key from secure_clinical_notes.sql
BEGIN
    SELECT * INTO client_record FROM public.clients WHERE email = client_email LIMIT 1;
    
    IF client_record IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Client not found');
    END IF;

    v_company_id := client_record.company_id;

    -- Aggregate data
    SELECT jsonb_build_object(
        'profile', to_jsonb(client_record),
        'clinical_notes', COALESCE((
            SELECT jsonb_agg(jsonb_build_object(
                'id', n.id,
                'content', extensions.pgp_sym_decrypt(n.content::bytea, v_encryption_key),
                'created_at', n.created_at,
                'created_by', n.created_by
            ))
            FROM public.client_clinical_notes n
            WHERE n.client_id = client_record.id
        ), '[]'::jsonb),
        'consents', COALESCE((
            SELECT jsonb_agg(to_jsonb(cr))
            FROM public.gdpr_consent_records cr
            WHERE cr.subject_email = client_email
        ), '[]'::jsonb),
        'access_requests', COALESCE((
            SELECT jsonb_agg(to_jsonb(ar))
            FROM public.gdpr_access_requests ar
            WHERE ar.subject_email = client_email
        ), '[]'::jsonb),
        'exported_at', NOW()
    )
    INTO client_data;

    -- Log Access
    INSERT INTO public.gdpr_audit_log (
        action_type, table_name, record_id, subject_email, purpose, old_values, user_id, company_id
    ) VALUES (
        'export',
        'clients',
        client_record.id,
        client_email,
        'Data Portability Request (Full Export)',
        NULL,
        NULL,
        requesting_user_id,
        v_company_id
    );

    RETURN client_data;
END;
$$;


ALTER FUNCTION "public"."gdpr_export_client_data"("client_email" "text", "requesting_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gdpr_get_consent_request"("p_token" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  r record;
  v_expired boolean;
BEGIN
  SELECT gcr.*, c.name AS company_name INTO r
  FROM public.gdpr_consent_requests gcr
  JOIN public.companies c ON c.id = gcr.company_id
  WHERE gcr.token = p_token;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'invalid_token');
  END IF;

  v_expired := (r.expires_at < now());

  RETURN jsonb_build_object(
    'success', true,
    'status', CASE WHEN v_expired AND r.status='pending' THEN 'expired' ELSE r.status END,
    'subject_email', r.subject_email,
    'client_id', r.client_id,
    'company_id', r.company_id,
    'company_name', r.company_name,
    'consent_types', r.consent_types,
    'purpose', r.purpose,
    'expires_at', r.expires_at
  );
END;
$$;


ALTER FUNCTION "public"."gdpr_get_consent_request"("p_token" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gdpr_log_access"("user_id" "uuid", "company_id" "uuid", "action_type" "text", "table_name" "text", "record_id" "uuid" DEFAULT NULL::"uuid", "subject_email" "text" DEFAULT NULL::"text", "purpose" "text" DEFAULT NULL::"text", "old_values" "jsonb" DEFAULT NULL::"jsonb", "new_values" "jsonb" DEFAULT NULL::"jsonb") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    INSERT INTO gdpr_audit_log (
        user_id,
        company_id,
        action_type,
        table_name,
        record_id,
        subject_email,
        purpose,
        old_values,
        new_values
    ) VALUES (
        user_id,
        company_id,
        action_type,
        table_name,
        record_id,
        subject_email,
        purpose,
        old_values,
        new_values
    );
    
    RETURN true;
EXCEPTION WHEN OTHERS THEN
    RETURN false;
END;
$$;


ALTER FUNCTION "public"."gdpr_log_access"("user_id" "uuid", "company_id" "uuid", "action_type" "text", "table_name" "text", "record_id" "uuid", "subject_email" "text", "purpose" "text", "old_values" "jsonb", "new_values" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_file_path"("company_uuid" "uuid", "file_name" "text", "subfolder" "text" DEFAULT 'general'::"text") RETURNS "text"
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
  -- Genera: company_id/subfolder/timestamp_filename
  RETURN company_uuid::text || '/' || subfolder || '/' || 
         extract(epoch from now())::bigint || '_' || file_name;
END;
$$;


ALTER FUNCTION "public"."generate_file_path"("company_uuid" "uuid", "file_name" "text", "subfolder" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_verifactu_hash"("p_invoice_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_invoice RECORD;
  v_previous_hash TEXT;
  v_data_string TEXT;
  v_new_hash TEXT;
BEGIN
  SELECT * INTO v_invoice FROM invoices WHERE id = p_invoice_id;

  SELECT verifactu_hash INTO v_previous_hash
  FROM invoices
  WHERE series_id = v_invoice.series_id
    AND verifactu_chain_position = (v_invoice.verifactu_chain_position - 1)
  LIMIT 1;

  v_previous_hash := COALESCE(v_previous_hash, 'GENESIS');

  v_data_string := v_previous_hash ||
                   v_invoice.full_invoice_number ||
                   v_invoice.invoice_date::TEXT ||
                   v_invoice.total::TEXT ||
                   v_invoice.company_id::TEXT ||
                   v_invoice.client_id::TEXT;

  v_new_hash := encode(digest(v_data_string, 'sha256'), 'hex');
  RETURN v_new_hash;
END;
$$;


ALTER FUNCTION "public"."generate_verifactu_hash"("p_invoice_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."generate_verifactu_hash"("p_invoice_id" "uuid") IS 'Genera hash SHA-256 para cadena Veri*Factu';



CREATE OR REPLACE FUNCTION "public"."get_addresses_dev"("target_user_id" "uuid") RETURNS TABLE("id" "uuid", "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "direccion" character varying, "numero" character varying, "piso" character varying, "puerta" character varying, "codigo_postal" character varying, "locality_id" "uuid", "usuario_id" "uuid")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        a.id,
        a.created_at,
        a.updated_at,
        a.direccion,
        a.numero,
        a.piso,
        a.puerta,
        a.codigo_postal,
        a.locality_id,
        a.usuario_id
    FROM public.addresses a
    WHERE a.usuario_id = target_user_id
    ORDER BY a.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_addresses_dev"("target_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_addresses_dev"("target_user_id" "uuid") IS 'Función RPC para obtener direcciones en modo desarrollo';



CREATE OR REPLACE FUNCTION "public"."get_all_companies_stats"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    company_record RECORD;
    all_stats jsonb := '[]'::jsonb;
    company_stats jsonb;
BEGIN
    -- Para cada empresa activa
    FOR company_record IN 
        SELECT id, name FROM companies WHERE deleted_at IS NULL ORDER BY name
    LOOP
        -- Obtener estadísticas de la empresa
        company_stats := get_ticket_stats(company_record.id);
        
        -- Añadir nombre de empresa
        company_stats := company_stats || jsonb_build_object('companyName', company_record.name);
        
        -- Agregar al array de resultados
        all_stats := all_stats || jsonb_build_array(company_stats);
    END LOOP;
    
    RETURN jsonb_build_object(
        'companies', all_stats,
        'totalCompanies', jsonb_array_length(all_stats),
        'generatedAt', now()
    );
END;
$$;


ALTER FUNCTION "public"."get_all_companies_stats"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_all_users_with_customers"() RETURNS TABLE("user_id" "uuid", "customer_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.usuario_id as user_id,
        COUNT(*) as customer_count
    FROM public.customers c
    GROUP BY c.usuario_id
    HAVING COUNT(*) > 0
    ORDER BY customer_count DESC;
END;
$$;


ALTER FUNCTION "public"."get_all_users_with_customers"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_all_users_with_customers"() IS 'Función RPC para obtener usuarios con clientes para el selector DEV';



CREATE OR REPLACE FUNCTION "public"."get_availability_data"("p_company_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_schedules jsonb;
  v_bookings jsonb;
BEGIN
  -- Fetch Schedules for all professionals in the company
  SELECT jsonb_agg(t) INTO v_schedules FROM (
    SELECT user_id, day_of_week, start_time, end_time
    FROM availability_schedules
    WHERE user_id IN (SELECT user_id FROM company_members WHERE company_id = p_company_id)
  ) t;

  -- Fetch Bookings (Busy slots), anonymized
  SELECT jsonb_agg(t) INTO v_bookings FROM (
    SELECT start_time, end_time, professional_id, resource_id
    FROM bookings
    WHERE company_id = p_company_id
    AND status != 'cancelled'
    AND start_time < p_end_date
    AND end_time > p_start_date
  ) t;

  RETURN jsonb_build_object(
    'schedules', COALESCE(v_schedules, '[]'::jsonb),
    'bookings', COALESCE(v_bookings, '[]'::jsonb)
  );
END;
$$;


ALTER FUNCTION "public"."get_availability_data"("p_company_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_booking_config"("p_company_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_config jsonb;
BEGIN
    SELECT booking_preferences INTO v_config
    FROM company_settings
    WHERE company_id = p_company_id;

    RETURN v_config;
END;
$$;


ALTER FUNCTION "public"."get_booking_config"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_client_clinical_notes"("p_client_id" "uuid") RETURNS TABLE("id" "uuid", "client_id" "uuid", "content" "text", "created_at" timestamp with time zone, "created_by_name" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    v_encryption_key text := 'simplifica-secure-key-2026';
    v_has_access boolean;
BEGIN
    -- 1. Permission Check
    SELECT EXISTS (
        SELECT 1 FROM public.clients c
        JOIN public.company_members cm ON c.company_id = cm.company_id
        WHERE c.id = p_client_id
        AND cm.user_id = auth.uid()
        AND cm.status = 'active'
    ) INTO v_has_access;

    IF NOT v_has_access THEN
        RAISE EXCEPTION 'Access denied: User is not an active member of the client company';
    END IF;

    -- 2. Return Decrypted Data
    RETURN QUERY
    SELECT 
        n.id,
        n.client_id,
        extensions.pgp_sym_decrypt(n.content::bytea, v_encryption_key) AS content,
        n.created_at,
        u.name AS created_by_name
    FROM public.client_clinical_notes n
    LEFT JOIN public.users u ON n.created_by = u.id
    WHERE n.client_id = p_client_id
    ORDER BY n.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_client_clinical_notes"("p_client_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_client_consent_request"("p_token" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_client record;
    v_company_name text;
BEGIN
    -- 1. Get Client and Company ID
    SELECT c.id, c.name, c.email, c.company_id, c.invitation_status
    INTO v_client
    FROM public.clients c
    WHERE c.invitation_token = p_token
    LIMIT 1;

    IF v_client.id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Token not found');
    END IF;

    IF v_client.invitation_status = 'completed' THEN
         RETURN jsonb_build_object('success', false, 'error', 'Invitation already completed');
    END IF;

    -- 2. Get Company Name
    SELECT name INTO v_company_name
    FROM public.companies
    WHERE id = v_client.company_id;

    RETURN jsonb_build_object(
        'success', true,
        'client_id', v_client.id,
        'client_name', v_client.name,
        'subject_email', v_client.email,
        'company_name', COALESCE(v_company_name, 'Simplifica CRM'),
        'purpose', 'Validación de datos y consentimiento RGPD'
    );
END;
$$;


ALTER FUNCTION "public"."get_client_consent_request"("p_token" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_client_consent_status"("p_client_id" "uuid", "p_requesting_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_client record;
    v_company_id uuid;
    v_consent_records jsonb;
BEGIN
    -- Verificar acceso
    SELECT company_id INTO v_company_id
    FROM users
    WHERE auth_user_id = COALESCE(p_requesting_user_id, auth.uid());
    
    -- Obtener cliente
    SELECT * INTO v_client
    FROM clients
    WHERE id = p_client_id
    AND company_id = v_company_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Cliente no encontrado o sin acceso'
        );
    END IF;
    
    -- Obtener registros de consentimiento detallados
    SELECT COALESCE(jsonb_agg(jsonb_build_object(
        'id', cr.id,
        'consent_type', cr.consent_type,
        'purpose', cr.purpose,
        'consent_given', cr.consent_given,
        'consent_method', cr.consent_method,
        'consent_evidence', cr.consent_evidence,
        'legal_basis', cr.legal_basis,
        'created_at', cr.created_at,
        'withdrawn_at', cr.withdrawn_at,
        'is_active', cr.is_active
    ) ORDER BY cr.created_at DESC), '[]'::jsonb) INTO v_consent_records
    FROM gdpr_consent_records cr
    WHERE cr.subject_email = v_client.email;
    
    RETURN jsonb_build_object(
        'success', true,
        'client_id', p_client_id,
        'client_email', v_client.email,
        'client_name', v_client.name,
        'consents', jsonb_build_object(
            'marketing_consent', v_client.marketing_consent,
            'marketing_consent_date', v_client.marketing_consent_date,
            'marketing_consent_method', v_client.marketing_consent_method,
            'data_processing_consent', v_client.data_processing_consent,
            'data_processing_consent_date', v_client.data_processing_consent_date,
            'data_processing_legal_basis', v_client.data_processing_legal_basis
        ),
        'consent_records', v_consent_records,
        'data_retention_until', v_client.data_retention_until,
        'is_active', v_client.is_active
    );
    
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'error_detail', SQLSTATE
    );
END;
$$;


ALTER FUNCTION "public"."get_client_consent_status"("p_client_id" "uuid", "p_requesting_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_client_consent_status"("p_client_id" "uuid", "p_requesting_user_id" "uuid") IS 'Obtiene el estado completo de consentimientos de un cliente';



CREATE OR REPLACE FUNCTION "public"."get_client_invoices_rpc"("p_invoice_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_user_id uuid := auth.uid();
    v_mapped_client_id uuid;
    v_mapped_company_id uuid;
    v_result jsonb;
BEGIN
    -- 1. Resolve Client & Company
    SELECT client_id, company_id INTO v_mapped_client_id, v_mapped_company_id
    FROM client_portal_users
    WHERE email = (SELECT email FROM auth.users WHERE id = v_user_id)
      AND is_active = true
    LIMIT 1;

    IF v_mapped_client_id IS NULL THEN
        SELECT id, company_id INTO v_mapped_client_id, v_mapped_company_id
        FROM clients
        WHERE auth_user_id = v_user_id
          AND is_active = true
        LIMIT 1;
    END IF;

    IF v_mapped_client_id IS NULL THEN
        -- Return empty list or null depending on context, EF returned []
        IF p_invoice_id IS NOT NULL THEN
            RETURN NULL;
        ELSE
            RETURN '[]'::jsonb;
        END IF;
    END IF;

    -- 2. Fetch Data
    IF p_invoice_id IS NOT NULL THEN
        -- Detail
        SELECT jsonb_build_object(
            'id', i.id,
            'company_id', i.company_id,
            'client_id', i.client_id,
            'full_invoice_number', i.full_invoice_number,
            'invoice_series', i.invoice_series,
            'invoice_number', i.invoice_number,
            'status', i.status,
            'payment_status', i.payment_status,
            'payment_link_token', i.payment_link_token,
            'payment_link_expires_at', i.payment_link_expires_at,
            'stripe_payment_url', i.stripe_payment_url,
            'paypal_payment_url', i.paypal_payment_url,
            'invoice_date', i.invoice_date,
            'due_date', i.due_date,
            'total', i.total,
            'currency', i.currency,
            'items', (
                SELECT jsonb_agg(jsonb_build_object(
                    'id', ii.id,
                    'line_order', ii.line_order,
                    'description', ii.description,
                    'quantity', ii.quantity,
                    'unit_price', ii.unit_price,
                    'tax_rate', ii.tax_rate,
                    'total', ii.total
                ))
                FROM invoice_items ii
                WHERE ii.invoice_id = i.id
            )
        ) INTO v_result
        FROM invoices i
        WHERE i.id = p_invoice_id
          AND i.client_id = v_mapped_client_id
          AND i.company_id = v_mapped_company_id;
        
        RETURN v_result;
    ELSE
        -- List
        SELECT jsonb_agg(jsonb_build_object(
            'id', i.id,
            'company_id', i.company_id,
            'client_id', i.client_id,
            'full_invoice_number', i.full_invoice_number,
            'invoice_series', i.invoice_series,
            'invoice_number', i.invoice_number,
            'status', i.status,
            'payment_status', i.payment_status,
            'payment_link_token', i.payment_link_token,
            'payment_link_expires_at', i.payment_link_expires_at,
            'stripe_payment_url', i.stripe_payment_url,
            'paypal_payment_url', i.paypal_payment_url,
            'invoice_date', i.invoice_date,
            'total', i.total,
            'currency', i.currency
        ) ORDER BY i.invoice_date DESC) INTO v_result
        FROM invoices i
        WHERE i.client_id = v_mapped_client_id
          AND i.company_id = v_mapped_company_id;

        RETURN COALESCE(v_result, '[]'::jsonb);
    END IF;
END;
$$;


ALTER FUNCTION "public"."get_client_invoices_rpc"("p_invoice_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_client_notes"("p_client_id" "uuid") RETURNS SETOF "public"."note_decrypted"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    current_uid uuid;
BEGIN
    current_uid := get_my_public_id();

    RETURN QUERY
    SELECT 
        cn.id,
        cn.client_id,
        cn.company_id,
        cn.author_id,
        cn.created_at,
        convert_from(
            pgsodium.crypto_secretbox_open(
                cn.encrypted_content,
                cn.nonce,
                cn.key_id
            ),
            'utf8'
        ) as content,
        (u.name || ' ' || COALESCE(u.surname, '')) as author_name
    FROM client_notes cn
    LEFT JOIN users u ON cn.author_id = u.id
    WHERE cn.client_id = p_client_id
    AND EXISTS (
        SELECT 1 FROM company_members cm 
        WHERE cm.user_id = current_uid 
        AND cm.company_id = cn.company_id 
        AND cm.status = 'active'
    )
    ORDER BY cn.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_client_notes"("p_client_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_client_quotes_rpc"("p_quote_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_user_id uuid := auth.uid();
    v_mapped_client_id uuid;
    v_mapped_company_id uuid;
    v_result jsonb;
BEGIN
    SELECT client_id, company_id INTO v_mapped_client_id, v_mapped_company_id
    FROM client_portal_users
    WHERE email = (SELECT email FROM auth.users WHERE id = v_user_id)
      AND is_active = true
    LIMIT 1;

    IF v_mapped_client_id IS NULL THEN
        SELECT id, company_id INTO v_mapped_client_id, v_mapped_company_id
        FROM clients
        WHERE auth_user_id = v_user_id
          AND is_active = true
        LIMIT 1;
    END IF;

    IF v_mapped_client_id IS NULL THEN
        IF p_quote_id IS NOT NULL THEN RETURN NULL; ELSE RETURN '[]'::jsonb; END IF;
    END IF;

    IF p_quote_id IS NOT NULL THEN
        -- Detail
        SELECT jsonb_build_object(
            'id', q.id,
            'company_id', q.company_id,
            'client_id', q.client_id,
            'full_quote_number', q.full_quote_number,
            'title', q.title,
            'status', q.status,
            'quote_date', q.quote_date,
            'valid_until', q.valid_until,
            'total_amount', q.total_amount,
            'convert_policy', q.convert_policy, -- Policy computation logic left for FE or separate logic if crucial
            'items', (
                SELECT jsonb_agg(qi.*)
                FROM quote_items qi
                WHERE qi.quote_id = q.id
            )
        ) INTO v_result
        FROM quotes q
        WHERE q.id = p_quote_id
          AND q.client_id = v_mapped_client_id
          AND q.company_id = v_mapped_company_id;
        
        RETURN v_result;
    ELSE
        -- List
        SELECT jsonb_agg(q.* ORDER BY q.quote_date DESC) INTO v_result
        FROM quotes q
        WHERE q.client_id = v_mapped_client_id
          AND q.company_id = v_mapped_company_id;

        RETURN COALESCE(v_result, '[]'::jsonb);
    END IF;
END;
$$;


ALTER FUNCTION "public"."get_client_quotes_rpc"("p_quote_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_company_config_stages"("p_expected_company_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("id" "uuid", "name" "text", "position" integer, "color" "text", "company_id" "uuid", "stage_category" "text", "workflow_category" "text", "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "deleted_at" timestamp with time zone, "is_hidden" boolean, "effective_position" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
BEGIN
  -- Resolve Company
  SELECT company_id INTO v_company_id
  FROM public.users
  WHERE auth_user_id = auth.uid();

  IF v_company_id IS NULL THEN
     SELECT company_id INTO v_company_id FROM public.clients WHERE auth_user_id = auth.uid();
  END IF;

  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'User not associated with a company';
  END IF;

  -- Optional check if specific company requested matches user's company
  -- Just ignore p_expected_company_id if it matches, raise specific error if mismatch to mimic edge function behavior
  IF p_expected_company_id IS NOT NULL AND p_expected_company_id != v_company_id THEN
    RAISE EXCEPTION 'Forbidden company_id';
  END IF;

  RETURN QUERY
  SELECT 
    ts.id,
    ts.name,
    ts.position,
    ts.color,
    ts.company_id,
    ts.stage_category,
    ts.workflow_category,
    ts.created_at,
    ts.updated_at,
    ts.deleted_at,
    (hs.stage_id IS NOT NULL) as is_hidden,
    COALESCE(cso.position, ts.position) as effective_position
  FROM ticket_stages ts
  LEFT JOIN hidden_stages hs ON hs.stage_id = ts.id AND hs.company_id = v_company_id
  LEFT JOIN company_stage_order cso ON cso.stage_id = ts.id AND cso.company_id = v_company_id
  WHERE ts.company_id IS NULL AND ts.deleted_at IS NULL
  ORDER BY effective_position ASC;
END;
$$;


ALTER FUNCTION "public"."get_company_config_stages"("p_expected_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_company_config_units"("p_expected_company_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("id" "uuid", "name" "text", "company_id" "uuid", "created_at" timestamp with time zone, "is_hidden" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
BEGIN
  -- Resolve Company
  SELECT company_id INTO v_company_id
  FROM public.users
  WHERE auth_user_id = auth.uid();

  IF v_company_id IS NULL THEN
     SELECT company_id INTO v_company_id FROM public.clients WHERE auth_user_id = auth.uid();
  END IF;

  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'User not associated with a company';
  END IF;

  IF p_expected_company_id IS NOT NULL AND p_expected_company_id != v_company_id THEN
    RAISE EXCEPTION 'Forbidden company_id';
  END IF;

  RETURN QUERY
  SELECT 
    su.id,
    su.name,
    su.company_id,
    su.created_at,
    (hu.unit_id IS NOT NULL) as is_hidden
  FROM service_units su
  LEFT JOIN hidden_units hu ON hu.unit_id = su.id AND hu.company_id = v_company_id
  WHERE su.company_id IS NULL
  ORDER BY su.name ASC;
END;
$$;


ALTER FUNCTION "public"."get_company_config_units"("p_expected_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_company_id_from_jwt"() RETURNS "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT COALESCE(
    (auth.jwt() ->> 'company_id')::uuid,
    (auth.jwt() -> 'user_metadata' ->> 'company_id')::uuid,
    (auth.jwt() -> 'app_metadata' ->> 'company_id')::uuid
  );
$$;


ALTER FUNCTION "public"."get_company_id_from_jwt"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_company_invitation_token"("p_invitation_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_token TEXT;
BEGIN
  SELECT token INTO v_token
  FROM public.company_invitations
  WHERE id = p_invitation_id;

  RETURN v_token;
END;
$$;


ALTER FUNCTION "public"."get_company_invitation_token"("p_invitation_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_company_invitation_token"("p_invitation_id" "uuid") IS 'Returns token for a given company_invitations.id';



CREATE OR REPLACE FUNCTION "public"."get_company_schedule"("p_company_id" "uuid") RETURNS TABLE("user_id" "uuid", "day_of_week" integer, "start_time" time without time zone, "end_time" time without time zone, "is_unavailable" boolean)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_owner_id uuid;
BEGIN
    -- Find the owner of the company
    SELECT cm.user_id INTO v_owner_id
    FROM company_members cm
    JOIN app_roles ar ON cm.role_id = ar.id
    WHERE cm.company_id = p_company_id
    AND ar.name = 'owner'
    AND cm.status = 'active'
    LIMIT 1;

    IF v_owner_id IS NULL THEN
        RETURN; -- Return empty set if no owner found
    END IF;

    -- Return the owner's default schedule
    RETURN QUERY
    SELECT 
        s.user_id,
        s.day_of_week,
        s.start_time,
        s.end_time,
        s.is_unavailable
    FROM availability_schedules s
    WHERE s.user_id = v_owner_id
    AND s.booking_type_id IS NULL
    ORDER BY s.day_of_week, s.start_time;
END;
$$;


ALTER FUNCTION "public"."get_company_schedule"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_company_services_with_variants"("p_company_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_result jsonb;
BEGIN
  SELECT jsonb_agg(
    jsonb_build_object(
      'service', row_to_json(s.*),
      'variants', COALESCE(
        (
          SELECT jsonb_agg(row_to_json(sv.*) ORDER BY sv.sort_order, sv.variant_name, sv.billing_period)
          FROM service_variants sv
          WHERE sv.service_id = s.id
          AND sv.is_active = true
        ),
        '[]'::jsonb
      )
    )
  )
  INTO v_result
  FROM services s
  WHERE s.company_id = p_company_id
  AND s.is_active = true
  AND s.deleted_at IS NULL
  ORDER BY s.name;
  
  RETURN COALESCE(v_result, '[]'::jsonb);
END;
$$;


ALTER FUNCTION "public"."get_company_services_with_variants"("p_company_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_company_services_with_variants"("p_company_id" "uuid") IS 'Obtiene todos los servicios activos de una empresa con sus variantes';



CREATE OR REPLACE FUNCTION "public"."get_config_stages"() RETURNS TABLE("id" "uuid", "name" "text", "position" integer, "color" "text", "company_id" "uuid", "stage_category" "public"."stage_category", "workflow_category" "public"."workflow_category", "is_hidden" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_company_id uuid := public.get_user_company_id();
BEGIN
  RETURN QUERY
  SELECT 
    s.id,
    s.name::text,
    s.position,
    s.color::text,
    s.company_id,
    s.stage_category,
    s.workflow_category,
    (hs.id IS NOT NULL) as is_hidden
  FROM public.ticket_stages s
  LEFT JOIN public.hidden_stages hs ON s.id = hs.stage_id AND hs.company_id = v_company_id
  WHERE s.company_id = v_company_id OR s.company_id IS NULL -- System stages + Company stages
  ORDER BY s.position;
END;
$$;


ALTER FUNCTION "public"."get_config_stages"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_config_units"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_company_id uuid;
    v_user_id uuid;
    result jsonb;
BEGIN
    v_user_id := auth.uid();
    
    -- Get user's company (try users table first)
    SELECT company_id INTO v_company_id FROM public.users WHERE auth_user_id = v_user_id;
    
    -- If not found, try clients (though typically config is for dashboard users)
    IF v_company_id IS NULL THEN
        SELECT company_id INTO v_company_id FROM public.clients WHERE auth_user_id = v_user_id;
    END IF;

    -- Return units combined with is_hidden flag
    SELECT jsonb_agg(
        to_jsonb(u) || jsonb_build_object('is_hidden', (hu.unit_id IS NOT NULL))
        ORDER BY u.name ASC
    ) INTO result
    FROM public.service_units u
    LEFT JOIN public.hidden_units hu ON u.id = hu.unit_id AND hu.company_id = v_company_id
    WHERE (u.company_id IS NULL OR u.company_id = v_company_id)
    AND (u.deleted_at IS NULL);

    RETURN COALESCE(result, '[]'::jsonb);
END;
$$;


ALTER FUNCTION "public"."get_config_units"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_customer_stats"("user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'total', (SELECT COUNT(*) FROM public.customers WHERE usuario_id = user_id),
        'active_this_month', (
            SELECT COUNT(*) 
            FROM public.customers 
            WHERE usuario_id = user_id 
            AND created_at >= date_trunc('month', CURRENT_DATE)
        ),
        'new_this_week', (
            SELECT COUNT(*) 
            FROM public.customers 
            WHERE usuario_id = user_id 
            AND created_at >= date_trunc('week', CURRENT_DATE)
        ),
        'by_locality', (
            SELECT json_object_agg(l.name, customer_count)
            FROM (
                SELECT 
                    COALESCE(l.name, 'Sin localidad') as name,
                    COUNT(c.id) as customer_count
                FROM public.customers c
                LEFT JOIN public.addresses a ON c.direccion_id = a.id
                LEFT JOIN public.localities l ON a.locality_id = l.id
                WHERE c.usuario_id = user_id
                GROUP BY l.name
            ) l
        )
    ) INTO result;
    
    RETURN result;
END;
$$;


ALTER FUNCTION "public"."get_customer_stats"("user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_customer_stats_dev"("target_user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'total', (
            SELECT COUNT(*) 
            FROM public.customers 
            WHERE usuario_id = target_user_id
        ),
        'active_this_month', (
            SELECT COUNT(*) 
            FROM public.customers 
            WHERE 
                usuario_id = target_user_id AND
                activo = true AND
                created_at >= date_trunc('month', CURRENT_DATE)
        ),
        'new_this_week', (
            SELECT COUNT(*) 
            FROM public.customers 
            WHERE 
                usuario_id = target_user_id AND
                created_at >= date_trunc('week', CURRENT_DATE)
        ),
        'by_locality', (
            SELECT COALESCE(json_object_agg(l.name, customer_count), '{}'::json)
            FROM (
                SELECT 
                    COALESCE(l.name, 'Sin localidad') as name,
                    COUNT(c.id) as customer_count
                FROM public.customers c
                LEFT JOIN public.addresses a ON c.direccion_id = a.id
                LEFT JOIN public.localities l ON a.locality_id = l.id
                WHERE c.usuario_id = target_user_id
                GROUP BY l.name
                HAVING COUNT(c.id) > 0
            ) l
        )
    ) INTO result;
    
    RETURN result;
END;
$$;


ALTER FUNCTION "public"."get_customer_stats_dev"("target_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_customer_stats_dev"("target_user_id" "uuid") IS 'Función RPC para estadísticas de clientes en modo desarrollo';



CREATE OR REPLACE FUNCTION "public"."get_customers_dev"("target_user_id" "uuid") RETURNS TABLE("id" "uuid", "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "nombre" character varying, "apellidos" character varying, "dni" character varying, "fecha_nacimiento" "date", "email" character varying, "telefono" character varying, "profesion" character varying, "empresa" character varying, "notas" "text", "activo" boolean, "avatar_url" "text", "direccion_id" "uuid", "usuario_id" "uuid", "search_vector" "tsvector")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.id,
        c.created_at,
        c.updated_at,
        c.nombre,
        c.apellidos,
        c.dni,
        c.fecha_nacimiento,
        c.email,
        c.telefono,
        c.profesion,
        c.empresa,
        c.notas,
        c.activo,
        c.avatar_url,
        c.direccion_id,
        c.usuario_id,
        c.search_vector
    FROM public.customers c
    WHERE c.usuario_id = target_user_id
    ORDER BY c.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_customers_dev"("target_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_customers_dev"("target_user_id" "uuid") IS 'Función RPC para obtener clientes de un usuario específico en modo desarrollo, bypaseando RLS';



CREATE OR REPLACE FUNCTION "public"."get_daily_revenue"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") RETURNS TABLE("day" "date", "revenue" numeric, "bookings_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    date_trunc('day', b.start_time)::date as day,
    SUM(COALESCE(b.total_price, 0)) as revenue,
    COUNT(b.id) as bookings_count
  FROM bookings b
  WHERE 
    b.company_id = p_company_id
    AND b.start_time >= start_date 
    AND b.start_time <= end_date
    AND b.status = 'confirmed'
  GROUP BY 1
  ORDER BY 1;
END;
$$;


ALTER FUNCTION "public"."get_daily_revenue"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_devices_stats"("company_uuid" "uuid") RETURNS TABLE("total_devices" bigint, "received_count" bigint, "in_progress_count" bigint, "completed_count" bigint, "delivered_count" bigint, "avg_repair_time" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_devices,
        COUNT(*) FILTER (WHERE status = 'received') as received_count,
        COUNT(*) FILTER (WHERE status = 'in_progress') as in_progress_count,
        COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
        COUNT(*) FILTER (WHERE status = 'delivered') as delivered_count,
        AVG(actual_repair_time) as avg_repair_time
    FROM devices 
    WHERE company_id = company_uuid
    AND created_at >= NOW() - INTERVAL '30 days';
END;
$$;


ALTER FUNCTION "public"."get_devices_stats"("company_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_devices_with_client_info"("company_uuid" "uuid") RETURNS TABLE("device_id" "uuid", "brand" character varying, "model" character varying, "device_type" character varying, "status" character varying, "client_name" character varying, "client_email" character varying, "received_at" timestamp with time zone, "estimated_cost" numeric, "progress_days" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        d.id as device_id,
        d.brand,
        d.model,
        d.device_type,
        d.status,
        c.name as client_name,
        c.email as client_email,
        d.received_at,
        d.estimated_cost,
        EXTRACT(DAY FROM NOW() - d.received_at)::INTEGER as progress_days
    FROM devices d
    LEFT JOIN clients c ON d.client_id = c.id
    WHERE d.company_id = company_uuid
    ORDER BY d.received_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_devices_with_client_info"("company_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_effective_modules"("p_input_company_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
declare
    result jsonb;
    v_auth_user_id uuid;
    v_public_user_id uuid;
    v_target_company_id uuid;
    v_membership_role text;
    v_global_role text;
    v_is_client boolean := false;
begin
    v_auth_user_id := auth.uid();
    
    -- 1. Check Global Role (super_admin has access to everything)
    select ar.name into v_global_role
    from public.users u
    left join public.app_roles ar on ar.id = u.app_role_id
    where u.auth_user_id = v_auth_user_id;

    if v_global_role = 'super_admin' then
        SELECT jsonb_agg(
            jsonb_build_object(
                'key', m.key,
                'name', m.label,
                'enabled', true
            ) ORDER BY m.key
        ) INTO result
        FROM public.modules_catalog m;
        
        RETURN COALESCE(result, '[]'::jsonb);
    end if;

    -- 2. Normal Logic (Membership check)
    if p_input_company_id is not null then
        v_target_company_id := p_input_company_id;
        
        -- Check if Actively a Member
        select ar.name into v_membership_role
        from public.company_members cm
        join public.users u on u.id = cm.user_id
        left join public.app_roles ar on ar.id = cm.role_id
        where u.auth_user_id = v_auth_user_id
          and cm.company_id = v_target_company_id
          and cm.status = 'active';
          
        if v_membership_role is not null then
             -- Check if explicit role is client
             if v_membership_role = 'client' then
                v_is_client := true;
             end if;

             -- IS STAFF / MEMBER
             select id into v_public_user_id
             from public.users
             where auth_user_id = v_auth_user_id;
        else
             -- NOT MEMBER: Check if Client in clients table
             perform 1 from public.clients
             where auth_user_id = v_auth_user_id
               and company_id = v_target_company_id
               and is_active = true;
               
             if found then
                v_is_client := true;
             end if;
        end if;
        
    else
        -- NO COMPANY ID PROVIDED (Default behavior)
        select id into v_public_user_id from public.users where auth_user_id = v_auth_user_id;
        
        -- Check if user has role 'client' in any active company membership
        -- We prioritize company_members check if they exist there with role 'client'
        select cm.company_id, ar.name into v_target_company_id, v_membership_role
        from public.company_members cm
        join public.users u on u.id = cm.user_id
        left join public.app_roles ar on ar.id = cm.role_id
        where u.auth_user_id = v_auth_user_id
          and cm.status = 'active'
        limit 1;
        
        if v_membership_role = 'client' then
            v_is_client := true;
        end if;
        
        -- If not determined yet, check clients table
        if not v_is_client then
             select company_id into v_target_company_id
             from public.clients
             where auth_user_id = v_auth_user_id
             and is_active = true
             limit 1;
             
             if v_target_company_id is not null then
                v_is_client := true;
             end if;
        end if;
    end if;

    -- 3. LOGIC: STAFF (User Modules) - ONLY if Not Client
    if v_public_user_id is not null and not v_is_client then
        SELECT jsonb_agg(
            jsonb_build_object(
                'key', m.key,
                'name', m.label,
                'enabled', (
                    um.status IS NOT NULL AND
                    LOWER(um.status::text) IN ('activado', 'active', 'enabled')
                )
            ) ORDER BY m.key
        ) INTO result
        FROM public.modules_catalog m
        LEFT JOIN public.user_modules um
            ON m.key = um.module_key
            AND um.user_id = v_public_user_id;

        RETURN COALESCE(result, '[]'::jsonb);
    end if;

    -- 4. LOGIC: CLIENT (Company Modules)
    if v_is_client then
        -- Return all modules, marked enabled if company has them active
        SELECT jsonb_agg(
            jsonb_build_object(
                'key', m.key,
                'name', m.label,
                'enabled', (cm.status = 'active')
            ) ORDER BY m.key
        ) INTO result
        FROM public.modules_catalog m
        LEFT JOIN public.company_modules cm 
            ON m.key = cm.module_key 
            AND cm.company_id = v_target_company_id;

        RETURN COALESCE(result, '[]'::jsonb);
    end if;

    -- 5. Fallback: Empty
    RETURN '[]'::jsonb;
END;
$$;


ALTER FUNCTION "public"."get_effective_modules"("p_input_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_effective_role_id"("p_company_id" "uuid", "p_auth_user_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_role_id uuid;
  v_user_id uuid;
BEGIN
  -- Get public user id (This call is now safe as we are SECURITY DEFINER)
  SELECT id INTO v_user_id FROM public.users WHERE auth_user_id = p_auth_user_id LIMIT 1;
  IF v_user_id IS NULL THEN RETURN NULL; END IF;

  -- 1. Check company_members
  SELECT role_id INTO v_role_id
  FROM public.company_members
  WHERE user_id = v_user_id
  AND company_id = p_company_id
  AND status = 'active'
  LIMIT 1;

  -- 2. If not found, check primary company in users table
  IF v_role_id IS NULL THEN
    SELECT app_role_id INTO v_role_id
    FROM public.users
    WHERE id = v_user_id
    AND company_id = p_company_id
    AND active = true;
  END IF;

  RETURN v_role_id;
END;
$$;


ALTER FUNCTION "public"."get_effective_role_id"("p_company_id" "uuid", "p_auth_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_employee_company_id"() RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Only return company_id if the user exists in public.users (Employees/Owners)
  -- Clients (public.clients) will return NULL, preventing access to general company records.
  RETURN (SELECT company_id FROM public.users WHERE auth_user_id = auth.uid() LIMIT 1);
END;
$$;


ALTER FUNCTION "public"."get_employee_company_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_job_attachments"("p_job_id" "uuid", "p_company_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("id" "uuid", "file_name" "text", "file_path" "text", "file_size" integer, "mime_type" "text", "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Si no se especifica company_id, intentar obtenerlo del contexto
  IF p_company_id IS NULL THEN
    p_company_id := public.get_current_company_id();
  END IF;
  
  RETURN QUERY
  SELECT a.id, a.file_name, a.file_path, a.file_size, a.mime_type, a.created_at
  FROM public.attachments a
  JOIN public.jobs j ON j.id = a.job_id
  WHERE a.job_id = p_job_id 
    AND a.deleted_at IS NULL
    AND j.deleted_at IS NULL
    AND (p_company_id IS NULL OR j.company_id = p_company_id);
END;
$$;


ALTER FUNCTION "public"."get_job_attachments"("p_job_id" "uuid", "p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_my_company_id"() RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  RETURN (SELECT company_id FROM public.users WHERE id = auth.uid());
END;
$$;


ALTER FUNCTION "public"."get_my_company_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_my_company_ids"() RETURNS "uuid"[]
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT array_agg(company_id)
  FROM company_members
  WHERE user_id = (SELECT id FROM users WHERE auth_user_id = auth.uid())
  AND status = 'active';
$$;


ALTER FUNCTION "public"."get_my_company_ids"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_my_public_id"() RETURNS "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT id FROM public.users WHERE auth_user_id = auth.uid();
$$;


ALTER FUNCTION "public"."get_my_public_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_next_invoice_number"("p_series_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_next_number INTEGER;
  v_prefix TEXT;
  v_number_text TEXT;
BEGIN
  UPDATE invoice_series
  SET next_number = next_number + 1,
      updated_at = CURRENT_TIMESTAMP
  WHERE id = p_series_id
  RETURNING next_number - 1, prefix INTO v_next_number, v_prefix;

  v_number_text := LPAD(v_next_number::TEXT, 5, '0');
  RETURN v_number_text;
END;
$$;


ALTER FUNCTION "public"."get_next_invoice_number"("p_series_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_next_invoice_number"("p_series_id" "uuid") IS 'Genera el siguiente número de factura para una serie';



CREATE OR REPLACE FUNCTION "public"."get_next_quote_number"("p_company_id" "uuid", "p_year" integer) RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  next_number INTEGER;
BEGIN
  -- Obtener el siguiente número de secuencia para el año
  SELECT COALESCE(MAX(sequence_number), 0) + 1
  INTO next_number
  FROM quotes
  WHERE company_id = p_company_id
    AND year = p_year;
  
  RETURN next_number;
END;
$$;


ALTER FUNCTION "public"."get_next_quote_number"("p_company_id" "uuid", "p_year" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_next_quote_number"("p_company_id" "uuid", "p_year" integer) IS 'Genera el siguiente número de presupuesto para una empresa y año';



CREATE OR REPLACE FUNCTION "public"."get_next_ticket_number"("p_company_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_next_val INTEGER;
BEGIN
    -- Upsert: Insert 0 if not exists, then increment and return
    INSERT INTO public.company_ticket_sequences (company_id, last_val)
    VALUES (p_company_id, 0)
    ON CONFLICT (company_id) DO NOTHING;

    -- Increment and return new value (Atomic update)
    UPDATE public.company_ticket_sequences
    SET last_val = last_val + 1,
        updated_at = NOW()
    WHERE company_id = p_company_id
    RETURNING last_val INTO v_next_val;

    RETURN v_next_val;
END;
$$;


ALTER FUNCTION "public"."get_next_ticket_number"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_or_create_brand"("p_brand_name" "text", "p_company_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_brand_id UUID;
BEGIN
  -- Try to find existing brand
  SELECT id INTO v_brand_id
  FROM public.product_brands
  WHERE name = p_brand_name
    AND (company_id = p_company_id OR company_id IS NULL)
    AND deleted_at IS NULL
  LIMIT 1;

  -- If not found, create it
  IF v_brand_id IS NULL THEN
    INSERT INTO public.product_brands (name, company_id)
    VALUES (p_brand_name, p_company_id)
    RETURNING id INTO v_brand_id;
  END IF;

  RETURN v_brand_id;
END;
$$;


ALTER FUNCTION "public"."get_or_create_brand"("p_brand_name" "text", "p_company_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_or_create_brand"("p_brand_name" "text", "p_company_id" "uuid") IS 'Helper function to get existing brand or create new one';



CREATE OR REPLACE FUNCTION "public"."get_or_create_category"("p_category_name" "text", "p_company_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_category_id UUID;
BEGIN
  -- Try to find existing category
  SELECT id INTO v_category_id
  FROM public.product_categories
  WHERE name = p_category_name
    AND (company_id = p_company_id OR company_id IS NULL)
    AND deleted_at IS NULL
  LIMIT 1;

  -- If not found, create it
  IF v_category_id IS NULL THEN
    INSERT INTO public.product_categories (name, company_id)
    VALUES (p_category_name, p_company_id)
    RETURNING id INTO v_category_id;
  END IF;

  RETURN v_category_id;
END;
$$;


ALTER FUNCTION "public"."get_or_create_category"("p_category_name" "text", "p_company_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_or_create_category"("p_category_name" "text", "p_company_id" "uuid") IS 'Helper function to get existing category or create new one';



CREATE OR REPLACE FUNCTION "public"."get_provider_tokens"("provider_name" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_user_id uuid;
  v_identity_data jsonb;
  v_access_token text;
  v_refresh_token text;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get identity data for the provider
  SELECT identity_data INTO v_identity_data
  FROM auth.identities
  WHERE user_id = v_user_id
  AND provider = provider_name
  LIMIT 1;

  IF v_identity_data IS NULL THEN
    RETURN json_build_object('error', 'Identity not found');
  END IF;

  -- Extract tokens
  v_access_token := v_identity_data->>'provider_access_token';
  v_refresh_token := v_identity_data->>'provider_refresh_token';

  -- Return as JSON
  RETURN json_build_object(
    'access_token', v_access_token,
    'refresh_token', v_refresh_token,
    'expires_in', (v_identity_data->>'expires_in')::int
  );
END;
$$;


ALTER FUNCTION "public"."get_provider_tokens"("provider_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_revenue_by_professional"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") RETURNS TABLE("professional_name" "text", "revenue" numeric, "bookings_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(u.name, 'Sin asignar') as professional_name,
    SUM(COALESCE(b.total_price, 0)) as revenue,
    COUNT(b.id) as bookings_count
  FROM bookings b
  LEFT JOIN users u ON b.professional_id = u.id
  WHERE 
    b.company_id = p_company_id
    AND b.start_time >= start_date 
    AND b.start_time <= end_date
    AND b.status = 'confirmed'
  GROUP BY u.name
  ORDER BY revenue DESC;
END;
$$;


ALTER FUNCTION "public"."get_revenue_by_professional"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_revenue_by_service"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") RETURNS TABLE("service_name" "text", "revenue" numeric, "bookings_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    s.name as service_name,
    SUM(COALESCE(b.total_price, 0)) as revenue,
    COUNT(b.id) as bookings_count
  FROM bookings b
  JOIN services s ON b.service_id = s.id
  WHERE 
    b.company_id = p_company_id
    AND b.start_time >= start_date 
    AND b.start_time <= end_date
    AND b.status = 'confirmed'
  GROUP BY s.name
  ORDER BY revenue DESC;
END;
$$;


ALTER FUNCTION "public"."get_revenue_by_service"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_service_with_variants"("p_service_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_result jsonb;
BEGIN
  SELECT jsonb_build_object(
    'service', row_to_json(s.*),
    'variants', COALESCE(
      (
        SELECT jsonb_agg(row_to_json(sv.*) ORDER BY sv.sort_order, sv.variant_name, sv.billing_period)
        FROM service_variants sv
        WHERE sv.service_id = s.id
        AND sv.is_active = true
      ),
      '[]'::jsonb
    )
  )
  INTO v_result
  FROM services s
  WHERE s.id = p_service_id;
  
  RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."get_service_with_variants"("p_service_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_service_with_variants"("p_service_id" "uuid") IS 'Obtiene un servicio con todas sus variantes activas';



CREATE OR REPLACE FUNCTION "public"."get_sessions_with_booking_counts"("p_start_date" "date" DEFAULT NULL::"date", "p_end_date" "date" DEFAULT NULL::"date") RETURNS TABLE("id" integer, "class_type_id" integer, "capacity" integer, "schedule_date" "date", "schedule_time" time without time zone, "confirmed_bookings_count" integer, "available_spots" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
begin
  return query
  select 
    cs.id,
    cs.class_type_id,
    cs.capacity,
    cs.schedule_date,
    cs.schedule_time,
    coalesce(b.confirmed_count, 0)::int as confirmed_bookings_count,
    (cs.capacity - coalesce(b.confirmed_count, 0))::int as available_spots
  from class_sessions cs
  left join (
    select class_session_id, count(*) as confirmed_count
    from bookings
    where upper(status) = 'CONFIRMED'
    group by class_session_id
  ) b on b.class_session_id = cs.id
  where (p_start_date is null or cs.schedule_date >= p_start_date)
    and (p_end_date is null or cs.schedule_date <= p_end_date)
  order by cs.schedule_date, cs.schedule_time;
end;
$$;


ALTER FUNCTION "public"."get_sessions_with_booking_counts"("p_start_date" "date", "p_end_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_ticket_stats"("target_company_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    stats_result jsonb;
    total_tickets integer;
    open_tickets integer;
    in_progress_tickets integer;
    completed_tickets integer;
    overdue_tickets integer;
    total_revenue numeric;
    total_estimated_hours numeric;
    total_actual_hours numeric;
    avg_resolution_days numeric;
    completed_with_dates integer;
    total_resolution_time bigint;
BEGIN
    -- Verificar que la empresa existe
    IF NOT EXISTS (SELECT 1 FROM companies WHERE id = target_company_id AND deleted_at IS NULL) THEN
        RAISE EXCEPTION 'Company with ID % does not exist or is deleted', target_company_id;
    END IF;
    
    -- Contar tickets totales
    SELECT COUNT(*) INTO total_tickets
    FROM tickets t
    WHERE t.company_id = target_company_id
    AND t.deleted_at IS NULL;
    
    -- Contar tickets abiertos/pendientes priorizando workflow_category (fallback a stage_category)
    SELECT COUNT(*) INTO open_tickets
    FROM tickets t
    JOIN ticket_stages ts ON t.stage_id = ts.id
    WHERE t.company_id = target_company_id
    AND t.deleted_at IS NULL
    AND (
        (ts.workflow_category IN ('waiting'))
        OR (ts.workflow_category IS NULL AND ts.stage_category = 'open')
    );
    
    -- Contar tickets en progreso priorizando workflow_category (analysis/action) con fallback a stage_category
    SELECT COUNT(*) INTO in_progress_tickets
    FROM tickets t
    JOIN ticket_stages ts ON t.stage_id = ts.id
    WHERE t.company_id = target_company_id
    AND t.deleted_at IS NULL
    AND (
        (ts.workflow_category IN ('analysis','action'))
        OR (ts.workflow_category IS NULL AND ts.stage_category = 'in_progress')
    );
    
    -- Contar tickets completados priorizando workflow_category (final/cancel) con fallback a stage_category
    SELECT COUNT(*) INTO completed_tickets
    FROM tickets t
    JOIN ticket_stages ts ON t.stage_id = ts.id
    WHERE t.company_id = target_company_id
    AND t.deleted_at IS NULL
    AND (
        (ts.workflow_category IN ('final','cancel'))
        OR (ts.workflow_category IS NULL AND ts.stage_category = 'completed')
    );
    
    -- Contar tickets vencidos
    SELECT COUNT(*) INTO overdue_tickets
    FROM tickets t
    WHERE t.company_id = target_company_id
    AND t.deleted_at IS NULL
    AND t.due_date IS NOT NULL
    AND t.due_date < CURRENT_DATE;
    
    -- Calcular ingresos totales
    SELECT COALESCE(SUM(t.total_amount), 0) INTO total_revenue
    FROM tickets t
    WHERE t.company_id = target_company_id
    AND t.deleted_at IS NULL;
    
    -- Calcular horas estimadas totales desde servicios asociados
    SELECT COALESCE(SUM(s.estimated_hours * ts.quantity), 0) INTO total_estimated_hours
    FROM tickets t
    JOIN ticket_services ts ON t.id = ts.ticket_id
    JOIN services s ON ts.service_id = s.id
    WHERE t.company_id = target_company_id
    AND t.deleted_at IS NULL;
    
    -- Calcular horas reales totales (si existe la columna actual_hours en tickets)
    -- Si no existe, usar estimated_hours de la tabla tickets como fallback
    BEGIN
        SELECT COALESCE(SUM(t.actual_hours), 0) INTO total_actual_hours
        FROM tickets t
        WHERE t.company_id = target_company_id
        AND t.deleted_at IS NULL;
    EXCEPTION WHEN undefined_column THEN
        -- Si no existe actual_hours, usar estimated_hours de tickets
        SELECT COALESCE(SUM(t.estimated_hours), 0) INTO total_actual_hours
        FROM tickets t
        WHERE t.company_id = target_company_id
        AND t.deleted_at IS NULL;
    END;
    
    -- Calcular tiempo promedio de resolución en días
    -- Solo para tickets completados que tienen fechas válidas
    SELECT COUNT(*), COALESCE(SUM(EXTRACT(EPOCH FROM (t.updated_at - t.created_at))), 0)
    INTO completed_with_dates, total_resolution_time
    FROM tickets t
    JOIN ticket_stages ts ON t.stage_id = ts.id
    WHERE t.company_id = target_company_id
    AND t.deleted_at IS NULL
    AND (
        (ts.workflow_category IN ('final','cancel'))
        OR (ts.workflow_category IS NULL AND ts.stage_category = 'completed')
    )
    AND t.created_at IS NOT NULL
    AND t.updated_at IS NOT NULL
    AND t.updated_at > t.created_at;
    
    -- Convertir a días promedio
    IF completed_with_dates > 0 THEN
        avg_resolution_days := ROUND((total_resolution_time / completed_with_dates) / 86400, 1);
    ELSE
        avg_resolution_days := 0;
    END IF;
    
    -- Construir resultado JSON
    stats_result := jsonb_build_object(
        'total', total_tickets,
        'open', open_tickets,
        'inProgress', in_progress_tickets,
        'completed', completed_tickets,
        'overdue', overdue_tickets,
        'avgResolutionTime', avg_resolution_days,
        'totalRevenue', total_revenue,
        'totalEstimatedHours', total_estimated_hours,
        'totalActualHours', total_actual_hours,
        'calculatedAt', now(),
        'companyId', target_company_id
    );
    
    RETURN stats_result;
END;
$$;


ALTER FUNCTION "public"."get_ticket_stats"("target_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_top_products"("limit_count" integer DEFAULT 3) RETURNS TABLE("product_id" "text", "product_name" "text", "total_quantity_sold" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
BEGIN
  -- Get the company_id for the current authenticated user
  SELECT company_id INTO v_company_id
  FROM public.users
  WHERE auth_user_id = auth.uid();

  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'Usuario no tiene compañía asignada';
  END IF;

  RETURN QUERY
  SELECT
    -- Logic from Edge Function: use product_id if available, else 'name:' + name
    COALESCE(ii.product_id::text, 'name:' || COALESCE(ii.name, ii.description, 'Producto sin nombre')) as p_id,
    COALESCE(ii.name, ii.description, 'Producto sin nombre') as p_name,
    SUM(COALESCE(ii.quantity, 0)) as total_qty
  FROM
    invoice_items ii
  JOIN
    invoices i ON ii.invoice_id = i.id
  WHERE
    i.company_id = v_company_id
    AND i.status = 'paid'
  GROUP BY
    1, 2
  ORDER BY
    total_qty DESC
  LIMIT
    limit_count;
END;
$$;


ALTER FUNCTION "public"."get_top_products"("limit_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_top_tags"("limit_count" integer, "search_scope" "text") RETURNS TABLE("id" "uuid", "name" "text", "usage_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    -- Simple implementation returning most used tags
    RETURN QUERY
    SELECT 
        t.id, 
        t.name::text, 
        COUNT(st.service_id)::bigint as usage_count
    FROM public.global_tags t
    LEFT JOIN public.services_tags st ON t.id = st.tag_id
    GROUP BY t.id, t.name
    ORDER BY usage_count DESC
    LIMIT limit_count;
END;
$$;


ALTER FUNCTION "public"."get_top_tags"("limit_count" integer, "search_scope" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_top_used_products"("target_company_id" "uuid", "limit_count" integer) RETURNS TABLE("product_id" "uuid", "usage_count" bigint, "name" "text", "current_stock" integer, "price" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        tp.product_id::uuid,
        COUNT(tp.product_id)::bigint AS usage_count,
        p.name::text,
        COALESCE(p.stock_quantity, 0)::integer AS current_stock,
        COALESCE(p.price, 0)::numeric
    FROM
        ticket_products tp
    JOIN
        products p ON tp.product_id = p.id
    JOIN
        tickets t ON tp.ticket_id = t.id
    WHERE
        t.company_id = target_company_id
        AND p.deleted_at IS NULL
    GROUP BY
        tp.product_id, p.name, p.stock_quantity, p.price
    ORDER BY
        usage_count DESC
    LIMIT
        limit_count;
END;
$$;


ALTER FUNCTION "public"."get_top_used_products"("target_company_id" "uuid", "limit_count" integer) OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."services" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(200) NOT NULL,
    "description" "text",
    "estimated_hours" numeric(4,2) DEFAULT 1.0,
    "base_price" numeric(10,2) DEFAULT 0.00,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone,
    "is_active" boolean DEFAULT true NOT NULL,
    "category" "text" DEFAULT 'Servicio Técnico'::"text",
    "legacy_negocio_id" "text",
    "company_id" "uuid" NOT NULL,
    "tax_rate" numeric(5,2) DEFAULT 21.00,
    "unit_type" character varying(50) DEFAULT 'horas'::character varying,
    "min_quantity" numeric(10,2) DEFAULT 1.00,
    "max_quantity" numeric(10,2),
    "difficulty_level" integer DEFAULT 1,
    "profit_margin" numeric(5,2) DEFAULT 30.00,
    "cost_price" numeric(10,2) DEFAULT 0.00,
    "requires_parts" boolean DEFAULT false,
    "requires_diagnosis" boolean DEFAULT false,
    "warranty_days" integer DEFAULT 30,
    "skill_requirements" "text"[],
    "tools_required" "text"[],
    "can_be_remote" boolean DEFAULT true,
    "priority_level" integer DEFAULT 3,
    "has_variants" boolean DEFAULT false,
    "base_features" "jsonb" DEFAULT '{}'::"jsonb",
    "is_public" boolean DEFAULT false,
    "features" "text",
    "allow_direct_contracting" boolean DEFAULT false,
    "is_bookable" boolean DEFAULT false,
    "duration_minutes" integer DEFAULT 60,
    "buffer_minutes" integer DEFAULT 0,
    "booking_color" "text",
    "room_required" boolean DEFAULT false,
    "required_resource_type" "text",
    "price_variations" "jsonb" DEFAULT '[]'::"jsonb",
    "deposit_type" "text" DEFAULT 'none'::"text",
    "deposit_amount" numeric DEFAULT 0,
    "min_notice_minutes" integer DEFAULT 60,
    "max_lead_days" integer DEFAULT 90,
    "max_capacity" integer DEFAULT 1,
    "requires_confirmation" boolean DEFAULT false,
    "form_schema" "jsonb" DEFAULT '[]'::"jsonb",
    CONSTRAINT "services_deposit_type_check" CHECK (("deposit_type" = ANY (ARRAY['none'::"text", 'fixed'::"text", 'percent'::"text", 'full'::"text"]))),
    CONSTRAINT "services_difficulty_level_check" CHECK ((("difficulty_level" >= 1) AND ("difficulty_level" <= 5))),
    CONSTRAINT "services_priority_level_check" CHECK ((("priority_level" >= 1) AND ("priority_level" <= 5))),
    CONSTRAINT "services_unit_type_not_empty" CHECK ((TRIM(BOTH FROM "unit_type") <> ''::"text"))
);


ALTER TABLE "public"."services" OWNER TO "postgres";


COMMENT ON COLUMN "public"."services"."has_variants" IS 'Indica si el servicio tiene variantes. Si es false, se usa el precio base directamente.';



COMMENT ON COLUMN "public"."services"."base_features" IS 'Características comunes a todas las variantes del servicio';



CREATE OR REPLACE FUNCTION "public"."get_top_used_services"("target_company_id" "uuid", "limit_count" integer) RETURNS SETOF "public"."services"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT s.*
  FROM services s
  LEFT JOIN (
     SELECT service_id, COUNT(*) as usage_count
     FROM ticket_services
     GROUP BY service_id
  ) usage ON s.id = usage.service_id
  WHERE s.company_id = target_company_id
    AND s.is_active = true
    AND s.deleted_at IS NULL
  ORDER BY usage.usage_count DESC NULLS LAST, s.name ASC
  LIMIT limit_count;
END;
$$;


ALTER FUNCTION "public"."get_top_used_services"("target_company_id" "uuid", "limit_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_company_id"() RETURNS "uuid"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  jwt jsonb;
  cid text;
  auth_id uuid;
  client_company_id uuid;
BEGIN
  jwt := COALESCE(current_setting('request.jwt.claims', true)::jsonb, '{}'::jsonb);
  cid := NULLIF((jwt ->> 'company_id'), '');
  
  -- If company_id is in JWT claims, use it
  IF cid IS NOT NULL THEN
    RETURN cid::uuid;
  END IF;
  
  -- Fallback: check if user is a client and get their company_id
  auth_id := auth.uid();
  IF auth_id IS NOT NULL THEN
    -- First try clients table
    SELECT company_id INTO client_company_id
    FROM public.clients
    WHERE auth_user_id = auth_id
    LIMIT 1;
    
    IF client_company_id IS NOT NULL THEN
      RETURN client_company_id;
    END IF;
    
    -- Then try users table
    SELECT company_id INTO client_company_id
    FROM public.users
    WHERE auth_user_id = auth_id
    LIMIT 1;
    
    IF client_company_id IS NOT NULL THEN
      RETURN client_company_id;
    END IF;
  END IF;
  
  -- If no company_id found anywhere, return NULL instead of raising exception
  -- This allows clients to still access their own records via auth_user_id policies
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."get_user_company_id"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_user_company_id"() IS 'Extrae company_id del JWT custom claim (Auth Hook)';



CREATE OR REPLACE FUNCTION "public"."get_user_permissions"("user_email" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    user_perms JSONB;
BEGIN
    SELECT permissions INTO user_perms
    FROM users 
    WHERE email = user_email AND active = true;
    
    RETURN COALESCE(user_perms, '{}');
END;
$$;


ALTER FUNCTION "public"."get_user_permissions"("user_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_permissions"("p_user_id" "uuid", "p_company_id" "uuid") RETURNS TABLE("permission" "text", "granted" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_role_id uuid;
BEGIN
    -- Get user's role_id in the company (company_members)
    SELECT role_id INTO v_role_id 
    FROM public.company_members 
    WHERE user_id = p_user_id AND company_id = p_company_id AND status = 'active'
    LIMIT 1;
    
    -- Fallback: check users table (primary company role)
    IF v_role_id IS NULL THEN
        SELECT app_role_id INTO v_role_id 
        FROM public.users 
        WHERE id = p_user_id 
        AND (company_id = p_company_id OR company_id IS NULL);
    END IF;

    -- Return permissions for that role_id
    RETURN QUERY
    SELECT rp.permission, rp.granted
    FROM public.role_permissions rp
    WHERE rp.company_id = p_company_id 
    AND rp.role_id = v_role_id;
END;
$$;


ALTER FUNCTION "public"."get_user_permissions"("p_user_id" "uuid", "p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_role"() RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    RETURN (
        SELECT role FROM user_profiles 
        WHERE id = auth.uid()
    );
END;
$$;


ALTER FUNCTION "public"."get_user_role"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_verifactu_cert_status"("p_company_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_settings RECORD;
    v_history JSONB;
    v_result JSONB;
BEGIN
    -- Check permissions (must be member of company)
    IF NOT EXISTS (
        SELECT 1 FROM public.company_members cm 
        WHERE cm.company_id = p_company_id 
        AND cm.user_id = (SELECT id FROM public.users WHERE auth_user_id = auth.uid())
    ) THEN
        RETURN jsonb_build_object('ok', false, 'error', 'Permission denied');
    END IF;

    -- Get Settings
    SELECT 
        software_code, 
        issuer_nif, 
        environment, 
        (cert_pem_enc IS NOT NULL AND key_pem_enc IS NOT NULL) as configured,
        CASE WHEN cert_pem_enc IS NOT NULL THEN 'encrypted'::text ELSE 'none'::text END as mode
    INTO v_settings
    FROM public.verifactu_settings
    WHERE company_id = p_company_id;

    IF NOT FOUND THEN
         -- Return valid structure but empty/unconfigured
         RETURN jsonb_build_object(
            'ok', true,
            'settings', jsonb_build_object(
                'configured', false,
                'mode', 'none',
                'software_code', null,
                'issuer_nif', null,
                'environment', null
            ),
            'history', '[]'::jsonb
         );
    END IF;

    -- Get History (recent 5)
    SELECT jsonb_agg(h)
    INTO v_history
    FROM (
        SELECT 
            version, 
            stored_at, 
            rotated_by, 
            integrity_hash, 
            notes, 
            cert_len, 
            key_len, 
            (key_pass_enc IS NOT NULL) as pass_present
        FROM public.verifactu_cert_history
        WHERE company_id = p_company_id
        ORDER BY stored_at DESC
        LIMIT 5
    ) h;

    RETURN jsonb_build_object(
        'ok', true,
        'settings', jsonb_build_object(
            'configured', v_settings.configured,
            'mode', v_settings.mode,
            'software_code', v_settings.software_code,
            'issuer_nif', v_settings.issuer_nif,
            'environment', v_settings.environment
        ),
        'history', COALESCE(v_history, '[]'::jsonb)
    );
END;
$$;


ALTER FUNCTION "public"."get_verifactu_cert_status"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_verifactu_settings_for_company"("p_company_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_result JSONB;
BEGIN
    -- Validar: Owner o Admin de la empresa
    IF NOT EXISTS (
        SELECT 1 FROM public.company_members cm
        JOIN public.users u ON cm.user_id = u.id
        JOIN public.app_roles ar ON cm.role_id = ar.id
        WHERE u.auth_user_id = auth.uid()
          AND cm.company_id = p_company_id
          AND ar.name IN ('owner', 'admin')
          AND cm.status = 'active'
    ) THEN
        RETURN jsonb_build_object('ok', false, 'error', 'access_denied');
    END IF;
    
    SELECT jsonb_build_object(
        'ok', true,
        'software_code', vs.software_code,
        'software_name', vs.software_name,
        'software_version', vs.software_version,
        'issuer_nif', vs.issuer_nif,
        'environment', vs.environment,
        'is_active', vs.is_active,
        'cert_subject', vs.cert_subject,
        'cert_valid_from', vs.cert_valid_from,
        'cert_valid_to', vs.cert_valid_to,
        'has_certificate', (vs.cert_pem_enc IS NOT NULL)
    ) INTO v_result
    FROM public.verifactu_settings vs
    WHERE vs.company_id = p_company_id;
    
    IF v_result IS NULL THEN
        RETURN jsonb_build_object('ok', true, 'exists', false, 'message', 'No configuration found');
    END IF;
    
    RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."get_verifactu_settings_for_company"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_auth_audit"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    headers JSON;
    client_ip TEXT;
BEGIN
    -- Get IP from headers (Cloudflare/Supabase Proxy)
    BEGIN
        headers := current_setting('request.headers', true)::json;
        client_ip := COALESCE(
            headers->>'cf-connecting-ip',
            headers->>'x-forwarded-for',
            inet_client_addr()::text
        );
    EXCEPTION WHEN OTHERS THEN
        client_ip := inet_client_addr()::text;
    END;

    -- Track changes to last_sign_in_at (Login event)
    IF (OLD.last_sign_in_at IS DISTINCT FROM NEW.last_sign_in_at) THEN
        INSERT INTO public.audit_logs (
            company_id,
            actor_id,
            actor_email,
            action,
            entity_type,
            entity_id,
            ip_address,
            user_agent
        )
        VALUES (
            NULL, -- Auth events are global/no company context
            NEW.id,
            NEW.email,
            'auth.login',
            'auth',
            NEW.id,
            client_ip, -- Use resolved IP
            headers->>'user-agent'
        );
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_auth_audit"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_comment_notifications"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_ticket RECORD;
BEGIN
    SELECT * INTO v_ticket FROM public.tickets WHERE id = NEW.ticket_id;
    
    IF NEW.is_internal THEN
        IF v_ticket.assigned_to IS NOT NULL AND v_ticket.assigned_to != NEW.user_id THEN
            PERFORM public.create_notification(v_ticket.company_id, v_ticket.assigned_to, 'ticket_comment_internal', NEW.ticket_id, 'Nota Interna en Ticket #' || v_ticket.ticket_number, 'Nueva nota interna: ' || left(NEW.comment, 50) || '...');
        END IF;
    ELSE
        IF v_ticket.assigned_to IS NOT NULL AND v_ticket.assigned_to != NEW.user_id THEN
             PERFORM public.create_notification(v_ticket.company_id, v_ticket.assigned_to, 'ticket_comment', NEW.ticket_id, 'Nuevo Comentario en Ticket #' || v_ticket.ticket_number, 'Nuevo comentario: ' || left(NEW.comment, 50) || '...');
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_comment_notifications"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_company_registration"("p_auth_user_id" "uuid", "p_email" "text", "p_full_name" "text", "p_company_name" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    company_info RECORD;
    new_company_id UUID;
    new_user_id UUID;
    user_role TEXT := 'owner';
BEGIN
    -- Verificar si la empresa ya existe
    SELECT * INTO company_info
    FROM check_company_exists(p_company_name);
    
    IF company_info.company_exists THEN
        -- La empresa existe, el usuario debe ser 'member'
        user_role := 'member';
        new_company_id := company_info.company_id;
        
        -- Verificar si ya existe un usuario con este email en esta empresa
        IF EXISTS (
            SELECT 1 FROM public.users 
            WHERE email = p_email AND company_id = new_company_id
        ) THEN
            RETURN json_build_object(
                'success', false,
                'error', 'User already exists in this company',
                'requires_invitation_approval', true,
                'company_name', company_info.company_name,
                'owner_email', company_info.owner_email
            );
        END IF;
    ELSE
        -- La empresa no existe, crear nueva
        INSERT INTO public.companies (name, slug)
        VALUES (
            p_company_name,
            LOWER(REPLACE(p_company_name, ' ', '-')) || '-' || EXTRACT(EPOCH FROM NOW())::BIGINT
        )
        RETURNING id INTO new_company_id;
        
        user_role := 'owner';
    END IF;
    
    -- Crear el usuario
    INSERT INTO public.users (
        email,
        name,
        surname,
        role,
        active,
        company_id,
        auth_user_id,
        permissions
    )
    VALUES (
        p_email,
        split_part(p_full_name, ' ', 1),
        NULLIF(regexp_replace(p_full_name, '^[^\s]+\s*', ''), ''),
        user_role,
        true,
        new_company_id,
        p_auth_user_id,
        '{}'::jsonb
    )
    RETURNING id INTO new_user_id;
    
    RETURN json_build_object(
        'success', true,
        'user_id', new_user_id,
        'company_id', new_company_id,
        'role', user_role,
        'message', CASE 
            WHEN user_role = 'owner' THEN 'New company created successfully'
            ELSE 'User added to existing company'
        END
    );
    
EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object(
        'success', false,
        'error', SQLERRM
    );
END;
$$;


ALTER FUNCTION "public"."handle_company_registration"("p_auth_user_id" "uuid", "p_email" "text", "p_full_name" "text", "p_company_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_gdpr_consent_notification"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  client_name text;
  notification_content text;
BEGIN
  -- Get Client Name
  SELECT COALESCE(name, '') || ' ' || COALESCE(surname, '') INTO client_name
  FROM public.clients
  WHERE id = NEW.subject_id;

  IF client_name IS NULL OR TRIM(client_name) = '' THEN
    client_name := NEW.subject_email;
  END IF;

  -- Determine Message
  IF NEW.consent_given THEN
    notification_content := 'El cliente ' || client_name || ' ha aceptado el consentimiento de ' || NEW.purpose;
  ELSE
    notification_content := 'El cliente ' || client_name || ' ha revocado el consentimiento de ' || NEW.purpose;
  END IF;

  -- Insert GLOBAL Notification (No specific recipient)
  INSERT INTO public.notifications (
    company_id,
    recipient_id,
    type,
    reference_id,
    title,
    content,
    is_read,
    created_at
  ) VALUES (
    NEW.company_id,
    NULL, -- Global
    'gdpr_consent_update',
    NEW.id,
    'Actualización GDPR',
    notification_content,
    false,
    now()
  );

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_gdpr_consent_notification"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_global_audit"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    audit_action TEXT;
    audit_user_id UUID;
    audit_client_ip TEXT;
    headers JSON;
    old_record JSONB;
    new_record JSONB;
BEGIN
    -- DUPLICATION FIX: Prevent recursive logging
    IF pg_trigger_depth() > 1 THEN
        RETURN NULL;
    END IF;

    -- Get IP from headers
    BEGIN
        headers := current_setting('request.headers', true)::json;
        audit_client_ip := COALESCE(
            headers->>'cf-connecting-ip',
            headers->>'x-forwarded-for',
            inet_client_addr()::text
        );
    EXCEPTION WHEN OTHERS THEN
        audit_client_ip := inet_client_addr()::text;
    END;

    -- Determine user
    audit_user_id := auth.uid();

    -- Determine Action and payloads
    IF TG_OP = 'INSERT' THEN
        audit_action := 'INSERT';
        new_record := to_jsonb(NEW);
        old_record := NULL;
    ELSIF TG_OP = 'UPDATE' THEN
        audit_action := 'UPDATE';
        new_record := to_jsonb(NEW);
        old_record := to_jsonb(OLD);
    ELSIF TG_OP = 'DELETE' THEN
        audit_action := 'DELETE';
        new_record := NULL;
        old_record := to_jsonb(OLD);
    END IF;

    INSERT INTO public.audit_logs (
        company_id,
        actor_id,
        actor_email,
        action,
        entity_type,
        entity_id,
        ip_address,
        user_agent,
        old_data,
        new_data
    )
    VALUES (
        COALESCE(
            (to_jsonb(NEW)->>'company_id')::uuid,
            (to_jsonb(OLD)->>'company_id')::uuid
        ),
        audit_user_id,
        (SELECT email FROM auth.users WHERE id = audit_user_id),
        audit_action,
        TG_TABLE_NAME,
        COALESCE(NEW.id, OLD.id),
        audit_client_ip,
        current_setting('request.headers', true)::json->>'user-agent',
        old_record,
        new_record
    );

    RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."handle_global_audit"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_auth_user_link"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    -- Link to public.users (Staff/Members)
    UPDATE public.users
    SET auth_user_id = NEW.id
    WHERE email = NEW.email
      AND auth_user_id IS NULL;

    -- Link to public.clients (Customers)
    UPDATE public.clients
    SET auth_user_id = NEW.id
    WHERE email = NEW.email
      AND auth_user_id IS NULL;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_auth_user_link"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_client_link"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    existing_auth_id uuid;
BEGIN
    -- Check if auth user exists with this email
    SELECT id INTO existing_auth_id
    FROM auth.users
    WHERE email = NEW.email;

    IF existing_auth_id IS NOT NULL AND NEW.auth_user_id IS NULL THEN
        NEW.auth_user_id := existing_auth_id;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_client_link"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_project_comment"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_project_name TEXT;
    v_project_company_id UUID;
    v_project_client_id UUID;
    v_author_name TEXT;
    v_company_admin_ids UUID[];
BEGIN
    -- Get project details
    SELECT name, company_id, client_id INTO v_project_name, v_project_company_id, v_project_client_id
    FROM projects
    WHERE id = NEW.project_id;

    -- CASE 1: Comment by CLIENT
    IF NEW.client_id IS NOT NULL THEN
        -- Get client name
        SELECT name INTO v_author_name FROM clients WHERE id = NEW.client_id;
        
        -- Get company admins (internal users) to notify
        SELECT ARRAY_AGG(user_id) INTO v_company_admin_ids
        FROM company_members
        WHERE company_id = v_project_company_id
        AND role IN ('owner', 'admin')
        AND status = 'active';

        -- Notify admins
        IF v_company_admin_ids IS NOT NULL THEN
            INSERT INTO notifications (company_id, recipient_id, type, reference_id, title, content)
            SELECT 
                v_project_company_id,
                UNNEST(v_company_admin_ids),
                'project_comment',
                NEW.project_id,
                'Nuevo comentario de ' || v_author_name,
                'En el proyecto: ' || v_project_name
            WHERE UNNEST(v_company_admin_ids) IS NOT NULL;
        END IF;

    -- CASE 2: Comment by INTERNAL USER
    ELSIF NEW.user_id IS NOT NULL THEN
        -- Get user name
        SELECT name || ' ' || COALESCE(surname, '') INTO v_author_name FROM users WHERE id = NEW.user_id;
        
        -- Notify project client if exists
        IF v_project_client_id IS NOT NULL THEN
            INSERT INTO notifications (company_id, client_recipient_id, type, reference_id, title, content)
            VALUES (
                v_project_company_id,
                v_project_client_id,
                'project_comment',
                NEW.project_id,
                'Nuevo comentario de ' || v_author_name,
                'En el proyecto: ' || v_project_name
            );
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_project_comment"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
begin
  insert into public.users (id, auth_user_id, email, name, active)
  values (new.id, new.id, new.email, coalesce(new.raw_user_meta_data->>'full_name', 'Usuario Nuevo'), true);
  return new;
end;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_link"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    existing_auth_id uuid;
BEGIN
    -- Check if auth user exists with this email
    SELECT id INTO existing_auth_id
    FROM auth.users
    WHERE email = NEW.email;

    IF existing_auth_id IS NOT NULL AND NEW.auth_user_id IS NULL THEN
        NEW.auth_user_id := existing_auth_id;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user_link"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_registration"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'auth'
    AS $$
DECLARE
    v_company_name text;
    v_company_id uuid;
    v_user_id uuid;
    v_full_name text;
    v_given_name text;
    v_surname text;
    v_role_id uuid;
BEGIN
    -- Extraer metadata del registro (inyectada por el frontend en el signUp)
    v_company_name := NEW.raw_user_meta_data->>'company_name';
    v_full_name := NEW.raw_user_meta_data->>'full_name';
    v_given_name := NEW.raw_user_meta_data->>'given_name';
    v_surname := NEW.raw_user_meta_data->>'surname';

    -- Si no hay nombre de empresa, es un registro simple o invitación,
    -- el trigger 'on_auth_user_created_link' (existente) se encargará de vincularlo.
    IF v_company_name IS NULL OR v_company_name = '' THEN
        RETURN NEW;
    END IF;

    -- 2. Crear la Empresa
    -- Usamos un nombre de slug único basado en el tiempo para evitar colisiones
    INSERT INTO public.companies (name, slug, is_active)
    VALUES (
        v_company_name, 
        lower(regexp_replace(v_company_name, '[^a-zA-Z0-9]+', '-', 'g')) || '-' || extract(epoch from now())::text,
        true
    )
    RETURNING id INTO v_company_id;

    -- 3. Crear el Perfil de Usuario en public.users
    INSERT INTO public.users (
        auth_user_id,
        email,
        name,
        surname,
        active,
        company_id
    ) VALUES (
        NEW.id,
        NEW.email,
        COALESCE(v_given_name, split_part(v_full_name, ' ', 1), split_part(NEW.email, '@', 1)),
        COALESCE(v_surname, substring(v_full_name from position(' ' in v_full_name) + 1)),
        true,
        v_company_id
    )
    RETURNING id INTO v_user_id;

    -- 4. Asignar Rol de Owner en la empresa
    -- Buscamos el ID del rol 'owner' en app_roles
    SELECT id INTO v_role_id FROM public.app_roles WHERE name = 'owner' LIMIT 1;

    INSERT INTO public.company_members (
        user_id,
        company_id,
        role_id,
        role,
        status
    ) VALUES (
        v_user_id,
        v_company_id,
        v_role_id,
        'owner',
        'active'
    );

    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    -- En triggers de Auth, es vital no bloquear el login si algo falla en la lógica secundaria.
    -- Logeamos el error (aparecerá en los logs de Supabase) pero permitimos que el usuario se cree.
    RAISE WARNING 'Error en handle_new_user_registration: %', SQLERRM;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user_registration"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_project_auto_move"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_project_id UUID;
    v_company_id UUID;
    v_current_stage_id UUID;
    v_is_review_stage BOOLEAN;
    v_is_final_stage BOOLEAN;
    v_review_stage_id UUID;
    v_default_stage_id UUID;
    v_incomplete_tasks_count INTEGER;
BEGIN
    -- Determine project_id based on operation
    IF (TG_OP = 'DELETE') THEN
        v_project_id := OLD.project_id;
    ELSE
        v_project_id := NEW.project_id;
    END IF;

    -- Get project and company info
    SELECT company_id, stage_id INTO v_company_id, v_current_stage_id
    FROM public.projects
    WHERE id = v_project_id;

    -- If project not found (e.g. deleted), exit
    IF v_company_id IS NULL THEN
        RETURN NULL;
    END IF;

    -- Check if current stage is the review or final stage
    SELECT is_review, is_final INTO v_is_review_stage, v_is_final_stage
    FROM public.project_stages
    WHERE id = v_current_stage_id;

    -- Count incomplete tasks
    SELECT COUNT(*) INTO v_incomplete_tasks_count
    FROM public.project_tasks
    WHERE project_id = v_project_id AND is_completed = false;

    -- Get special stages for this company
    SELECT id INTO v_review_stage_id FROM public.project_stages WHERE company_id = v_company_id AND is_review = true LIMIT 1;
    SELECT id INTO v_default_stage_id FROM public.project_stages WHERE company_id = v_company_id AND is_default = true LIMIT 1;

    -- Logic 1: All tasks completed -> Move to Review Stage
    -- Only if NOT already in Review OR Final stage (if in Final, we stay there unless manually changed)
    IF v_incomplete_tasks_count = 0 THEN
        IF v_review_stage_id IS NOT NULL 
           AND (v_current_stage_id IS DISTINCT FROM v_review_stage_id) 
           AND (v_is_final_stage IS NOT TRUE) THEN
            
            UPDATE public.projects 
            SET stage_id = v_review_stage_id, updated_at = NOW()
            WHERE id = v_project_id;
        END IF;
    END IF;

    -- Logic 2: Not all tasks completed (reopened or new added) -> Move back to Default Stage
    -- If currently in Review OR Final Stage
    IF v_incomplete_tasks_count > 0 THEN
        IF (v_is_review_stage = true OR v_is_final_stage = true) AND v_default_stage_id IS NOT NULL THEN
             UPDATE public.projects 
            SET stage_id = v_default_stage_id, updated_at = NOW()
            WHERE id = v_project_id;
        END IF;
    END IF;

    RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."handle_project_auto_move"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_ticket_assignment_notification"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_actor_id UUID := auth.uid();
BEGIN
    -- Only if assigned_to changed and is not null
    IF NEW.assigned_to IS DISTINCT FROM OLD.assigned_to AND NEW.assigned_to IS NOT NULL THEN
        -- Don't notify if I assigned it to myself
        IF NEW.assigned_to != v_actor_id THEN
            PERFORM public.create_notification(
                NEW.company_id,
                NEW.assigned_to, -- Recipient is the new assignee (auth_user_id)
                'ticket_assignment',
                'Ticket Asignado',
                'Se te ha asignado el ticket #' || NEW.ticket_number || ': ' || NEW.title,
                NEW.id,
                jsonb_build_object('ticket_number', NEW.ticket_number)
            );
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_ticket_assignment_notification"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_ticket_audit_log"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_actor_id UUID := auth.uid();
    v_event_type TEXT;
    v_metadata JSONB;
BEGIN
    -- Only run on UPDATE
    IF TG_OP = 'UPDATE' THEN
        
        -- Check Stage Change
        IF OLD.stage_id IS DISTINCT FROM NEW.stage_id THEN
            INSERT INTO public.ticket_timeline (ticket_id, company_id, actor_id, event_type, metadata, is_public)
            VALUES (
                NEW.id, 
                NEW.company_id, 
                v_actor_id, 
                'stage_change', 
                jsonb_build_object('from', OLD.stage_id, 'to', NEW.stage_id), 
                true -- Stage changes are usually public? Let's say yes for now, or make configurable.
            );
        END IF;

        -- Check Priority Change
        IF OLD.priority IS DISTINCT FROM NEW.priority THEN
            INSERT INTO public.ticket_timeline (ticket_id, company_id, actor_id, event_type, metadata, is_public)
            VALUES (
                NEW.id, 
                NEW.company_id, 
                v_actor_id, 
                'priority_change', 
                jsonb_build_object('from', OLD.priority, 'to', NEW.priority), 
                false -- Priority is usually internal
            );
        END IF;

        -- Check Assignment Change
        IF OLD.assigned_to IS DISTINCT FROM NEW.assigned_to THEN
            INSERT INTO public.ticket_timeline (ticket_id, company_id, actor_id, event_type, metadata, is_public)
            VALUES (
                NEW.id, 
                NEW.company_id, 
                v_actor_id, 
                'assignment_change', 
                jsonb_build_object('from', OLD.assigned_to, 'to', NEW.assigned_to), 
                false -- Internal
            );
        END IF;

        -- SLA Calculation: Resolution Time
        IF NEW.closed_at IS NOT NULL AND OLD.closed_at IS NULL THEN
            -- Ticket just closed
            NEW.resolution_time_mins := EXTRACT(EPOCH FROM (NEW.closed_at - NEW.created_at)) / 60;
        END IF;

    ELSIF TG_OP = 'INSERT' THEN
        -- Creation Event
        INSERT INTO public.ticket_timeline (ticket_id, company_id, actor_id, event_type, metadata, is_public)
        VALUES (
            NEW.id, 
            NEW.company_id, 
            v_actor_id, 
            'creation', 
            '{}'::jsonb, 
            true
        );
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_ticket_audit_log"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_ticket_auto_assignment"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_eligible_count int;
    v_assignee_id uuid;
BEGIN
    -- Only run if assigned_to is NULL
    IF NEW.assigned_to IS NULL THEN
        -- Find eligible users (owner, admin, member, agent, professional?)
        -- Using app_roles instead of legacy role column
        
        -- Fix: Cast ID to text for MIN() function
        SELECT count(*), min(u.id::text)::uuid INTO v_eligible_count, v_assignee_id
        FROM public.users u
        JOIN public.app_roles ar ON u.app_role_id = ar.id
        WHERE u.company_id = NEW.company_id
        AND ar.name IN ('owner', 'admin', 'member', 'professional', 'agent') 
        AND u.active = true;

        IF v_eligible_count = 1 THEN
            NEW.assigned_to := v_assignee_id;
        END IF; 
        
        -- If more than 1, leave unassigned
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_ticket_auto_assignment"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_ticket_comment_automation"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_stage_id uuid;
  v_stage_pos int;
  v_stage_workflow text;
  v_target_stage_id uuid;
  v_user_comment_count int;
  v_config_staff_reply_stage uuid;
  v_config_client_reply_stage uuid;
BEGIN
  -- A) CLIENT REPLY
  IF NEW.client_id IS NOT NULL THEN
      -- Check setting for client reply
      SELECT ticket_stage_on_client_reply INTO v_config_client_reply_stage
      FROM public.company_settings
      WHERE company_id = (SELECT company_id FROM tickets WHERE id = NEW.ticket_id);
      
      IF v_config_client_reply_stage IS NOT NULL THEN
         UPDATE tickets SET stage_id = v_config_client_reply_stage, updated_at = NOW() WHERE id = NEW.ticket_id;
      END IF;
      -- If Not configured, do nothing (default behavior for now, or could act 'waiting')
      RETURN NEW; 
  END IF;

  -- B) STAFF REPLY
  IF NEW.user_id IS NOT NULL THEN
    SELECT count(*) INTO v_user_comment_count 
    FROM ticket_comments 
    WHERE ticket_id = NEW.ticket_id AND user_id IS NOT NULL;
    
    -- Only automate on FIRST staff comment? 
    -- User might want EVERY staff comment to move to 'On Progress'?
    -- Let's keep "First Comment" logic for the DEFAULT behavior.
    -- BUT if `ticket_stage_on_staff_reply` is set, should we do it ALWAYS or just FIRST?
    -- Usually "First Response" is the key transition. 
    -- If we do it always, we might overwrite manual changes.
    -- Let's stick to "First Comment" constraint even for Configured Stage, UNLESS user explicitly asked "When I reply, move to X".
    -- Safer: Stick to First Comment constraint for now to avoid annoyance.
    
    IF v_user_comment_count = 1 THEN
       
       -- 1. Check Settings
       SELECT ticket_stage_on_staff_reply INTO v_config_staff_reply_stage
       FROM public.company_settings
       WHERE company_id = (SELECT company_id FROM tickets WHERE id = NEW.ticket_id);

       IF v_config_staff_reply_stage IS NOT NULL THEN
          v_target_stage_id := v_config_staff_reply_stage;
       ELSE
           -- 2. Default Logic: Find 'En Análisis'
           SELECT id INTO v_target_stage_id
           FROM ticket_stages
           WHERE 
             (company_id = (SELECT company_id FROM tickets WHERE id = NEW.ticket_id) OR company_id IS NULL)
             AND deleted_at IS NULL
             AND (name ILIKE '%Análisis%' OR workflow_category = 'analysis')
             AND NOT EXISTS (
                SELECT 1 FROM hidden_stages hs 
                WHERE hs.stage_id = ticket_stages.id 
                AND hs.company_id = (SELECT company_id FROM tickets WHERE id = NEW.ticket_id)
             )
           ORDER BY (company_id IS NOT NULL) DESC, (workflow_category = 'analysis') DESC, position ASC
           LIMIT 1;
       END IF;

       -- Validations (Current != Target)
       SELECT id, position, workflow_category INTO v_stage_id, v_stage_pos, v_stage_workflow
       FROM ticket_stages
       WHERE id = (SELECT stage_id FROM tickets WHERE id = NEW.ticket_id);
       
       IF v_target_stage_id IS NOT NULL AND v_target_stage_id != v_stage_id THEN
          DECLARE
            v_target_pos int;
          BEGIN
            SELECT position INTO v_target_pos FROM ticket_stages WHERE id = v_target_stage_id;
            
            -- ALLOW MOVE IF: Current is 'waiting'/'open' OR strictly lower OR (Configured Setting override safety checks? No, keeps strictness unless configured?)
            -- If user configured it, we should probably allows it comfortably.
            -- Let's keep the check: Only advance forward or from open/waiting.
            -- If Configured, we assume user wants it. Maybe skip check?
            -- Let's skip check IF v_config_staff_reply_stage IS NOT NULL.
            
            IF v_config_staff_reply_stage IS NOT NULL OR (v_stage_workflow IN ('waiting', 'open')) OR (v_stage_pos < v_target_pos) THEN
               UPDATE tickets SET stage_id = v_target_stage_id, updated_at = NOW() WHERE id = NEW.ticket_id;
            END IF;
          END;
       END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_ticket_comment_automation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_ticket_comment_notification"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_is_client BOOLEAN;
    v_assignee UUID;
    v_ticket_number TEXT;
    v_ticket_title TEXT;
BEGIN
    -- Check if author is a client
    SELECT EXISTS (SELECT 1 FROM public.clients WHERE auth_user_id = NEW.user_id) INTO v_is_client;

    IF v_is_client THEN
        -- Get Ticket details
        SELECT assigned_to, ticket_number, title INTO v_assignee, v_ticket_number, v_ticket_title
        FROM public.tickets 
        WHERE id = NEW.ticket_id;

        IF v_assignee IS NOT NULL THEN
             PERFORM public.create_notification(
                NEW.company_id,
                v_assignee,
                'ticket_comment',
                'Nuevo Comentario de Cliente',
                'Cliente comentó en ticket #' || v_ticket_number,
                NEW.ticket_id,
                jsonb_build_object('comment_id', NEW.id)
            );
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_ticket_comment_notification"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_ticket_critical_notification"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    -- If priority changed to critical
    IF NEW.priority = 'critical' AND (OLD.priority != 'critical' OR OLD.priority IS NULL) THEN
        
        -- Send GLOBAL notification (recipient_id = NULL)
        PERFORM public.create_notification(
            NEW.company_id,
            NULL, -- GLOBAL
            'ticket_critical',
            'Ticket CRÍTICO',
            'El ticket #' || NEW.ticket_number || ' (' || NEW.title || ') es ahora CRÍTICO.',
            NEW.id,
            jsonb_build_object('priority', 'critical')
        );

    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_ticket_critical_notification"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_ticket_first_response"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_is_staff BOOLEAN;
BEGIN
    -- Check if ticket already has a first_response_at
    -- If not, we check if the commenter is Staff
    IF (SELECT first_response_at FROM public.tickets WHERE id = NEW.ticket_id) IS NULL THEN
        
        -- Check if user is Staff (exists in public.users)
        -- We assume 'is_internal' column on ticket_comments might exist, but safer to check user table
        SELECT EXISTS (
            SELECT 1 FROM public.users 
            WHERE auth_user_id = NEW.user_id 
              AND active = true
        ) INTO v_is_staff;

        IF v_is_staff THEN
            UPDATE public.tickets
            SET first_response_at = NEW.created_at
            WHERE id = NEW.ticket_id;
        END IF;

    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_ticket_first_response"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_ticket_notifications"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_admins CURSOR FOR 
        -- Get users who are admins/owners in this company
        -- Check company_members FIRST
        SELECT cm.user_id 
        FROM public.company_members cm
        JOIN public.app_roles ar ON cm.role_id = ar.id
        WHERE cm.company_id = NEW.company_id
        AND ar.name IN ('owner', 'admin')
        AND cm.status = 'active'
        
        UNION
        
        -- UNION with users table (primary company)
        -- (Ideally we avoid duplicates but UNION handles that)
        SELECT u.id as user_id
        FROM public.users u
        JOIN public.app_roles ar ON u.app_role_id = ar.id
        WHERE u.company_id = NEW.company_id
        AND ar.name IN ('owner', 'admin')
        AND u.active = true;
BEGIN
    IF TG_OP = 'INSERT' THEN
        FOR admin_Rec IN v_admins LOOP
            -- Avoid self-notification if creator is admin? (Optional, skipping optimization for simplicity)
            PERFORM public.create_notification(NEW.company_id, admin_Rec.user_id, 'ticket_created', NEW.id, 'Nuevo Ticket #' || NEW.ticket_number, 'Se ha creado un nuevo ticket: ' || NEW.title);
        END LOOP;
        
        IF NEW.assigned_to IS NOT NULL THEN
             PERFORM public.create_notification(NEW.company_id, NEW.assigned_to, 'ticket_assigned', NEW.id, 'Ticket Asignado #' || NEW.ticket_number, 'Te han asignado el ticket: ' || NEW.title);
        END IF;

    ELSIF TG_OP = 'UPDATE' THEN
        IF (OLD.assigned_to IS DISTINCT FROM NEW.assigned_to) AND (NEW.assigned_to IS NOT NULL) THEN
            PERFORM public.create_notification(NEW.company_id, NEW.assigned_to, 'ticket_assigned', NEW.id, 'Ticket Asignado #' || NEW.ticket_number, 'Te han asignado el ticket: ' || NEW.title);
        END IF;

        IF (OLD.stage_id IS DISTINCT FROM NEW.stage_id) THEN
            IF NEW.assigned_to IS NOT NULL THEN
                PERFORM public.create_notification(NEW.company_id, NEW.assigned_to, 'ticket_status_change', NEW.id, 'Cambio de Estado Ticket #' || NEW.ticket_number, 'El estado del ticket ha cambiado.');
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_ticket_notifications"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_ticket_soft_delete"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_cancel_stage_id uuid;
    v_config_stage_id uuid;
BEGIN
    -- Check if ticket is being soft-deleted
    IF (OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL) THEN
        
        -- 1. Check Company Settings FIRST
        SELECT ticket_stage_on_delete INTO v_config_stage_id
        FROM public.company_settings
        WHERE company_id = NEW.company_id;

        IF v_config_stage_id IS NOT NULL THEN
             -- Use configured stage
             v_cancel_stage_id := v_config_stage_id;
        ELSE
             -- 2. Fallback: Find 'cancel' stage (CHECK BOTH COMPANY AND GLOBAL)
            SELECT id INTO v_cancel_stage_id
            FROM public.ticket_stages
            WHERE (company_id = NEW.company_id OR company_id IS NULL)
              AND workflow_category = 'cancel'
            -- Prefer company specific, then global
            ORDER BY (company_id IS NOT NULL) DESC
            LIMIT 1;
        END IF;

        IF v_cancel_stage_id IS NOT NULL THEN
            NEW.stage_id := v_cancel_stage_id;
            NEW.is_opened := false; -- Explicitly close it
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_ticket_soft_delete"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_ticket_state_transition"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    new_stage_category stage_category;
BEGIN
    -- Only run if stage_id changed
    IF (OLD.stage_id IS DISTINCT FROM NEW.stage_id) THEN
        
        -- Get category of the new stage
        -- We handle NULL stage_id gracefully just in case
        IF NEW.stage_id IS NOT NULL THEN
            SELECT stage_category INTO new_stage_category
            FROM public.ticket_stages
            WHERE id = NEW.stage_id;
            
            -- Logic: If moved to 'completed' category -> Close Ticket
            IF (new_stage_category = 'completed') THEN
                NEW.is_opened := false;
                -- Only set closed_at if it wasn't already set (preserve original close time if moving between completed states?)
                -- Actually, moving to a new completed state (e.g. Resuelto -> Cancelado) usually implies a new "end" event.
                -- Let's update it to current time.
                NEW.closed_at := NOW();
            ELSE
                -- If reopened (moved to open/in_progress/on_hold), Open Ticket
                NEW.is_opened := true;
                NEW.closed_at := NULL;
            END IF;
        END IF;

    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_ticket_state_transition"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_verifactu_voiding"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- If an anulacion event is accepted, mark the invoice as void
  IF NEW.event_type = 'anulacion' AND NEW.status = 'accepted' THEN
    UPDATE public.invoices
       SET status = 'void',
           state = 'void'
     WHERE id = NEW.invoice_id
       AND (status != 'void' OR state != 'void');
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_verifactu_voiding"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."has_company_permission"("p_company_id" "uuid", "p_roles" "text"[]) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_user_id uuid;
BEGIN
  -- Get the internal user ID from public.users using the auth ID
  SELECT id INTO v_user_id
  FROM public.users
  WHERE auth_user_id = auth.uid();

  -- If no user found, deny access
  IF v_user_id IS NULL THEN
    RETURN false;
  END IF;

  -- Check permission using the internal user ID
  RETURN EXISTS (
    SELECT 1
    FROM public.company_members
    WHERE company_id = p_company_id
    AND user_id = v_user_id
    AND role = ANY(p_roles)
    AND status = 'active'
  );
END;
$$;


ALTER FUNCTION "public"."has_company_permission"("p_company_id" "uuid", "p_roles" "text"[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."initialize_mail_account_folders"("p_account_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    -- Inbox
    INSERT INTO public.mail_folders (account_id, name, path, type, system_role)
    VALUES (p_account_id, 'Inbox', 'Inbox', 'system', 'inbox')
    ON CONFLICT DO NOTHING;
    
    -- Sent
    INSERT INTO public.mail_folders (account_id, name, path, type, system_role)
    VALUES (p_account_id, 'Sent', 'Sent', 'system', 'sent')
    ON CONFLICT DO NOTHING;
    
    -- Drafts
    INSERT INTO public.mail_folders (account_id, name, path, type, system_role)
    VALUES (p_account_id, 'Drafts', 'Drafts', 'system', 'drafts')
    ON CONFLICT DO NOTHING;
    
    -- Trash
    INSERT INTO public.mail_folders (account_id, name, path, type, system_role)
    VALUES (p_account_id, 'Trash', 'Trash', 'system', 'trash')
    ON CONFLICT DO NOTHING;
    
    -- Spam
    INSERT INTO public.mail_folders (account_id, name, path, type, system_role)
    VALUES (p_account_id, 'Spam', 'Spam', 'system', 'spam')
    ON CONFLICT DO NOTHING;
END;
$$;


ALTER FUNCTION "public"."initialize_mail_account_folders"("p_account_id" "uuid") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."addresses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "direccion" character varying(255) NOT NULL,
    "numero" character varying(10),
    "piso" character varying(10),
    "puerta" character varying(10),
    "locality_id" "uuid",
    "usuario_id" "uuid" NOT NULL,
    "company_id" "uuid"
);


ALTER TABLE "public"."addresses" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."insert_or_get_address"("p_direccion" "text", "p_locality_id" "uuid", "p_numero" "text", "p_usuario_id" "uuid") RETURNS SETOF "public"."addresses"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_address public.addresses;
BEGIN
    -- Check if exists
    SELECT * INTO v_address
    FROM public.addresses
    WHERE direccion = p_direccion
      AND locality_id = p_locality_id
      AND usuario_id = p_usuario_id;

    IF FOUND THEN
        RETURN NEXT v_address;
        RETURN;
    END IF;

    -- Insert if not exists
    INSERT INTO public.addresses (direccion, locality_id, numero, usuario_id)
    VALUES (p_direccion, p_locality_id, p_numero, p_usuario_id)
    RETURNING * INTO v_address;

    RETURN NEXT v_address;
END;
$$;


ALTER FUNCTION "public"."insert_or_get_address"("p_direccion" "text", "p_locality_id" "uuid", "p_numero" "text", "p_usuario_id" "uuid") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."localities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "name" character varying(100) NOT NULL,
    "province" character varying(100),
    "country" character varying(100) DEFAULT 'España'::character varying,
    "postal_code" character varying(10)
);


ALTER TABLE "public"."localities" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."insert_or_get_locality"("p_name" "text", "p_province" "text", "p_country" "text", "p_postal_code" "text") RETURNS "public"."localities"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  _row public.localities;
BEGIN
  -- Normalize input inside DB if desired (caller should already normalize)
  SELECT * INTO _row FROM public.localities WHERE postal_code = p_postal_code LIMIT 1;
  IF FOUND THEN
    RETURN _row;
  END IF;

  INSERT INTO public.localities (name, province, country, postal_code)
  VALUES (p_name, p_province, p_country, p_postal_code)
  RETURNING * INTO _row;

  RETURN _row;
EXCEPTION WHEN unique_violation THEN
  SELECT * INTO _row FROM public.localities WHERE postal_code = p_postal_code LIMIT 1;
  RETURN _row;
END;
$$;


ALTER FUNCTION "public"."insert_or_get_locality"("p_name" "text", "p_province" "text", "p_country" "text", "p_postal_code" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."invite_user_to_company"("user_email" "text", "user_name" "text", "user_role" "text" DEFAULT 'member'::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    current_user_company_id UUID;
    current_user_role TEXT;
    new_user_id UUID;
    result JSON;
BEGIN
    -- Obtener empresa y rol del usuario actual (método directo)
    SELECT u.company_id, u.role
    INTO current_user_company_id, current_user_role
    FROM public.users u
    WHERE u.auth_user_id = auth.uid()
    AND u.active = true
    LIMIT 1;
    
    -- Verificar que el usuario actual existe
    IF current_user_company_id IS NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Usuario no encontrado o inactivo'
        );
    END IF;
    
    -- Solo owners y admins pueden invitar
    IF current_user_role NOT IN ('owner', 'admin') THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Solo owners y administradores pueden invitar usuarios'
        );
    END IF;
    
    -- Verificar si el usuario ya existe
    IF EXISTS (
        SELECT 1 FROM public.users 
        WHERE email = user_email 
        AND company_id = current_user_company_id 
        AND deleted_at IS NULL
    ) THEN
        RETURN json_build_object(
            'success', false,
            'error', 'El usuario ya existe en esta empresa'
        );
    END IF;
    
    -- Validar role
    IF user_role NOT IN ('owner', 'admin', 'member') THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Rol no válido. Debe ser: owner, admin o member'
        );
    END IF;
    
    -- Crear el usuario
    INSERT INTO public.users (
        company_id, 
        email, 
        name, 
        role, 
        active,
        permissions
    ) VALUES (
        current_user_company_id,
        user_email,
        user_name,
        user_role,
        true,
        '{"moduloFacturas": false, "moduloMaterial": false, "moduloServicios": false, "moduloPresupuestos": false}'::jsonb
    ) RETURNING id INTO new_user_id;
    
    RETURN json_build_object(
        'success', true,
        'user_id', new_user_id,
        'company_id', current_user_company_id,
        'message', 'Usuario invitado correctamente'
    );
    
EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object(
        'success', false,
        'error', 'Error: ' || SQLERRM
    );
END;
$$;


ALTER FUNCTION "public"."invite_user_to_company"("user_email" "text", "user_name" "text", "user_role" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."invite_user_to_company"("p_email" "text", "p_company_id" "uuid", "p_role" "text", "p_message" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  inviter_user_id uuid;
  inviter_role text; -- This will come from app_roles.name
  invitation_id uuid;
  company_name text;
BEGIN
  -- 1. Get Inviter ID and verify role via company_members + app_roles
  SELECT u.id, ar.name, c.name 
  INTO inviter_user_id, inviter_role, company_name
  FROM public.users u
  JOIN public.company_members cm ON cm.user_id = u.id
  JOIN public.app_roles ar ON cm.role_id = ar.id
  JOIN public.companies c ON c.id = cm.company_id
  WHERE u.auth_user_id = auth.uid()
    AND cm.company_id = p_company_id
    AND cm.status = 'active'
    AND ar.name IN ('owner', 'admin');

  -- 2. Validate permissions
  IF inviter_user_id IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Unauthorized: You must be an Owner or Admin of this company to invite users.');
  END IF;

  -- 3. Check if user already exists in the company
  IF EXISTS(
      SELECT 1 FROM public.users u
      JOIN public.company_members cm ON cm.user_id = u.id
      WHERE u.email = p_email 
      AND cm.company_id = p_company_id 
      AND cm.status = 'active'
  ) THEN
    RETURN json_build_object('success', false, 'error', 'User already exists in this company');
  END IF;

  -- 4. Expire old pending invitations
  UPDATE public.company_invitations
  SET status = 'expired'
  WHERE email = p_email AND company_id = p_company_id AND status = 'pending';

  -- 5. Create new invitation
  INSERT INTO public.company_invitations (company_id, email, invited_by_user_id, role, message)
  VALUES (p_company_id, p_email, inviter_user_id, p_role, p_message)
  RETURNING id INTO invitation_id;

  RETURN json_build_object(
    'success', true, 
    'invitation_id', invitation_id, 
    'company_name', company_name, 
    'message', 'Invitation sent successfully'
  );

EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."invite_user_to_company"("p_email" "text", "p_company_id" "uuid", "p_role" "text", "p_message" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."invite_user_to_company"("p_company_id" "uuid", "p_email" "text", "p_role" "text" DEFAULT 'member'::"text", "p_message" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  inviter_user_id UUID;
  inviter_role TEXT;
  invitation_id UUID;
  company_name TEXT;
BEGIN
  -- 1. Get Inviter ID and verify role via company_members
  SELECT u.id, cm.role, c.name 
  INTO inviter_user_id, inviter_role, company_name
  FROM public.users u
  JOIN public.company_members cm ON cm.user_id = u.id
  JOIN public.companies c ON c.id = cm.company_id
  WHERE u.auth_user_id = auth.uid()
    AND cm.company_id = p_company_id
    AND cm.status = 'active'
    AND cm.role IN ('owner', 'admin');

  -- 2. Validate permissions
  IF inviter_user_id IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Unauthorized: You must be an Owner or Admin of this company to invite users.');
  END IF;

  -- 3. Check if user already exists in the company
  IF EXISTS(
      SELECT 1 FROM public.users u
      JOIN public.company_members cm ON cm.user_id = u.id
      WHERE u.email = p_email 
      AND cm.company_id = p_company_id 
      AND cm.status = 'active'
  ) THEN
    RETURN json_build_object('success', false, 'error', 'User already exists in this company');
  END IF;

  -- 4. Expire old pending invitations for this email/company
  UPDATE public.company_invitations
  SET status = 'expired'
  WHERE email = p_email AND company_id = p_company_id AND status = 'pending';

  -- 5. Create new invitation
  INSERT INTO public.company_invitations (company_id, email, invited_by_user_id, role, message)
  VALUES (p_company_id, p_email, inviter_user_id, p_role, p_message)
  RETURNING id INTO invitation_id;

  RETURN json_build_object(
    'success', true, 
    'invitation_id', invitation_id, 
    'company_name', company_name, 
    'message', 'Invitation sent successfully'
  );

EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."invite_user_to_company"("p_company_id" "uuid", "p_email" "text", "p_role" "text", "p_message" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."invite_user_to_company_debug"("user_email" "text", "user_name" "text", "user_role" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    current_auth_uid UUID;
    current_user_company_id UUID;
    current_user_role TEXT;
    new_user_id UUID;
    debug_info JSON;
    v_role_id UUID;
BEGIN
    current_auth_uid := auth.uid();
    
    -- Authenticated User Context
    IF current_auth_uid IS NOT NULL THEN
        -- Get company and role via company_members
        SELECT cm.company_id, ar.name
        INTO current_user_company_id, current_user_role
        FROM public.users u
        JOIN public.company_members cm ON u.id = cm.user_id
        JOIN public.app_roles ar ON cm.role_id = ar.id
        WHERE u.auth_user_id = current_auth_uid
        AND cm.status = 'active'
        LIMIT 1;
    ELSE
        -- Fallback: Find first 'owner' (dangerous but this is debug func)
        SELECT cm.company_id, ar.name, u.auth_user_id
        INTO current_user_company_id, current_user_role, current_auth_uid
        FROM public.company_members cm
        JOIN public.app_roles ar ON cm.role_id = ar.id
        JOIN public.users u ON cm.user_id = u.id
        WHERE ar.name = 'owner' 
        AND u.active = true
        LIMIT 1;
    END IF;
    
    -- Assume company/role if NULL (Debug purposes validation)
    IF current_user_company_id IS NULL THEN
        SELECT id INTO current_user_company_id FROM public.companies WHERE is_active = true LIMIT 1;
        current_user_role := 'owner'; 
    END IF;
    
    debug_info := json_build_object(
        'auth_uid', current_auth_uid,
        'company_id', current_user_company_id,
        'user_role', current_user_role,
        'input_email', user_email,
        'input_name', user_name,
        'input_role', user_role
    );
    
    -- Check Exists
    IF EXISTS (SELECT 1 FROM public.users WHERE email = user_email AND deleted_at IS NULL) THEN
        RETURN json_build_object('success', false, 'error', 'El usuario ya existe en el sistema', 'debug', debug_info);
    END IF;
    
    -- Get Role ID
    SELECT id INTO v_role_id FROM public.app_roles WHERE name = user_role;
    IF v_role_id IS NULL THEN
          RETURN json_build_object('success', false, 'error', 'Role not found', 'debug', debug_info);
    END IF;

    -- Create User (without role column)
    INSERT INTO public.users (
        company_id, 
        email, 
        name, 
        active,
        permissions
    ) VALUES (
        current_user_company_id,
        user_email,
        user_name,
        true,
        '{"moduloFacturas": false, "moduloMaterial": false, "moduloServicios": false, "moduloPresupuestos": false}'::jsonb
    ) RETURNING id INTO new_user_id;
    
    -- Create Company Member
    INSERT INTO public.company_members (user_id, company_id, role_id, status)
    VALUES (new_user_id, current_user_company_id, v_role_id, 'active');

    RETURN json_build_object(
        'success', true,
        'user_id', new_user_id,
        'company_id', current_user_company_id,
        'message', 'Usuario invitado correctamente',
        'debug', debug_info
    );

EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object('success', false, 'error', 'Error: ' || SQLERRM, 'sqlstate', SQLSTATE, 'debug', debug_info);
END;
$$;


ALTER FUNCTION "public"."invite_user_to_company_debug"("user_email" "text", "user_name" "text", "user_role" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."invoices_immutability_guard"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  old_values JSONB;
  new_values JSONB;
  diff_keys TEXT[];
  base_allowed_fields TEXT[] := ARRAY[
    'payment_status',
    'notes_internal', 
    'payment_method',
    'payment_reference',
    'paid_at',
    'due_date',
    'updated_at',
    'stripe_payment_url',
    'stripe_payment_token',
    'paypal_payment_url',
    'paypal_payment_token',
    'payment_link_token',
    'payment_link_provider',
    'payment_link_expires_at',
    'retention_until',
    'full_invoice_number'
  ];
  allowed_fields TEXT[];
BEGIN
  -- Only block updates if invoice is in a final state
  -- We use 'issued', 'sent', 'paid', 'partially_paid', 'rectified', 'void', 'cancelled'
  -- We assume 'draft' is mutable.
  -- Valid enum values: draft, sent, paid, partial, overdue, cancelled, void, approved, issued, rectified
  IF OLD.status NOT IN ('issued', 'sent', 'paid', 'partial', 'overdue', 'rectified', 'void', 'cancelled') THEN
    RETURN NEW;
  END IF;

  allowed_fields := base_allowed_fields;
  
  -- Allow rectification changes
  IF NEW.status IN ('rectified', 'void') THEN
    allowed_fields := allowed_fields || ARRAY['status', 'rectification_invoice_id', 'rectification_reason', 'rectification_type', 'rectified_at'];
  END IF;
  
  old_values := to_jsonb(OLD);
  new_values := to_jsonb(NEW);
  
  FOR i IN 1..array_length(allowed_fields, 1) LOOP
    old_values := old_values - allowed_fields[i];
    new_values := new_values - allowed_fields[i];
  END LOOP;
  
  SELECT array_agg(key) INTO diff_keys
  FROM (
    SELECT key FROM jsonb_each(new_values) 
    EXCEPT 
    SELECT key FROM jsonb_each(old_values) WHERE old_values->key = new_values->key
  ) AS diffs;
  
  IF diff_keys IS NOT NULL AND array_length(diff_keys, 1) > 0 THEN
    FOR i IN 1..array_length(diff_keys, 1) LOOP
      IF new_values->diff_keys[i] IS DISTINCT FROM old_values->diff_keys[i] THEN
        RAISE EXCEPTION 'Invoice is in final state (%) and immutable. Diff: New=% Old=%', 
          OLD.status, new_values, old_values
        USING HINT = 'Allowed: ' || array_to_string(allowed_fields, ', ');
      END IF;
    END LOOP;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."invoices_immutability_guard"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."invoke_process_recurring_quotes"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_url text;
  v_service_key text;
BEGIN
  -- Obtener la URL base de Supabase
  -- Nota: En producción, estas deberían estar configuradas como secrets
  v_url := current_setting('app.settings.supabase_url', true);
  v_service_key := current_setting('app.settings.service_role_key', true);
  
  IF v_url IS NULL THEN
    v_url := 'https://ufutyjbqfjrlzkprvyvs.supabase.co';
  END IF;

  -- Hacer la llamada HTTP a la Edge Function
  PERFORM net.http_post(
    url := v_url || '/functions/v1/process-recurring-quotes',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || v_service_key
    ),
    body := '{}'::jsonb
  );
  
  RAISE NOTICE 'Invoked process-recurring-quotes at %', NOW();
END;
$$;


ALTER FUNCTION "public"."invoke_process_recurring_quotes"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."invoke_process_recurring_quotes"() IS 'Invoca la Edge Function process-recurring-quotes para generar facturas
de presupuestos recurrentes que están pendientes de facturar.
Se ejecuta diariamente a las 00:05 UTC via pg_cron.';



CREATE OR REPLACE FUNCTION "public"."is_company_admin"("target_company" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.company_members cm
    JOIN public.users u ON cm.user_id = u.id
    LEFT JOIN public.app_roles ar ON cm.role_id = ar.id
    WHERE u.auth_user_id = auth.uid()
      AND cm.company_id = target_company
      AND cm.status = 'active'
      AND ar.name IN ('owner', 'admin', 'super_admin')
  )
$$;


ALTER FUNCTION "public"."is_company_admin"("target_company" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_company_member"("p_company_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Optimized check: direct lookup in company_members using safe ID function
  RETURN EXISTS (
    SELECT 1
    FROM public.company_members cm
    WHERE cm.company_id = p_company_id
    AND cm.user_id = public.get_my_public_id() -- SAFE: prevents users table RLS check
    AND cm.status = 'active'
  );
END;
$$;


ALTER FUNCTION "public"."is_company_member"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_dev_user"("user_email" "text") RETURNS boolean
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM users 
        WHERE email = user_email 
        AND role = 'owner'
        AND active = true
        AND (permissions->>'isDev')::boolean = true
    );
END;
$$;


ALTER FUNCTION "public"."is_dev_user"("user_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_stage_hidden_for_company"("p_stage_id" "uuid", "p_company_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM hidden_stages
    WHERE stage_id = p_stage_id
      AND company_id = p_company_id
  );
END;
$$;


ALTER FUNCTION "public"."is_stage_hidden_for_company"("p_stage_id" "uuid", "p_company_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."is_stage_hidden_for_company"("p_stage_id" "uuid", "p_company_id" "uuid") IS 'Verifica si un estado genérico está oculto para una empresa específica';



CREATE OR REPLACE FUNCTION "public"."is_super_admin"("user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Verificar por nombre de rol en lugar de ID fijo
  RETURN EXISTS (
    SELECT 1 
    FROM public.users u
    JOIN public.app_roles ar ON u.app_role_id = ar.id
    WHERE (u.auth_user_id = user_id OR u.id = user_id)
    AND ar.name = 'super_admin'
  );
END;
$$;


ALTER FUNCTION "public"."is_super_admin"("user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."issue_invoice_verifactu"("pinvoiceid" "uuid", "pdeviceid" "text" DEFAULT NULL::"text", "psoftwareid" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_inv       RECORD;
  v_next_pos  int;
  v_hash      text;
  v_result    json;
BEGIN
  -- Cargar y bloquear
  SELECT i.*, s.verifactuenabled, s.lastverifactuhash
  INTO v_inv
  FROM public.invoices i
  JOIN public.invoiceseries s ON s.id = i.seriesid
  WHERE i.id = pinvoiceid
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Invoice not found: %', pinvoiceid;
  END IF;

  IF v_inv.state IN ('final','void') OR v_inv.status NOT IN ('draft','sent') THEN
    RAISE EXCEPTION 'Invalid state to issue: state=% status=%', v_inv.state, v_inv.status;
  END IF;

  IF v_inv.verifactuenabled IS DISTINCT FROM TRUE THEN
    RAISE EXCEPTION 'Series not enabled for Verifactu';
  END IF;

  -- Siguiente posición de cadena por serie
  SELECT COALESCE(MAX(verifactuchainposition), 0) + 1
    INTO v_next_pos
  FROM public.invoices
  WHERE seriesid = v_inv.seriesid
    AND deleted_at IS NULL;

  UPDATE public.invoices
     SET verifactuchainposition = v_next_pos
   WHERE id = pinvoiceid;

  -- Hash encadenado propio
  v_hash := public.generateverifactuhash(pinvoiceid);

  -- Finalizar con tu función
  v_result := public.finalizeinvoice(
    pinvoiceid := pinvoiceid,
    pseries    := v_inv.invoiceseries, -- etiqueta visible de la serie en tu invoices
    pdeviceid  := pdeviceid,
    psoftwareid:= psoftwareid
  );

  -- Actualizar último hash de la serie
  UPDATE public.invoiceseries
     SET lastverifactuhash = v_hash,
         updated_at = CURRENT_TIMESTAMP
   WHERE id = v_inv.seriesid;

  -- Registrar evento de emisión (service role lo usa; si llamas desde Edge, usa verifactu_log_event)
  INSERT INTO public.verifactu_events(eventtype, invoiceid, companyid, payload)
  VALUES ('issue', pinvoiceid, v_inv.companyid, jsonb_build_object('hash', v_hash, 'chain_position', v_next_pos));

  RETURN json_build_object(
    'invoice_id', pinvoiceid,
    'company_id', v_inv.companyid,
    'chain_position', v_next_pos,
    'hash', v_hash,
    'result', v_result
  );
END;
$$;


ALTER FUNCTION "public"."issue_invoice_verifactu"("pinvoiceid" "uuid", "pdeviceid" "text", "psoftwareid" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."join_company_as_member"("p_company_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_auth_user_id uuid;
  v_app_user_id uuid;
  v_member_role_id uuid;
  v_auth_email text;
  v_given_name text;
  v_surname text;
BEGIN
  -- Get current auth user
  v_auth_user_id := auth.uid();
  IF v_auth_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get auth user metadata
  SELECT 
    au.email,
    COALESCE(au.raw_user_meta_data->>'given_name', split_part(au.raw_user_meta_data->>'full_name', ' ', 1), split_part(au.email, '@', 1)),
    COALESCE(au.raw_user_meta_data->>'surname', NULLIF(regexp_replace(au.raw_user_meta_data->>'full_name', '^[^\s]+\s*', ''), ''))
  INTO v_auth_email, v_given_name, v_surname
  FROM auth.users au
  WHERE au.id = v_auth_user_id;

  -- Ensure user exists in public.users (create if not)
  SELECT id INTO v_app_user_id FROM public.users WHERE auth_user_id = v_auth_user_id;
  
  IF v_app_user_id IS NULL THEN
    INSERT INTO public.users (email, name, surname, active, company_id, auth_user_id, permissions)
    VALUES (v_auth_email, COALESCE(v_given_name, 'Usuario'), v_surname, true, p_company_id, v_auth_user_id, '{}'::jsonb)
    RETURNING id INTO v_app_user_id;
  ELSE
    -- Update company_id if not set
    UPDATE public.users SET company_id = p_company_id WHERE id = v_app_user_id AND company_id IS NULL;
  END IF;

  -- Get member role id
  SELECT id INTO v_member_role_id FROM app_roles WHERE name = 'member';

  -- Upsert company membership
  INSERT INTO company_members (user_id, company_id, role_id, status)
  VALUES (v_app_user_id, p_company_id, v_member_role_id, 'active')
  ON CONFLICT (user_id, company_id) DO UPDATE
  SET role_id = EXCLUDED.role_id, status = 'active', updated_at = NOW();

  RETURN json_build_object(
    'success', true,
    'user_id', v_app_user_id,
    'company_id', p_company_id
  );
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."join_company_as_member"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."link_pending_professional"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    joined_user_email text;
BEGIN
    -- Get the email of the new member
    SELECT email INTO joined_user_email FROM public.users WHERE id = NEW.user_id;
    
    IF joined_user_email IS NOT NULL THEN
        -- Find pending professional with this email in the same company
        UPDATE professionals
        SET user_id = NEW.user_id,
            email = NULL -- Clear email/flag as linked
        WHERE company_id = NEW.company_id 
          AND email = joined_user_email
          AND user_id IS NULL;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."link_pending_professional"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."link_ticket_device"("p_ticket_id" "uuid", "p_device_id" "uuid", "p_relation_type" "text" DEFAULT 'primary'::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
  v_ticket_company_id uuid;
  v_device_company_id uuid;
BEGIN
  -- Validate Auth
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get User Company
  SELECT company_id INTO v_company_id FROM users WHERE auth_user_id = auth.uid();
  
  -- If not internal user, check for Client portal access (optional, depending on business rule)
  -- For now, strict staff access as per typical use case, or if client owns ticket/device
  IF v_company_id IS NULL THEN
     -- Check if client owns both
     IF NOT EXISTS (
       SELECT 1 FROM tickets t 
       JOIN clients c ON t.client_id = c.id
       WHERE t.id = p_ticket_id AND c.auth_user_id = auth.uid()
     ) THEN
       RAISE EXCEPTION 'Permission denied';
     END IF;
  ELSE
     -- Verify ticket belongs to company
     SELECT company_id INTO v_ticket_company_id FROM tickets WHERE id = p_ticket_id;
     IF v_ticket_company_id != v_company_id THEN
       RAISE EXCEPTION 'Ticket does not belong to your company';
     END IF;

     -- Verify device belongs to company
     SELECT company_id INTO v_device_company_id FROM devices WHERE id = p_device_id;
     IF v_device_company_id != v_company_id THEN
       RAISE EXCEPTION 'Device does not belong to your company';
     END IF;
  END IF;

  -- UPSERT the link
  INSERT INTO ticket_devices (ticket_id, device_id, relation_type)
  VALUES (p_ticket_id, p_device_id, p_relation_type)
  ON CONFLICT (ticket_id, device_id) 
  DO UPDATE SET relation_type = EXCLUDED.relation_type;

  RETURN json_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."link_ticket_device"("p_ticket_id" "uuid", "p_device_id" "uuid", "p_relation_type" "text") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."devices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "brand" character varying(100) NOT NULL,
    "model" character varying(200) NOT NULL,
    "device_type" character varying(50) NOT NULL,
    "serial_number" character varying(200),
    "imei" character varying(50),
    "status" character varying(50) DEFAULT 'received'::character varying NOT NULL,
    "condition_on_arrival" "text",
    "reported_issue" "text" NOT NULL,
    "operating_system" character varying(100),
    "storage_capacity" character varying(50),
    "color" character varying(50),
    "purchase_date" "date",
    "warranty_status" character varying(50),
    "priority" character varying(20) DEFAULT 'normal'::character varying,
    "estimated_repair_time" integer,
    "actual_repair_time" integer,
    "received_at" timestamp with time zone DEFAULT "now"(),
    "started_repair_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "delivered_at" timestamp with time zone,
    "estimated_cost" numeric(10,2),
    "final_cost" numeric(10,2),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "ai_diagnosis" "jsonb",
    "ai_confidence_score" numeric(3,2),
    "device_images" "text"[],
    "repair_notes" "text"[],
    "deleted_at" timestamp with time zone,
    "deletion_reason" "text"
);


ALTER TABLE "public"."devices" OWNER TO "postgres";


COMMENT ON TABLE "public"."devices" IS 'Tabla principal para gestión completa de dispositivos en reparación';



CREATE OR REPLACE FUNCTION "public"."list_company_devices"("p_company_id" "uuid") RETURNS SETOF "public"."devices"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_auth_user_id uuid;
  v_is_staff boolean := false;
  v_acting_client_id uuid;
BEGIN
  v_auth_user_id := auth.uid();
  IF v_auth_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Check Staff via company_members
  SELECT EXISTS (
    SELECT 1 
    FROM public.company_members cm
    JOIN public.users u ON cm.user_id = u.id
    WHERE u.auth_user_id = v_auth_user_id 
    AND cm.company_id = p_company_id 
    AND cm.status = 'active'
  ) INTO v_is_staff;

  IF NOT v_is_staff THEN
    -- Check Client
    SELECT id INTO v_acting_client_id
    FROM public.clients
    WHERE auth_user_id = v_auth_user_id 
    AND company_id = p_company_id 
    AND is_active = true;

    IF v_acting_client_id IS NULL THEN
      RAISE EXCEPTION 'Permission denied';
    END IF;
  END IF;

  -- Return Data
  RETURN QUERY
  SELECT d.*
  FROM public.devices d
  WHERE d.company_id = p_company_id
  AND (
    v_is_staff = true 
    OR 
    (v_acting_client_id IS NOT NULL AND d.client_id = v_acting_client_id)
  );

END;
$$;


ALTER FUNCTION "public"."list_company_devices"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."list_company_devices_rpc"("p_company_id" "uuid") RETURNS SETOF "public"."devices"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_user_id uuid := auth.uid();
    v_is_staff boolean;
    v_client_id uuid;
BEGIN
    -- Check if user is staff (using EXISTS for performance)
    SELECT EXISTS (
        SELECT 1 FROM public.users
        WHERE auth_user_id = v_user_id
          AND company_id = p_company_id
          AND active = true
    ) INTO v_is_staff;

    IF v_is_staff THEN
        RETURN QUERY
        SELECT * FROM devices
        WHERE company_id = p_company_id
        ORDER BY received_at DESC;
        RETURN;
    END IF;

    -- If not staff, check if user is a client
    SELECT id INTO v_client_id
    FROM public.clients
    WHERE auth_user_id = v_user_id
      AND company_id = p_company_id
      AND is_active = true; -- assuming active check is desired based on original EF logic

    IF v_client_id IS NOT NULL THEN
        RETURN QUERY
        SELECT * FROM devices
        WHERE company_id = p_company_id
          AND client_id = v_client_id
        ORDER BY received_at DESC;
        RETURN;
    END IF;

    -- If neither, return empty set (or could raise exception, but empty set is safer for list endpoints)
    -- Original EF returned 403, here we just return nothing which is a common RLS pattern but calling code might expect error. 
    -- However, since this is a specific RPC for listing, returning empty is fine if unauthorized.
    -- To match EF strictness:
    RAISE EXCEPTION 'User not allowed for this company' USING ERRCODE = 'P0001'; 
END;
$$;


ALTER FUNCTION "public"."list_company_devices_rpc"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_audit_event"("p_company_id" "uuid", "p_action" "text", "p_entity_type" "text", "p_entity_id" "uuid", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_uid uuid;
  v_email text;
BEGIN
  -- Get current user
  v_uid := auth.uid();
  IF v_uid IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT email INTO v_email FROM auth.users WHERE id = v_uid;

  INSERT INTO public.audit_logs (
    company_id,
    actor_id,
    actor_email,
    action,
    entity_type,
    entity_id,
    new_data,
    ip_address,
    user_agent
  )
  VALUES (
    p_company_id,
    v_uid,
    v_email,
    p_action,
    p_entity_type,
    p_entity_id,
    p_metadata,
    inet_client_addr(),
    current_setting('request.headers', true)::json->>'user-agent'
  );
END;
$$;


ALTER FUNCTION "public"."log_audit_event"("p_company_id" "uuid", "p_action" "text", "p_entity_type" "text", "p_entity_id" "uuid", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_booking_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    current_auth_id UUID;
    current_public_user_id UUID;
    audit_company_id UUID;
    change_details JSONB := '{}'::jsonb;
    ch_type TEXT := 'update';
BEGIN
    current_auth_id := auth.uid();
    
    -- Try to find public user id
    SELECT id INTO current_public_user_id FROM public.users WHERE auth_user_id = current_auth_id LIMIT 1;

    -- Determine operation
    IF (TG_OP = 'INSERT') THEN
        ch_type := 'create';
        audit_company_id := NEW.company_id;
        change_details := jsonb_build_object('event', 'Booking Created');
    ELSIF (TG_OP = 'UPDATE') THEN
        audit_company_id := NEW.company_id;
        
        -- Default type
        ch_type := 'update';

        -- Detect Status Change
        IF OLD.status IS DISTINCT FROM NEW.status THEN
             IF NEW.status = 'cancelled' THEN
                ch_type := 'cancel';
             ELSE
                ch_type := 'status_change';
             END IF;
             change_details := change_details || jsonb_build_object('old_status', OLD.status, 'new_status', NEW.status);
        END IF;
        
        -- Detect Reschedule
        IF OLD.start_time IS DISTINCT FROM NEW.start_time OR OLD.end_time IS DISTINCT FROM NEW.end_time THEN
             ch_type := 'reschedule';
             change_details := change_details || jsonb_build_object('old_start', OLD.start_time, 'new_start', NEW.start_time);
        END IF;

         -- Detect Resource/Professional Change
        IF OLD.resource_id IS DISTINCT FROM NEW.resource_id THEN
             change_details := change_details || jsonb_build_object('action', 'Resource Changed', 'old_resource', OLD.resource_id, 'new_resource', NEW.resource_id);
        END IF;
        IF OLD.professional_id IS DISTINCT FROM NEW.professional_id THEN
             change_details := change_details || jsonb_build_object('action', 'Professional Changed', 'old_prof', OLD.professional_id, 'new_prof', NEW.professional_id);
        END IF;
        
    END IF;

    -- Only log if it's an insert or we have interesting updates
    
    INSERT INTO public.booking_history (
        booking_id,
        changed_by,
        changed_by_user_id,
        previous_status,
        new_status,
        change_type,
        details,
        company_id
    ) VALUES (
        NEW.id,
        current_auth_id,
        current_public_user_id,
        CASE WHEN TG_OP = 'INSERT' THEN NULL ELSE OLD.status END,
        NEW.status,
        ch_type,
        change_details,
        audit_company_id
    );

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."log_booking_changes"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_device_status_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
    -- Solo registrar si el estado realmente cambió
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        INSERT INTO device_status_history (
            device_id, 
            previous_status, 
            new_status, 
            changed_by,
            notes
        ) VALUES (
            NEW.id,
            OLD.status,
            NEW.status,
            NEW.created_by, -- O usar auth.uid() si está disponible
            CASE 
                WHEN NEW.status = 'in_progress' AND NEW.started_repair_at IS NULL THEN 
                    'Reparación iniciada automáticamente'
                WHEN NEW.status = 'completed' AND NEW.completed_at IS NULL THEN 
                    'Reparación completada automáticamente'
                WHEN NEW.status = 'delivered' AND NEW.delivered_at IS NULL THEN 
                    'Dispositivo entregado automáticamente'
                ELSE 'Cambio de estado automático'
            END
        );
        
        -- Actualizar fechas automáticamente
        IF NEW.status = 'in_progress' AND NEW.started_repair_at IS NULL THEN
            NEW.started_repair_at = NOW();
        ELSIF NEW.status = 'completed' AND NEW.completed_at IS NULL THEN
            NEW.completed_at = NOW();
        ELSIF NEW.status = 'delivered' AND NEW.delivered_at IS NULL THEN
            NEW.delivered_at = NOW();
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."log_device_status_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_gdpr_audit"("p_action_type" "text", "p_table_name" "text", "p_record_id" "uuid" DEFAULT NULL::"uuid", "p_subject_email" "text" DEFAULT NULL::"text", "p_purpose" "text" DEFAULT NULL::"text", "p_old_values" "jsonb" DEFAULT NULL::"jsonb", "p_new_values" "jsonb" DEFAULT NULL::"jsonb", "p_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_company_id uuid;
    v_audit_id uuid;
BEGIN
    -- Validar action_type
    IF p_action_type NOT IN ('create', 'read', 'update', 'delete', 'export', 'anonymize', 'consent', 'access_request') THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Tipo de acción inválido'
        );
    END IF;
    
    -- Obtener company_id
    SELECT company_id INTO v_company_id
    FROM users
    WHERE auth_user_id = COALESCE(p_user_id, auth.uid());
    
    -- Insertar en audit log
    INSERT INTO gdpr_audit_log (
        user_id,
        company_id,
        action_type,
        table_name,
        record_id,
        subject_email,
        purpose,
        old_values,
        new_values,
        created_at
    ) VALUES (
        COALESCE(p_user_id, auth.uid()),
        v_company_id,
        p_action_type,
        p_table_name,
        p_record_id,
        p_subject_email,
        p_purpose,
        p_old_values,
        p_new_values,
        now()
    )
    RETURNING id INTO v_audit_id;
    
    RETURN jsonb_build_object(
        'success', true,
        'audit_id', v_audit_id,
        'logged_at', now()
    );
    
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'error_detail', SQLSTATE
    );
END;
$$;


ALTER FUNCTION "public"."log_gdpr_audit"("p_action_type" "text", "p_table_name" "text", "p_record_id" "uuid", "p_subject_email" "text", "p_purpose" "text", "p_old_values" "jsonb", "p_new_values" "jsonb", "p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_gdpr_audit"("p_action_type" "text", "p_table_name" "text", "p_record_id" "uuid", "p_subject_email" "text", "p_purpose" "text", "p_old_values" "jsonb", "p_new_values" "jsonb", "p_user_id" "uuid") IS 'Registra un evento de auditoría GDPR en gdpr_audit_log';



CREATE OR REPLACE FUNCTION "public"."maintain_ticket_opened_status"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_category text;
  v_workflow text;
BEGIN
  -- Get category AND workflow of the NEW stage
  SELECT stage_category, workflow_category INTO v_category, v_workflow
  FROM ticket_stages
  WHERE id = NEW.stage_id;

  -- Logic: Close if category is 'completed' OR workflow is 'cancel' or 'final'
  -- (Because some users have 'final' stages marked as 'open' category erroneously)
  IF v_category = 'completed' OR v_workflow IN ('cancel', 'final') THEN
     NEW.is_opened := false;
  ELSE
     NEW.is_opened := true;
  END IF;
  
  -- Override if deleted
  IF NEW.deleted_at IS NOT NULL THEN
     NEW.is_opened := false;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."maintain_ticket_opened_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_client_accessed"("p_client_id" "uuid", "p_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_client_email text;
    v_company_id uuid;
    v_user_id uuid;
BEGIN
    -- Obtener email del cliente
    SELECT email INTO v_client_email
    FROM clients
    WHERE id = p_client_id;
    
    IF v_client_email IS NULL THEN
        RETURN;
    END IF;
    
    -- Obtener user_id y company_id
    SELECT u.id, u.company_id INTO v_user_id, v_company_id
    FROM users u
    WHERE u.auth_user_id = COALESCE(p_user_id, auth.uid())
    LIMIT 1;
    
    -- Actualizar last_accessed_at y access_count
    UPDATE clients
    SET 
        last_accessed_at = now(),
        access_count = COALESCE(access_count, 0) + 1
    WHERE id = p_client_id;
    
    -- Registrar en audit log (solo si pasó más de 1 hora desde el último registro)
    IF NOT EXISTS (
        SELECT 1 FROM gdpr_audit_log
        WHERE record_id = p_client_id
        AND action_type = 'read'
        AND created_at > now() - INTERVAL '1 hour'
    ) THEN
        INSERT INTO gdpr_audit_log (
            user_id,
            company_id,
            action_type,
            table_name,
            record_id,
            subject_email,
            purpose,
            created_at
        ) VALUES (
            v_user_id,
            v_company_id,
            'read',
            'clients',
            p_client_id,
            v_client_email,
            'Client data accessed',
            now()
        );
    END IF;
    
EXCEPTION WHEN OTHERS THEN
    -- No bloquear si falla
    RAISE WARNING 'Error al marcar cliente como accedido: %', SQLERRM;
END;
$$;


ALTER FUNCTION "public"."mark_client_accessed"("p_client_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."mark_client_accessed"("p_client_id" "uuid", "p_user_id" "uuid") IS 'Marca un cliente como accedido y registra en audit log (llamar desde frontend)';



CREATE OR REPLACE FUNCTION "public"."mark_expired_quotes"() RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  UPDATE quotes
  SET status = 'expired',
      updated_at = NOW()
  WHERE status IN ('draft', 'sent', 'viewed')
    AND valid_until < CURRENT_DATE
    AND NOT is_anonymized;
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$;


ALTER FUNCTION "public"."mark_expired_quotes"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."mark_expired_quotes"() IS 'Marca como expirados los presupuestos que superaron su fecha de validez';



CREATE OR REPLACE FUNCTION "public"."mark_invoice_local_payment_rpc"("p_invoice_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_user_id uuid := auth.uid();
    v_mapped_client_id uuid;
    v_mapped_company_id uuid;
    v_current_status text;
    v_payment_status text;
BEGIN
    -- 1. Resolve Client & Company (from client_portal_users or clients table)
    SELECT client_id, company_id INTO v_mapped_client_id, v_mapped_company_id
    FROM client_portal_users
    WHERE email = (SELECT email FROM auth.users WHERE id = v_user_id)
      AND is_active = true
    LIMIT 1;

    IF v_mapped_client_id IS NULL THEN
        -- Fallback to clients table
        SELECT id, company_id INTO v_mapped_client_id, v_mapped_company_id
        FROM clients
        WHERE auth_user_id = v_user_id
          AND is_active = true
        LIMIT 1;
    END IF;

    IF v_mapped_client_id IS NULL THEN
        RAISE EXCEPTION 'User profile not found or access denied';
    END IF;

    -- 2. Verify Invoice Ownership & Status
    SELECT status, payment_status INTO v_current_status, v_payment_status
    FROM invoices
    WHERE id = p_invoice_id
      AND client_id = v_mapped_client_id
      AND company_id = v_mapped_company_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Invoice not found or access denied';
    END IF;

    IF v_payment_status = 'paid' THEN
        RAISE EXCEPTION 'Invoice is already paid';
    END IF;

    -- 3. Update Status
    UPDATE invoices
    SET payment_status = 'pending_local',
        updated_at = now()
    WHERE id = p_invoice_id;

    RETURN jsonb_build_object('success', true, 'message', 'Invoice marked for local payment');
END;
$$;


ALTER FUNCTION "public"."mark_invoice_local_payment_rpc"("p_invoice_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_project_as_read"("p_project_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_user_id UUID;
    v_client_id UUID;
BEGIN
    -- Check if it's an internal user
    SELECT id INTO v_user_id
    FROM users
    WHERE auth_user_id = auth.uid();

    IF v_user_id IS NOT NULL THEN
        INSERT INTO project_reads (project_id, user_id, last_read_at)
        VALUES (p_project_id, v_user_id, now())
        ON CONFLICT (project_id, user_id) WHERE user_id IS NOT NULL
        DO UPDATE SET last_read_at = now();
        RETURN;
    END IF;

    -- Check if it's a client
    SELECT id INTO v_client_id
    FROM clients
    WHERE auth_user_id = auth.uid();

    IF v_client_id IS NOT NULL THEN
        INSERT INTO project_reads (project_id, client_id, last_read_at)
        VALUES (p_project_id, v_client_id, now())
        ON CONFLICT (project_id, client_id) WHERE client_id IS NOT NULL
        DO UPDATE SET last_read_at = now();
        RETURN;
    END IF;

    -- If neither, do nothing (or raise error if strict)
END;
$$;


ALTER FUNCTION "public"."mark_project_as_read"("p_project_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."match_product_catalog"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer) RETURNS TABLE("id" "uuid", "name" "text", "brand" "text", "model" "text", "description" "text", "similarity" double precision)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
begin
  return query
  select
    product_catalog.id,
    product_catalog.name,
    product_catalog.brand,
    product_catalog.model,
    product_catalog.description,
    1 - (product_catalog.embedding <=> query_embedding) as similarity
  from product_catalog
  where 1 - (product_catalog.embedding <=> query_embedding) > match_threshold
  order by product_catalog.embedding <=> query_embedding
  limit match_count;
end;
$$;


ALTER FUNCTION "public"."match_product_catalog"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."migrate_clients_by_tenant"() RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
    michinanny_id UUID;
    satpcgo_id UUID;
    libera_id UUID;
    result_text TEXT := '';
    clients_migrated INTEGER := 0;
BEGIN
    -- Obtener IDs de las empresas
    SELECT id INTO michinanny_id FROM companies WHERE name = 'Michinanny';
    SELECT id INTO satpcgo_id FROM companies WHERE name = 'SatPCGo';
    SELECT id INTO libera_id FROM companies WHERE name = 'Libera Tus Creencias';
    
    -- Verificar que las empresas existen
    IF michinanny_id IS NULL OR satpcgo_id IS NULL OR libera_id IS NULL THEN
        RAISE EXCEPTION 'No se encontraron todas las empresas. Ejecutar primero migrate_legacy_users().';
    END IF;
    
    result_text := result_text || '=== EMPRESAS ENCONTRADAS ===' || E'\n';
    result_text := result_text || 'Michinanny: ' || michinanny_id::text || E'\n';
    result_text := result_text || 'SatPCGo: ' || satpcgo_id::text || E'\n';
    result_text := result_text || 'Libera Tus Creencias: ' || libera_id::text || E'\n\n';
    
    -- Limpiar datos anteriores
    DELETE FROM clients WHERE metadata->>'migration_source' = 'legacy_data';
    result_text := result_text || '🧹 Datos anteriores limpiados' || E'\n\n';
    
    -- === CLIENTES DE SATPCGO (Reparación de ordenadores) ===
    -- Según mencionas, los datos originales pertenecían a SatPCGo
    result_text := result_text || '=== MIGRANDO CLIENTES A SATPCGO ===' || E'\n';
    
    INSERT INTO clients (id, company_id, name, email, phone, address, metadata, created_at, updated_at)
    VALUES 
    -- Clientes originales que tenían problemas con ordenadores
    (gen_random_uuid(), satpcgo_id, 'Ana Pérez García', 'ana.perez@example.com', '611223344',
     '{"direccion": "Calle Mayor 15, Madrid", "legacy_direccion_id": "6800b7d54417550a4cba4392"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43bb", "dni": "12345678A", "migration_source": "legacy_data", "tipo_cliente": "reparacion_pc"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    (gen_random_uuid(), satpcgo_id, 'Luis González López', 'luis.gonzalez@example.com', '622334455',
     '{"direccion": "Avenida España 23, Barcelona", "legacy_direccion_id": "6800b7d54417550a4cba4393"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43bc", "dni": "98765432B", "migration_source": "legacy_data", "tipo_cliente": "mantenimiento"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    (gen_random_uuid(), satpcgo_id, 'Sofía Martínez Ruiz', 'sofia.martinez@example.com', '633445566',
     '{"direccion": "Plaza Central 8, Valencia", "legacy_direccion_id": "6800b7d54417550a4cba4394"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43bd", "dni": "45678912C", "migration_source": "legacy_data", "tipo_cliente": "reparacion_laptop"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    (gen_random_uuid(), satpcgo_id, 'Manolo Cabeza Bolo', 'cabezabolo@gmail.com', '654234567',
     '{"direccion": "Calle Inventada 42, Sevilla", "legacy_direccion_id": "68338e40fb9513a4a9116a0d"}'::jsonb,
     '{"legacy_id": "68338e4148117feab207eed1", "dni": "676545634L", "migration_source": "legacy_data", "tipo_cliente": "virus_removal"}'::jsonb,
     '2025-05-25 21:40:00'::timestamp, NOW()),
     
    (gen_random_uuid(), satpcgo_id, 'POR FAVOR FUNCIONA', 'porfavor@gmail.com', '675434567',
     '{"direccion": "Calle de la Desesperación 1, Madrid", "legacy_direccion_id": "6833a2f1fb9513a4a9116fd3"}'::jsonb,
     '{"legacy_id": "6833a2f248117feab207f474", "dni": "456284920G", "migration_source": "legacy_data", "tipo_cliente": "emergencia_pc", "nota": "Cliente desesperado por arreglar su PC"}'::jsonb,
     '2025-05-25 23:08:00'::timestamp, NOW());
     
    clients_migrated := clients_migrated + 5;
    result_text := result_text || '✅ 5 clientes migrados a SatPCGo' || E'\n';
    
    -- === CLIENTES DE MICHINANNY (Servicios para mascotas) ===
    result_text := result_text || E'\n=== AÑADIENDO CLIENTES A MICHINANNY ===' || E'\n';
    
    INSERT INTO clients (id, company_id, name, email, phone, address, metadata, created_at, updated_at)
    VALUES 
    (gen_random_uuid(), michinanny_id, 'Carmen López Fernández', 'carmen.lopez@example.com', '655667788',
     '{"direccion": "Barrio de Salamanca 12, Madrid", "tipo_vivienda": "piso"}'::jsonb,
     '{"migration_source": "legacy_data", "tipo_cliente": "cuidado_perros", "mascotas": ["Golden Retriever", "Gato Persa"], "servicios_frecuentes": ["paseo", "cuidado_fin_de_semana"]}'::jsonb,
     NOW(), NOW()),
     
    (gen_random_uuid(), michinanny_id, 'Mikimiau Miau Miau', 'miau@gmail.com', '657876452',
     '{"direccion": "Calle de los Gatos 7, Barcelona", "tipo_vivienda": "casa"}'::jsonb,
     '{"legacy_id": "68338da11985382d9f221703", "dni": "456234562A", "migration_source": "legacy_data", "tipo_cliente": "especialista_gatos", "mascotas": ["Miau", "Gatito", "Pelusa"], "nota": "Especialista en gatos, claramente"}'::jsonb,
     '2025-05-25 21:37:00'::timestamp, NOW()),
     
    (gen_random_uuid(), michinanny_id, 'Isabel Ruiz Pérez', 'isabel.ruiz@example.com', '677889900',
     '{"direccion": "Avenida de los Parques 34, Valencia", "tipo_vivienda": "chalet"}'::jsonb,
     '{"migration_source": "legacy_data", "tipo_cliente": "cuidado_premium", "mascotas": ["Labrador", "Yorkshire"], "servicios_frecuentes": ["grooming", "veterinario"]}'::jsonb,
     NOW(), NOW());
     
    clients_migrated := clients_migrated + 3;
    result_text := result_text || '✅ 3 clientes añadidos a Michinanny' || E'\n';
    
    -- === CLIENTES DE LIBERA TUS CREENCIAS (Coaching/Terapia) ===
    result_text := result_text || E'\n=== AÑADIENDO CLIENTES A LIBERA TUS CREENCIAS ===' || E'\n';
    
    INSERT INTO clients (id, company_id, name, email, phone, address, metadata, created_at, updated_at)
    VALUES 
    (gen_random_uuid(), libera_id, 'Elena Martín López', 'elena.martin@example.com', '699001122',
     '{"direccion": "Zona Zen 15, Ibiza", "tipo_vivienda": "apartamento"}'::jsonb,
     '{"migration_source": "legacy_data", "tipo_cliente": "coaching_personal", "servicios": ["autoestima", "liberacion_emocional"], "sesiones_completadas": 12}'::jsonb,
     NOW(), NOW()),
     
    (gen_random_uuid(), libera_id, 'Mamerto Humberto', 'hola@gmail.com', '654567432',
     '{"direccion": "Calle de la Paz Interior 3, Mallorca", "tipo_vivienda": "casa"}'::jsonb,
     '{"legacy_id": "683371be2e4bb9979f4c9025", "dni": "234567353K", "migration_source": "legacy_data", "tipo_cliente": "terapia_pareja", "servicios": ["comunicacion", "resolucion_conflictos"]}'::jsonb,
     '2025-05-25 19:38:00'::timestamp, NOW()),
     
    (gen_random_uuid(), libera_id, 'Alberto Paperto Miamerto', 'miamerto@gmail.com', '675432345',
     '{"direccion": "Plaza de la Libertad 88, Granada", "tipo_vivienda": "loft"}'::jsonb,
     '{"legacy_id": "6833917f48117feab207eefb", "dni": "657542345L", "migration_source": "legacy_data", "tipo_cliente": "coaching_profesional", "servicios": ["liderazgo", "gestion_tiempo"], "objetivo": "promocion_laboral"}'::jsonb,
     '2025-05-25 21:54:00'::timestamp, NOW());
     
    clients_migrated := clients_migrated + 3;
    result_text := result_text || '✅ 3 clientes añadidos a Libera Tus Creencias' || E'\n';
    
    -- Resumen final
    result_text := result_text || E'\n=== RESUMEN DE MIGRACIÓN ===' || E'\n';
    result_text := result_text || 'Total de clientes migrados: ' || clients_migrated::text || E'\n';
    result_text := result_text || '- SatPCGo (Reparación PC): 5 clientes' || E'\n';
    result_text := result_text || '- Michinanny (Mascotas): 3 clientes' || E'\n';
    result_text := result_text || '- Libera Tus Creencias (Coaching): 3 clientes' || E'\n';
    result_text := result_text || E'\n✅ Migración completada con datos distribuidos por tenant' || E'\n';
    
    RETURN result_text;
END;
$$;


ALTER FUNCTION "public"."migrate_clients_by_tenant"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."migrate_legacy_clients"() RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
    michinanny_company_id UUID;
    anscarr_company_id UUID;
    libera_company_id UUID;
    satpcgo_company_id UUID;
    result_text TEXT := '';
    clients_migrated INTEGER := 0;
BEGIN
    -- Obtener los IDs de las empresas existentes
    SELECT id INTO michinanny_company_id FROM companies WHERE name = 'Michinanny';
    SELECT id INTO anscarr_company_id FROM companies WHERE name = 'Anscarr';  
    SELECT id INTO libera_company_id FROM companies WHERE name = 'Libera Tus Creencias';
    SELECT id INTO satpcgo_company_id FROM companies WHERE name = 'SatPCGo';
    
    -- Verificar que las empresas existen
    IF michinanny_company_id IS NULL THEN
        RAISE EXCEPTION 'Empresa Michinanny no encontrada. Ejecutar primero el script de migración de usuarios.';
    END IF;
    
    result_text := result_text || 'Empresas encontradas:' || E'\n';
    result_text := result_text || '- Michinanny: ' || michinanny_company_id::text || E'\n';
    result_text := result_text || '- Anscarr: ' || COALESCE(anscarr_company_id::text, 'NOT FOUND') || E'\n';
    result_text := result_text || '- Libera Tus Creencias: ' || COALESCE(libera_company_id::text, 'NOT FOUND') || E'\n';
    result_text := result_text || '- SatPCGo: ' || COALESCE(satpcgo_company_id::text, 'NOT FOUND') || E'\n\n';
    
    -- Limpiar clientes existentes de migración anterior
    DELETE FROM clients WHERE metadata->>'legacy_id' IS NOT NULL;
    
    result_text := result_text || 'Iniciando migración de clientes...' || E'\n';
    
    -- MIGRAR CLIENTES
    -- La mayoría pertenecen a usuario_id: 672275dacb317c137fb1dd1f (Michinanny)
    -- Uno pertenece a usuario_id: 671e967acb317c137fb1dc4a (probablemente otra empresa)
    
    -- Clientes de Michinanny (usuario_id: 672275dacb317c137fb1dd1f)
    INSERT INTO clients (id, company_id, name, email, phone, address, metadata, created_at, updated_at)
    VALUES 
    -- Ana Pérez García
    (gen_random_uuid(), michinanny_company_id, 'Ana Pérez García', 'ana.perez@example.com', '611223344', 
     '{"legacy_direccion_id": "6800b7d54417550a4cba4392"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43bb", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "12345678A"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Luis González López  
    (gen_random_uuid(), michinanny_company_id, 'Luis González López', 'luis.gonzalez@example.com', '622334455',
     '{"legacy_direccion_id": "6800b7d54417550a4cba4393"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43bc", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "98765432B"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Sofía Martínez Ruiz
    (gen_random_uuid(), michinanny_company_id, 'Sofía Martínez Ruiz', 'sofia.martinez@example.com', '633445566',
     '{"legacy_direccion_id": "6800b7d54417550a4cba4394"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43bd", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "45678912C"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Javier Sánchez Díaz
    (gen_random_uuid(), michinanny_company_id, 'Javier Sánchez Díaz', 'javier.sanchez@example.com', '644556677',
     '{"legacy_direccion_id": "6800b7d54417550a4cba4395"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43be", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "32165498D"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Carmen López Fernández
    (gen_random_uuid(), michinanny_company_id, 'Carmen López Fernández', 'carmen.lopez@example.com', '655667788',
     '{"legacy_direccion_id": "6800b7d54417550a4cba4396"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43bf", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "78912345E"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Manuel García Martín
    (gen_random_uuid(), michinanny_company_id, 'Manuel García Martín', 'manuel.garcia@example.com', '666778899',
     '{"legacy_direccion_id": "6800b7d54417550a4cba4397"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43c0", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "65432178F"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Isabel Ruiz Pérez
    (gen_random_uuid(), michinanny_company_id, 'Isabel Ruiz Pérez', 'isabel.ruiz@example.com', '677889900',
     '{"legacy_direccion_id": "6800b7d54417550a4cba4398"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43c1", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "21478536G"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Antonio Díaz González
    (gen_random_uuid(), michinanny_company_id, 'Antonio Díaz González', 'antonio.diaz@example.com', '688990011',
     '{"legacy_direccion_id": "6800b7d54417550a4cba4399"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43c2", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "87521469H"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Elena Martín López
    (gen_random_uuid(), michinanny_company_id, 'Elena Martín López', 'elena.martin@example.com', '699001122',
     '{"legacy_direccion_id": "6800b7d54417550a4cba439a"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43c3", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "96325874J"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Marta Pérez Díaz
    (gen_random_uuid(), michinanny_company_id, 'Marta Pérez Díaz', 'marta.perez@example.com', '611223355',
     '{"legacy_direccion_id": "6800b7d54417550a4cba439c"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43c5", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "25874136L"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW());
     
    clients_migrated := clients_migrated + 10;
    
    -- Continuar con más clientes de Michinanny (los primeros 45 registros)
    INSERT INTO clients (id, company_id, name, email, phone, address, metadata, created_at, updated_at)
    VALUES 
    -- Carlos González Martín
    (gen_random_uuid(), michinanny_company_id, 'Carlos González Martín', 'carlos.gonzalez@example.com', '622334466',
     '{"legacy_direccion_id": "6800b7d54417550a4cba439d"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43c6", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "36985214M"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Lucía Martínez Fernández
    (gen_random_uuid(), michinanny_company_id, 'Lucía Martínez Fernández', 'lucia.martinez@example.com', '633445577',
     '{"legacy_direccion_id": "6800b7d54417550a4cba439e"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43c7", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "15935782N"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Sergio Sánchez López
    (gen_random_uuid(), michinanny_company_id, 'Sergio Sánchez López', 'sergio.sanchez@example.com', '644556688',
     '{"legacy_direccion_id": "6800b7d54417550a4cba439f"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43c8", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "75395128P"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Paula López García
    (gen_random_uuid(), michinanny_company_id, 'Paula López García', 'paula.lopez@example.com', '655667799',
     '{"legacy_direccion_id": "6800b7d54417550a4cba43a0"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43c9", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "85274196Q"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Raúl García Ruiz
    (gen_random_uuid(), michinanny_company_id, 'Raúl García Ruiz', 'raul.garcia@example.com', '666778900',
     '{"legacy_direccion_id": "6800b7d54417550a4cba43a1"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43ca", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "96385274R"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Mamerto Humberto (cliente especial - tiene apellidos vacíos)
    (gen_random_uuid(), michinanny_company_id, 'Mamerto Humberto', 'hola@gmail.com', '654567432',
     '{"legacy_direccion_id": "683371be48117feab207e815"}'::jsonb,
     '{"legacy_id": "683371be2e4bb9979f4c9025", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "234567353K"}'::jsonb,
     '2025-05-25 19:38:00'::timestamp, NOW()),
     
    -- Mikimiau Miau Miau
    (gen_random_uuid(), michinanny_company_id, 'Mikimiau Miau Miau', 'miau@gmail.com', '657876452',
     '{"legacy_direccion_id": "68338da02e4bb9979f4c9b03"}'::jsonb,
     '{"legacy_id": "68338da11985382d9f221703", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "456234562A"}'::jsonb,
     '2025-05-25 21:37:00'::timestamp, NOW()),
     
    -- Manolo Cabeza Bolo
    (gen_random_uuid(), michinanny_company_id, 'Manolo Cabeza Bolo', 'cabezabolo@gmail.com', '654234567',
     '{"legacy_direccion_id": "68338e40fb9513a4a9116a0d"}'::jsonb,
     '{"legacy_id": "68338e4148117feab207eed1", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "676545634L"}'::jsonb,
     '2025-05-25 21:40:00'::timestamp, NOW()),
     
    -- Alberto Paperto Miamerto
    (gen_random_uuid(), michinanny_company_id, 'Alberto Paperto Miamerto', 'miamerto@gmail.com', '675432345',
     '{"legacy_direccion_id": "6833917efb9513a4a9116a4b"}'::jsonb,
     '{"legacy_id": "6833917f48117feab207eefb", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "657542345L"}'::jsonb,
     '2025-05-25 21:54:00'::timestamp, NOW()),
     
    -- POR FAVOR FUNCIONA
    (gen_random_uuid(), michinanny_company_id, 'POR FAVOR FUNCIONA', 'porfavor@gmail.com', '675434567',
     '{"legacy_direccion_id": "6833a2f1fb9513a4a9116fd3"}'::jsonb,
     '{"legacy_id": "6833a2f248117feab207f474", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "456284920G"}'::jsonb,
     '2025-05-25 23:08:00'::timestamp, NOW());
     
    clients_migrated := clients_migrated + 10;
    
    -- Cliente especial que pertenece a otro usuario_id (probablemente otra empresa)
    -- Pedro Fernández Ruiz (usuario_id: 671e967acb317c137fb1dc4a)
    IF anscarr_company_id IS NOT NULL THEN
        INSERT INTO clients (id, company_id, name, email, phone, address, metadata, created_at, updated_at)
        VALUES 
        (gen_random_uuid(), anscarr_company_id, 'Pedro Fernández Ruiz', 'pedro.fernandez@example.com', '600112233',
         '{"legacy_direccion_id": "6800b7d54417550a4cba439b"}'::jsonb,
         '{"legacy_id": "6800bb5a4417550a4cba43c4", "legacy_usuario_id": "671e967acb317c137fb1dc4a", "dni": "14785236K"}'::jsonb,
         '2025-04-17 08:27:00'::timestamp, NOW());
         
        clients_migrated := clients_migrated + 1;
        result_text := result_text || 'Cliente Pedro Fernández asignado a Anscarr' || E'\n';
    ELSE
        -- Si no existe Anscarr, asignar a Michinanny temporalmente
        INSERT INTO clients (id, company_id, name, email, phone, address, metadata, created_at, updated_at)
        VALUES 
        (gen_random_uuid(), michinanny_company_id, 'Pedro Fernández Ruiz', 'pedro.fernandez@example.com', '600112233',
         '{"legacy_direccion_id": "6800b7d54417550a4cba439b"}'::jsonb,
         '{"legacy_id": "6800bb5a4417550a4cba43c4", "legacy_usuario_id": "671e967acb317c137fb1dc4a", "dni": "14785236K", "note": "Originalmente de otro usuario_id - revisar asignación"}'::jsonb,
         '2025-04-17 08:27:00'::timestamp, NOW());
         
        clients_migrated := clients_migrated + 1;
        result_text := result_text || 'Cliente Pedro Fernández asignado temporalmente a Michinanny (usuario_id diferente)' || E'\n';
    END IF;
    
    -- Continuar con el resto de clientes de Michinanny...
    -- (Agregando algunos más de los 47 totales para completar la migración)
    INSERT INTO clients (id, company_id, name, email, phone, address, metadata, created_at, updated_at)
    VALUES 
    -- Nuria Ruiz Díaz
    (gen_random_uuid(), michinanny_company_id, 'Nuria Ruiz Díaz', 'nuria.ruiz@example.com', '677889911',
     '{"legacy_direccion_id": "6800b7d54417550a4cba43a2"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43cb", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "10293847S"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- David Díaz Martín
    (gen_random_uuid(), michinanny_company_id, 'David Díaz Martín', 'david.diaz@example.com', '688990022',
     '{"legacy_direccion_id": "6800b7d54417550a4cba43a3"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43cc", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "47586932T"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Alba Martín Fernández
    (gen_random_uuid(), michinanny_company_id, 'Alba Martín Fernández', 'alba.martin@example.com', '699001133',
     '{"legacy_direccion_id": "6800b7d54417550a4cba43a4"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43cd", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "29384756U"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Adrián Fernández López
    (gen_random_uuid(), michinanny_company_id, 'Adrián Fernández López', 'adrian.fernandez@example.com', '600112244',
     '{"legacy_direccion_id": "6800b7d54417550a4cba43a5"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43ce", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "56473829V"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW()),
     
    -- Clara Pérez García
    (gen_random_uuid(), michinanny_company_id, 'Clara Pérez García', 'clara.perez@example.com', '611223366',
     '{"legacy_direccion_id": "6800b7d54417550a4cba43a6"}'::jsonb,
     '{"legacy_id": "6800bb5a4417550a4cba43cf", "legacy_usuario_id": "672275dacb317c137fb1dd1f", "dni": "82736495W"}'::jsonb,
     '2025-04-17 08:27:00'::timestamp, NOW());
     
    clients_migrated := clients_migrated + 5;
    
    result_text := result_text || 'Migración completada exitosamente!' || E'\n';
    result_text := result_text || 'Total de clientes migrados: ' || clients_migrated::text || E'\n';
    result_text := result_text || 'Clientes asignados principalmente a Michinanny' || E'\n';
    result_text := result_text || 'Un cliente con usuario_id diferente identificado' || E'\n';
    
    RETURN result_text;
END;
$$;


ALTER FUNCTION "public"."migrate_legacy_clients"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."migrate_legacy_users"() RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    company_uuid UUID;
    result_text TEXT := '';
BEGIN
    -- Limpiar datos anteriores de migración si existen
    DELETE FROM users WHERE email LIKE '%@michinanny.es' OR email LIKE '%@anscarr.es' OR email LIKE '%@liberatuscreencias.com' OR email LIKE '%@satpcgo.es';
    DELETE FROM companies WHERE legacy_negocio_id IS NOT NULL;
    
    -- EMPRESA 1: michinanny.es
    INSERT INTO companies (id, name, website, legacy_negocio_id, created_at, updated_at)
    VALUES (
        gen_random_uuid(),
        'Michinanny',
        'https://michinanny.es/',
        '671ec9f84ecc7019c9ea3bd2',
        '2024-10-27 19:19:00'::timestamp,
        NOW()
    ) RETURNING id INTO company_uuid;
    
    result_text := result_text || 'Empresa Michinanny creada: ' || company_uuid::text || E'\n';
    
    -- Usuarios de Michinanny
    INSERT INTO users (id, company_id, email, name, permissions, created_at, updated_at)
    VALUES 
    (gen_random_uuid(), company_uuid, 'marina@michinanny.es', 'Marina Casado García', 
     '{"moduloFacturas": false, "moduloPresupuestos": false, "moduloServicios": true, "moduloMaterial": false}'::jsonb,
     '2024-10-27 19:19:00'::timestamp, NOW()),
    (gen_random_uuid(), company_uuid, 'eva@michinanny.es', 'Eva Marín',
     '{"moduloFacturas": false, "moduloPresupuestos": false, "moduloServicios": true, "moduloMaterial": false}'::jsonb,
     '2024-10-27 19:20:00'::timestamp, NOW());
    
    -- EMPRESA 3: liberatuscreencias.com
    INSERT INTO companies (id, name, website, legacy_negocio_id, created_at, updated_at)
    VALUES (
        gen_random_uuid(),
        'Libera Tus Creencias',
        'https://liberatuscreencias.com/',
        '67227971cb317c137fb1dd20',
        '2024-10-27 19:40:00'::timestamp,
        NOW()
    ) RETURNING id INTO company_uuid;
    
    INSERT INTO users (id, company_id, email, name, permissions, created_at, updated_at)
    VALUES (
        gen_random_uuid(),
        company_uuid,
        'vanesa@liberatuscreencias.com',
        'Vanesa Santa Maria Garibaldi',
        '{"moduloFacturas": false, "moduloPresupuestos": false, "moduloServicios": false, "moduloMaterial": false}'::jsonb,
        '2024-10-27 19:40:00'::timestamp,
        NOW()
    );
    
    -- EMPRESA 4: satpcgo.es
    INSERT INTO companies (id, name, website, legacy_negocio_id, created_at, updated_at)
    VALUES (
        gen_random_uuid(),
        'SatPCGo',
        'https://satpcgo.es/',
        '671eca034ecc7019c9ea3bd3',
        '2024-10-30 18:07:00'::timestamp,
        NOW()
    ) RETURNING id INTO company_uuid;
    
    INSERT INTO users (id, company_id, email, name, permissions, created_at, updated_at)
    VALUES (
        gen_random_uuid(),
        company_uuid,
        'alberto@satpcgo.es',
        'Alberto Dominguez',
        '{"moduloFacturas": true, "moduloPresupuestos": true, "moduloServicios": true, "moduloMaterial": true}'::jsonb,
        '2024-10-30 18:07:00'::timestamp,
        NOW()
    );
    
    result_text := result_text || 'Migración completada exitosamente. 4 empresas y 5 usuarios creados.';
    
    RETURN result_text;
END;
$$;


ALTER FUNCTION "public"."migrate_legacy_users"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_booking_notifier"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_url TEXT := 'https://ufutyjbqfjrlzkprvyvs.supabase.co/functions/v1/booking-notifier';
    v_secret TEXT := 'simplifica-booking-webhook-secret';
    v_payload JSONB;
BEGIN
    -- Construct Payload
    v_payload := jsonb_build_object(
        'type', TG_OP,
        'table', TG_TABLE_NAME,
        'schema', TG_TABLE_SCHEMA,
        'record', row_to_json(NEW),
        'old_record', CASE WHEN TG_OP = 'UPDATE' THEN row_to_json(OLD) ELSE NULL END
    );

    -- Send Async Request
    -- We use PERFORM to discard the result (request_id)
    PERFORM net.http_post(
        url := v_url,
        body := v_payload,
        headers := jsonb_build_object(
            'Content-Type', 'application/json',
            'x-webhook-secret', v_secret
        )
    );

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_booking_notifier"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_owner_on_gdpr_request"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_owner_id UUID;
    v_subject_name TEXT;
    v_type_es TEXT;
BEGIN
    -- Get Company Owner ID from company_members joining app_roles
    SELECT cm.user_id INTO v_owner_id
    FROM public.company_members cm
    JOIN public.app_roles ar ON cm.role_id = ar.id
    WHERE cm.company_id = NEW.company_id
    AND ar.name = 'owner'
    AND cm.status = 'active'
    LIMIT 1;

    -- Fallback: If no owner found, try 'admin'
    IF v_owner_id IS NULL THEN
        SELECT cm.user_id INTO v_owner_id
        FROM public.company_members cm
        JOIN public.app_roles ar ON cm.role_id = ar.id
        WHERE cm.company_id = NEW.company_id
        AND ar.name = 'admin'
        AND cm.status = 'active'
        LIMIT 1;
    END IF;

    -- If still no recipient, exit (prevent error)
    IF v_owner_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- Determine subject name for display
    v_subject_name := COALESCE(NEW.subject_name, NEW.subject_email, 'Usuario');

    -- Translate Request Type
    v_type_es := CASE NEW.request_type
        WHEN 'rectification' THEN 'rectificación'
        WHEN 'erasure' THEN 'supresión (olvido)'
        WHEN 'restriction' THEN 'limitación'
        WHEN 'portability' THEN 'portabilidad'
        WHEN 'objection' THEN 'oposición'
        ELSE NEW.request_type
    END;

    -- Insert Notification
    INSERT INTO public.notifications (
        company_id,
        recipient_id,
        type,
        reference_id,
        title,
        content,
        is_read,
        created_at
    ) VALUES (
        NEW.company_id,
        v_owner_id,
        'gdpr_request',
        NEW.id,
        'Nueva Solicitud RGPD: ' || v_type_es,
        'El usuario ' || v_subject_name || ' ha solicitado: ' || v_type_es || '.',
        false,
        NOW()
    );

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_owner_on_gdpr_request"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_client_consent"("p_token" "uuid", "p_marketing_consent" boolean, "p_ip" "text", "p_user_agent" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_client_id uuid;
    v_client_name text;
BEGIN
    SELECT id, name INTO v_client_id, v_client_name
    FROM public.clients
    WHERE invitation_token = p_token
    LIMIT 1;

    IF v_client_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Invalid or expired token');
    END IF;

    UPDATE public.clients
    SET
        consent_status = 'accepted',
        marketing_consent = p_marketing_consent,
        consent_date = NOW(),
        consent_ip = p_ip,
        invitation_status = 'completed',
        invitation_token = NULL,
        updated_at = NOW()
    WHERE id = v_client_id;

    RETURN jsonb_build_object('success', true, 'client_name', v_client_name);
END;
$$;


ALTER FUNCTION "public"."process_client_consent"("p_token" "uuid", "p_marketing_consent" boolean, "p_ip" "text", "p_user_agent" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_gdpr_deletion_request"("p_request_id" "uuid", "p_approve" boolean, "p_rejection_reason" "text" DEFAULT NULL::"text", "p_processing_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_request record;
    v_company_id uuid;
    v_client_id uuid;
    v_result jsonb;
BEGIN
    -- Obtener company_id del usuario
    SELECT company_id INTO v_company_id
    FROM users
    WHERE auth_user_id = COALESCE(p_processing_user_id, auth.uid());
    
    -- Obtener solicitud
    SELECT * INTO v_request
    FROM gdpr_access_requests
    WHERE id = p_request_id
    AND company_id = v_company_id
    AND request_type = 'erasure';
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Solicitud de eliminación no encontrada o sin acceso'
        );
    END IF;
    
    -- Verificar que la solicitud no esté ya procesada
    IF v_request.processing_status IN ('completed', 'rejected') THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Solicitud ya fue procesada',
            'status', v_request.processing_status,
            'completed_at', v_request.completed_at
        );
    END IF;
    
    IF p_approve THEN
        -- Buscar cliente por email
        SELECT id INTO v_client_id
        FROM clients
        WHERE email = v_request.subject_email
        AND company_id = v_company_id
        LIMIT 1;
        
        IF v_client_id IS NOT NULL THEN
            -- Anonimizar el cliente
            v_result := anonymize_client_data(
                v_client_id,
                'gdpr_deletion_request_approved',
                p_processing_user_id
            );
            
            IF (v_result->>'success')::boolean THEN
                -- Actualizar solicitud a completada
                UPDATE gdpr_access_requests
                SET 
                    processing_status = 'completed',
                    verification_status = 'verified',
                    completed_at = now(),
                    response_data = v_result,
                    updated_at = now()
                WHERE id = p_request_id;
                
                RETURN jsonb_build_object(
                    'success', true,
                    'message', 'Solicitud de eliminación procesada y cliente anonimizado',
                    'request_id', p_request_id,
                    'client_anonymized', true,
                    'completed_at', now()
                );
            ELSE
                RETURN jsonb_build_object(
                    'success', false,
                    'error', 'Error al anonimizar cliente',
                    'details', v_result
                );
            END IF;
        ELSE
            -- Cliente no encontrado, marcar como completada igual
            UPDATE gdpr_access_requests
            SET 
                processing_status = 'completed',
                verification_status = 'verified',
                completed_at = now(),
                response_data = jsonb_build_object('message', 'Cliente no encontrado en el sistema'),
                updated_at = now()
            WHERE id = p_request_id;
            
            RETURN jsonb_build_object(
                'success', true,
                'message', 'Solicitud marcada como completada (cliente no encontrado)',
                'request_id', p_request_id
            );
        END IF;
    ELSE
        -- Rechazar solicitud
        UPDATE gdpr_access_requests
        SET 
            processing_status = 'rejected',
            verification_status = 'rejected',
            legal_basis_for_delay = p_rejection_reason,
            completed_at = now(),
            updated_at = now()
        WHERE id = p_request_id;
        
        RETURN jsonb_build_object(
            'success', true,
            'message', 'Solicitud rechazada',
            'request_id', p_request_id,
            'rejection_reason', p_rejection_reason,
            'completed_at', now()
        );
    END IF;
    
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'error_detail', SQLSTATE
    );
END;
$$;


ALTER FUNCTION "public"."process_gdpr_deletion_request"("p_request_id" "uuid", "p_approve" boolean, "p_rejection_reason" "text", "p_processing_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."process_gdpr_deletion_request"("p_request_id" "uuid", "p_approve" boolean, "p_rejection_reason" "text", "p_processing_user_id" "uuid") IS 'Procesa una solicitud de eliminación GDPR, aprobando o rechazando';



CREATE OR REPLACE FUNCTION "public"."recompute_ticket_total"("p_ticket_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
DECLARE
    v_total numeric := 0;
BEGIN
    SELECT COALESCE(SUM(COALESCE(total_price, price_per_unit * quantity)),0)
    INTO v_total
    FROM public.ticket_services
    WHERE ticket_id = p_ticket_id;

    UPDATE public.tickets
    SET total_amount = v_total, updated_at = timezone('utc', now())
    WHERE id = p_ticket_id;
END;
$$;


ALTER FUNCTION "public"."recompute_ticket_total"("p_ticket_id" "uuid") OWNER TO "postgres";


CREATE PROCEDURE "public"."refresh_analytics_materialized_views"()
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Presupuestos
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_quote_kpis_monthly;
  EXCEPTION WHEN undefined_table THEN NULL; END;
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_quote_top_items_monthly;
  EXCEPTION WHEN undefined_table THEN NULL; END;
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_quote_cube;
  EXCEPTION WHEN undefined_table THEN NULL; END;
  -- Facturas
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_invoice_kpis_monthly;
  EXCEPTION WHEN undefined_table THEN NULL; END;
  -- Tickets
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_ticket_kpis_monthly;
  EXCEPTION WHEN undefined_table THEN NULL; END;
END;
$$;


ALTER PROCEDURE "public"."refresh_analytics_materialized_views"() OWNER TO "postgres";


CREATE PROCEDURE "public"."refresh_quotes_materialized_views"()
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_quote_kpis_monthly;
  EXCEPTION WHEN undefined_table THEN NULL; END;
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_quote_top_items_monthly;
  EXCEPTION WHEN undefined_table THEN NULL; END;
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.mv_quote_cube;
  EXCEPTION WHEN undefined_table THEN NULL; END;
END;
$$;


ALTER PROCEDURE "public"."refresh_quotes_materialized_views"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."register_new_owner_from_invite"("p_invitation_token" "text", "p_company_name" "text", "p_company_nif" "text", "p_user_name" "text", "p_user_surname" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_invitation record;
  v_new_company_id uuid;
  v_user_id uuid;
  v_auth_user_id uuid;
  v_owner_role_id uuid;
BEGIN
  -- 1. Get current auth user
  v_auth_user_id := auth.uid();
  if v_auth_user_id is null then
    return json_build_object('success', false, 'error', 'Not authenticated');
  end if;

  -- 2. Validate Invitation
  select * into v_invitation
  from public.company_invitations
  where token = p_invitation_token
    and status = 'pending'
    and role = 'owner'; -- Must be an owner invite

  if v_invitation.id is null then
    return json_build_object('success', false, 'error', 'Invitation not found or invalid');
  end if;

  -- 3. Get Owner Role ID
  select id into v_owner_role_id from public.app_roles where name = 'owner';
  if v_owner_role_id is null then
      return json_build_object('success', false, 'error', 'Owner role configuration missing in database');
  end if;

  -- 4. Create New Company
  insert into public.companies (name, nif)
  values (p_company_name, p_company_nif)
  returning id into v_new_company_id;

  -- 5. Create/Update Public User
  -- Use ON CONFLICT to handle race condition with on_auth_user_created trigger
  insert into public.users (
      auth_user_id,
      company_id, 
      app_role_id, -- New column
      name,
      surname,
      email,
      active
  )
  values (
      v_auth_user_id,
      v_new_company_id,
      v_owner_role_id,
      p_user_name,
      p_user_surname,
      v_invitation.email,
      true
  )
  on conflict (auth_user_id) do update
  set 
      company_id = v_new_company_id,
      app_role_id = v_owner_role_id,
      name = p_user_name,
      surname = p_user_surname,
      active = true,
      updated_at = now()
  returning id into v_user_id;

  -- 6. Insert into Company Members (Multi-Tenancy)
  insert into public.company_members (
      user_id,
      company_id,
      role_id, -- New column
      role,    -- Legacy column (REQUIRED per NOT NULL constraint)
      status
  ) values (
      v_user_id,
      v_new_company_id,
      v_owner_role_id,
      'owner', -- Explicitly set legacy role
      'active'
  )
  on conflict (user_id, company_id) do update
  set 
    role_id = v_owner_role_id, 
    role = 'owner', 
    status = 'active', 
    updated_at = now();

  -- 7. Mark Invitation as Accepted
  update public.company_invitations
  set 
    status = 'accepted',
    responded_at = now()
  where id = v_invitation.id;

  return json_build_object(
    'success', true,
    'company_id', v_new_company_id,
    'user_id', v_user_id
  );

exception when others then
  return json_build_object('success', false, 'error', SQLERRM);
end;
$$;


ALTER FUNCTION "public"."register_new_owner_from_invite"("p_invitation_token" "text", "p_company_name" "text", "p_company_nif" "text", "p_user_name" "text", "p_user_surname" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reject_client_consent"("p_token" "uuid", "p_ip" "text", "p_user_agent" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_client_id uuid;
BEGIN
    SELECT id INTO v_client_id
    FROM public.clients
    WHERE invitation_token = p_token
    LIMIT 1;

    IF v_client_id IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Invalid or expired token');
    END IF;

    UPDATE public.clients
    SET
        consent_status = 'rejected',
        marketing_consent = false,
        consent_date = NOW(),
        consent_ip = p_ip,
        invitation_status = 'completed',
        invitation_token = NULL,
        updated_at = NOW()
    WHERE id = v_client_id;

    RETURN jsonb_build_object('success', true);
END;
$$;


ALTER FUNCTION "public"."reject_client_consent"("p_token" "uuid", "p_ip" "text", "p_user_agent" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."remove_or_deactivate_client_rpc"("p_client_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_user_id uuid := auth.uid();
    v_company_id uuid;
    v_client_company_id uuid;
    v_client_meta jsonb;
    v_invoice_count int;
    v_quote_count int;
    v_ticket_count int;
    v_action text;
BEGIN
    -- 1. Resolve Admin/Staff Company ID
    SELECT company_id INTO v_company_id
    FROM public.users
    WHERE auth_user_id = v_user_id
      AND active = true
    LIMIT 1;

    IF v_company_id IS NULL THEN
        RAISE EXCEPTION 'User not authorized or no company found';
    END IF;

    -- 2. Fetch Client to verify ownership and get metadata
    SELECT company_id, metadata INTO v_client_company_id, v_client_meta
    FROM public.clients
    WHERE id = p_client_id;

    IF v_client_company_id IS NULL THEN
        RAISE EXCEPTION 'Client not found';
    END IF;

    IF v_client_company_id != v_company_id THEN
        RAISE EXCEPTION 'Not allowed to remove client from another company';
    END IF;

    -- 3. Count Active Invoices (not cancelled, not deleted)
    SELECT count(*) INTO v_invoice_count
    FROM public.invoices
    WHERE client_id = p_client_id
      AND company_id = v_company_id
      AND deleted_at IS NULL
      AND status != 'cancelled';

    -- 4. Logic: Deactivate OR Delete
    IF v_invoice_count > 0 THEN
        -- Deactivate
        v_action := 'deactivated';
        
        -- Update metadata with retention info
        v_client_meta := v_client_meta || jsonb_build_object(
            'retention_invoice_count', v_invoice_count,
            'retention_last_action', 'deactivated',
            'retention_action_at', now(),
            'retention_reason', 'invoices_present'
        );

        UPDATE public.clients
        SET is_active = false,
            metadata = v_client_meta,
            updated_at = now()
        WHERE id = p_client_id;

    ELSE
        -- Hard Delete
        v_action := 'deleted';

        -- Delete Quotes
        DELETE FROM public.quotes
        WHERE client_id = p_client_id
          AND company_id = v_company_id;
        
        -- Delete Tickets (soft delete usually, but EF does hard delete)
        -- The EF code attempts a DELETE on tickets.
        DELETE FROM public.tickets
        WHERE client_id = p_client_id
          AND company_id = v_company_id;

        -- Delete Client
        DELETE FROM public.clients
        WHERE id = p_client_id;
    END IF;

    -- Return JSON result similar to EF
    RETURN jsonb_build_object(
        'ok', true,
        'action', v_action,
        'invoiceCount', v_invoice_count,
        'clientId', p_client_id
    );
END;
$$;


ALTER FUNCTION "public"."remove_or_deactivate_client_rpc"("p_client_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reorder_stages"("stage_ids" "uuid"[]) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
BEGIN
  -- 1. Get company_id
  SELECT company_id INTO v_company_id 
  FROM public.users 
  WHERE auth_user_id = auth.uid();

  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'User does not belong to a company';
  END IF;

  -- 2. Validate all stages are generic (company_id IS NULL)
  -- The Edge Function checked this, so we should too to maintain behavior.
  IF EXISTS (
    SELECT 1 
    FROM ticket_stages 
    WHERE id = ANY(stage_ids) 
      AND company_id IS NOT NULL
  ) THEN
    RAISE EXCEPTION 'Only generic stages can be reordered via this endpoint';
  END IF;

  -- 3. Upsert positions
  -- We use unnest with ordinality to get the index. 
  -- JS sends array, index 0..N. unnest returns 1..N. So we subtract 1.
  INSERT INTO company_stage_order (company_id, stage_id, position)
  SELECT 
    v_company_id, 
    elem_id, 
    (idx - 1)
  FROM unnest(stage_ids) WITH ORDINALITY AS t(elem_id, idx)
  ON CONFLICT (company_id, stage_id) 
  DO UPDATE SET position = EXCLUDED.position;

END;
$$;


ALTER FUNCTION "public"."reorder_stages"("stage_ids" "uuid"[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."restore_original_invoice_on_void"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_original_invoice_id UUID;
  v_has_other_valid_rectifications BOOLEAN;
BEGIN
  -- Solo actuar si la factura está siendo anulada (void)
  IF NEW.status = 'void' AND OLD.status != 'void' THEN
    
    -- Verificar si esta factura es una rectificativa
    IF NEW.rectifies_invoice_id IS NOT NULL THEN
      v_original_invoice_id := NEW.rectifies_invoice_id;
      
      -- Comprobar si hay otras facturas rectificativas válidas para esta factura original
      SELECT EXISTS(
        SELECT 1 
        FROM public.invoices 
        WHERE rectifies_invoice_id = v_original_invoice_id 
          AND id != NEW.id
          AND status NOT IN ('void', 'cancelled')
      ) INTO v_has_other_valid_rectifications;
      
      -- Si no hay otras rectificativas válidas, restaurar el estado de la original
      IF NOT v_has_other_valid_rectifications THEN
        UPDATE public.invoices
        SET 
          status = 'approved',
          updated_at = NOW()
        WHERE id = v_original_invoice_id
          AND status = 'rectified';
          
        RAISE NOTICE 'Factura original % restaurada a estado approved', v_original_invoice_id;
      END IF;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."restore_original_invoice_on_void"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."restore_original_invoice_on_void"() IS 'Restaura el estado de una factura original de "rectified" a "approved" cuando se anula su factura rectificativa, permitiendo crear una nueva rectificación';



CREATE OR REPLACE FUNCTION "public"."rls_auto_enable"() RETURNS "event_trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN
    SELECT *
    FROM pg_event_trigger_ddl_commands()
    WHERE command_tag IN ('CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO')
      AND object_type IN ('table','partitioned table')
  LOOP
     IF cmd.schema_name IS NOT NULL AND cmd.schema_name IN ('public') AND cmd.schema_name NOT IN ('pg_catalog','information_schema') AND cmd.schema_name NOT LIKE 'pg_toast%' AND cmd.schema_name NOT LIKE 'pg_temp%' THEN
      BEGIN
        EXECUTE format('alter table if exists %s enable row level security', cmd.object_identity);
        RAISE LOG 'rls_auto_enable: enabled RLS on %', cmd.object_identity;
      EXCEPTION
        WHEN OTHERS THEN
          RAISE LOG 'rls_auto_enable: failed to enable RLS on %', cmd.object_identity;
      END;
     ELSE
        RAISE LOG 'rls_auto_enable: skip % (either system schema or not in enforced list: %.)', cmd.object_identity, cmd.schema_name;
     END IF;
  END LOOP;
END;
$$;


ALTER FUNCTION "public"."rls_auto_enable"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."safe_delete_ticket_stage"("p_stage_id" "uuid", "p_company_id" "uuid", "p_reassign_to" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_stage_company uuid;
  v_reassign_company uuid;
  v_exists integer;
  v_reassigned integer := 0;
  v_workflow text;
  v_stagecat text;
  v_visible_same_cat integer := 0;
  v_candidate_system_stage uuid;
  v_cat text;
  v_required_cats text[] := ARRAY['waiting','analysis','action','final','cancel'];
BEGIN
  IF p_stage_id IS NULL THEN
    RAISE EXCEPTION 'p_stage_id is required';
  END IF;

  IF p_company_id IS NULL THEN
    RAISE EXCEPTION 'p_company_id is required';
  END IF;

  -- Validate the stage exists and belongs to the company
  SELECT company_id INTO v_stage_company
  FROM ticket_stages
  WHERE id = p_stage_id
    AND deleted_at IS NULL
  LIMIT 1;

  IF v_stage_company IS NULL THEN
    RAISE EXCEPTION 'Stage % not found or already deleted', p_stage_id;
  END IF;

  IF v_stage_company <> p_company_id THEN
    RAISE EXCEPTION 'Stage % does not belong to company %', p_stage_id, p_company_id;
  END IF;

  -- Get categories of the stage being deleted
  SELECT workflow_category, stage_category
    INTO v_workflow, v_stagecat
  FROM ticket_stages
  WHERE id = p_stage_id
    AND deleted_at IS NULL;

  -- Count how many VISIBLE stages of the same workflow category remain (excluding the one to delete)
  -- Visible for company = owned by company OR (system AND not hidden by company)
  SELECT COUNT(*) INTO v_visible_same_cat
  FROM ticket_stages s
  WHERE s.deleted_at IS NULL
    AND s.id <> p_stage_id
    AND (
      s.company_id = p_company_id
      OR (
        s.company_id IS NULL
        AND NOT EXISTS (
          SELECT 1 FROM hidden_stages h
           WHERE h.company_id = p_company_id AND h.stage_id = s.id
        )
      )
    )
    AND (
      (v_workflow IS NOT NULL AND s.workflow_category::text = v_workflow)
      OR (v_workflow IS NULL AND s.stage_category::text = v_stagecat)
    );

  -- If none remain, try to auto-unhide a matching system stage to preserve coverage
  IF v_visible_same_cat = 0 THEN
    SELECT s.id INTO v_candidate_system_stage
    FROM ticket_stages s
    WHERE s.deleted_at IS NULL
      AND s.company_id IS NULL
      AND (
        (v_workflow IS NOT NULL AND s.workflow_category::text = v_workflow)
        OR (v_workflow IS NULL AND s.stage_category::text = v_stagecat)
      )
      AND EXISTS (
        SELECT 1 FROM hidden_stages h
         WHERE h.company_id = p_company_id AND h.stage_id = s.id
      )
    LIMIT 1;

    IF v_candidate_system_stage IS NOT NULL THEN
      DELETE FROM hidden_stages
       WHERE company_id = p_company_id AND stage_id = v_candidate_system_stage;

      -- Recount
      SELECT COUNT(*) INTO v_visible_same_cat
      FROM ticket_stages s
      WHERE s.deleted_at IS NULL
        AND s.id <> p_stage_id
        AND (
          s.company_id = p_company_id
          OR (
            s.company_id IS NULL
            AND NOT EXISTS (
              SELECT 1 FROM hidden_stages h
               WHERE h.company_id = p_company_id AND h.stage_id = s.id
            )
          )
        )
        AND (
          (v_workflow IS NOT NULL AND s.workflow_category::text = v_workflow)
          OR (v_workflow IS NULL AND s.stage_category::text = v_stagecat)
        );
    END IF;
  END IF;

  IF v_visible_same_cat = 0 THEN
    RAISE EXCEPTION 'Debe existir al menos un estado visible de la categoría % para la empresa % (activa algún estado del sistema o crea uno nuevo)',
      COALESCE(v_workflow, v_stagecat), p_company_id;
  END IF;

  -- Ensure global coverage across required workflow categories
  FOREACH v_cat IN ARRAY v_required_cats LOOP
    SELECT COUNT(*) INTO v_visible_same_cat
    FROM ticket_stages s
    WHERE s.deleted_at IS NULL
      AND s.id <> p_stage_id
      AND (
        s.company_id = p_company_id
        OR (
          s.company_id IS NULL
          AND NOT EXISTS (
            SELECT 1 FROM hidden_stages h
             WHERE h.company_id = p_company_id AND h.stage_id = s.id
          )
        )
      )
      AND s.workflow_category::text = v_cat;

    IF v_visible_same_cat = 0 THEN
      SELECT s.id INTO v_candidate_system_stage
      FROM ticket_stages s
      WHERE s.deleted_at IS NULL
        AND s.company_id IS NULL
        AND s.workflow_category::text = v_cat
        AND EXISTS (
          SELECT 1 FROM hidden_stages h
           WHERE h.company_id = p_company_id AND h.stage_id = s.id
        )
      LIMIT 1;

      IF v_candidate_system_stage IS NOT NULL THEN
        DELETE FROM hidden_stages
         WHERE company_id = p_company_id AND stage_id = v_candidate_system_stage;

        SELECT COUNT(*) INTO v_visible_same_cat
        FROM ticket_stages s
        WHERE s.deleted_at IS NULL
          AND s.id <> p_stage_id
          AND (
            s.company_id = p_company_id
            OR (
              s.company_id IS NULL
              AND NOT EXISTS (
                SELECT 1 FROM hidden_stages h
                 WHERE h.company_id = p_company_id AND h.stage_id = s.id
              )
            )
          )
          AND s.workflow_category::text = v_cat;
      END IF;
    END IF;

    IF v_visible_same_cat = 0 THEN
      RAISE EXCEPTION 'Debe existir al menos un estado de la categoría % visible para la empresa %', v_cat, p_company_id;
    END IF;
  END LOOP;

  -- If provided, validate reassign stage
  IF p_reassign_to IS NOT NULL THEN
    IF p_reassign_to = p_stage_id THEN
      RAISE EXCEPTION 'p_reassign_to cannot be the same as p_stage_id';
    END IF;

    SELECT company_id INTO v_reassign_company
    FROM ticket_stages
    WHERE id = p_reassign_to
      AND deleted_at IS NULL
    LIMIT 1;

    IF v_reassign_company IS NULL THEN
      RAISE EXCEPTION 'Reassign stage % not found or deleted', p_reassign_to;
    END IF;

    IF v_reassign_company <> p_company_id THEN
      RAISE EXCEPTION 'Reassign stage % belongs to a different company', p_reassign_to;
    END IF;
  END IF;

  -- Check if there are tickets referencing the stage
  SELECT COUNT(*) INTO v_exists
  FROM tickets
  WHERE stage_id = p_stage_id
    AND company_id = p_company_id
    AND deleted_at IS NULL;

  IF v_exists > 0 THEN
    IF p_reassign_to IS NULL THEN
      RAISE EXCEPTION 'Stage % is referenced by % tickets. Provide p_reassign_to to reassign before delete.', p_stage_id, v_exists;
    END IF;

    UPDATE tickets
    SET stage_id = p_reassign_to,
        updated_at = NOW()
    WHERE stage_id = p_stage_id
      AND company_id = p_company_id
      AND deleted_at IS NULL;

    GET DIAGNOSTICS v_reassigned = ROW_COUNT;
  END IF;

  -- Clean references in hidden_stages
  IF EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema = 'public' AND table_name = 'hidden_stages'
  ) THEN
    DELETE FROM hidden_stages
    WHERE stage_id = p_stage_id
      AND company_id = p_company_id;
  END IF;

  -- Finally, delete the stage
  DELETE FROM ticket_stages
  WHERE id = p_stage_id
    AND company_id = p_company_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Failed to delete stage % (not found or already deleted)', p_stage_id;
  END IF;

  RETURN jsonb_build_object(
    'deleted', true,
    'reassignedTickets', v_reassigned,
    'stageId', p_stage_id,
    'reassignedTo', p_reassign_to,
    'companyId', p_company_id,
    'deletedAt', NOW()
  );
END;
$$;


ALTER FUNCTION "public"."safe_delete_ticket_stage"("p_stage_id" "uuid", "p_company_id" "uuid", "p_reassign_to" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."search_customers"("search_term" "text", "user_id" "uuid") RETURNS TABLE("id" "uuid", "nombre" character varying, "apellidos" character varying, "email" character varying, "telefono" character varying, "created_at" timestamp with time zone, "rank" real)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.id,
        c.nombre,
        c.apellidos,
        c.email,
        c.telefono,
        c.created_at,
        ts_rank(c.search_vector, plainto_tsquery('spanish', search_term)) as rank
    FROM public.customers c
    WHERE 
        c.usuario_id = user_id AND
        c.search_vector @@ plainto_tsquery('spanish', search_term)
    ORDER BY rank DESC, c.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."search_customers"("search_term" "text", "user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."search_customers_dev"("target_user_id" "uuid", "search_term" "text") RETURNS TABLE("id" "uuid", "nombre" character varying, "apellidos" character varying, "email" character varying, "telefono" character varying, "created_at" timestamp with time zone, "rank" real)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    -- Si no hay término de búsqueda, devolver todos los clientes del usuario
    IF search_term IS NULL OR search_term = '' THEN
        RETURN QUERY
        SELECT 
            c.id,
            c.nombre,
            c.apellidos,
            c.email,
            c.telefono,
            c.created_at,
            1.0::real as rank
        FROM public.customers c
        WHERE c.usuario_id = target_user_id
        ORDER BY c.created_at DESC;
    ELSE
        -- Búsqueda con texto completo
        RETURN QUERY
        SELECT 
            c.id,
            c.nombre,
            c.apellidos,
            c.email,
            c.telefono,
            c.created_at,
            ts_rank(c.search_vector, plainto_tsquery('spanish', search_term)) as rank
        FROM public.customers c
        WHERE 
            c.usuario_id = target_user_id AND
            c.search_vector @@ plainto_tsquery('spanish', search_term)
        ORDER BY rank DESC, c.created_at DESC;
    END IF;
END;
$$;


ALTER FUNCTION "public"."search_customers_dev"("target_user_id" "uuid", "search_term" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."search_customers_dev"("target_user_id" "uuid", "search_term" "text") IS 'Función RPC para búsqueda de clientes en modo desarrollo';



CREATE OR REPLACE FUNCTION "public"."set_current_company_context"("company_uuid" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
  PERFORM set_config('app.current_company_id', company_uuid::text, false);
END;
$$;


ALTER FUNCTION "public"."set_current_company_context"("company_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_initial_ticket_stage"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_initial_stage_id uuid;
BEGIN
    -- Find the stage with the lowest position for this company
    SELECT id INTO v_initial_stage_id
    FROM public.ticket_stages
    WHERE company_id = NEW.company_id
      AND deleted_at IS NULL
    ORDER BY position ASC
    LIMIT 1;

    -- If found, enforce it
    IF v_initial_stage_id IS NOT NULL THEN
        NEW.stage_id := v_initial_stage_id;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_initial_ticket_stage"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_invoice_month"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.invoice_month := DATE_TRUNC('month', COALESCE(NEW.invoice_date, NEW.created_at))::date;
  RETURN NEW;
END; $$;


ALTER FUNCTION "public"."set_invoice_month"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_quote_month"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.quote_month := DATE_TRUNC('month', COALESCE(NEW.quote_date, NEW.created_at))::date;
  RETURN NEW;
END; $$;


ALTER FUNCTION "public"."set_quote_month"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_ticket_month"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.ticket_month := DATE_TRUNC('month', NEW.created_at)::date;
  RETURN NEW;
END; $$;


ALTER FUNCTION "public"."set_ticket_month"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_ticket_number"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    -- Only assign if not provided (or if 0/default)
    -- We ignore the global sequence default if we want per-company
    IF NEW.ticket_number IS NULL OR NEW.ticket_number = 0 THEN
        IF NEW.company_id IS NOT NULL THEN
            NEW.ticket_number := public.get_next_ticket_number(NEW.company_id);
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_ticket_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END; $$;


ALTER FUNCTION "public"."set_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_updated_at_ticket_products"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_updated_at_ticket_products"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_updated_at_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_updated_at_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_client_profile"() RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
declare
  v_count int;
begin
  UPDATE public.clients c
  SET 
    auth_user_id = auth.uid(),
    updated_at = now()
  FROM public.users u
  WHERE c.email = u.email 
    AND u.auth_user_id = auth.uid()
    AND (c.auth_user_id IS NULL OR c.auth_user_id != auth.uid());
    
  GET DIAGNOSTICS v_count = ROW_COUNT;
  
  return json_build_object('success', true, 'updated_count', v_count);
end;
$$;


ALTER FUNCTION "public"."sync_client_profile"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_gdpr_to_client_consent"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Check if this is a Marketing consent record
  -- We check consent_type 'marketing' OR purpose containing 'marketing'
  IF NEW.consent_type = 'marketing' OR NEW.purpose ILIKE '%marketing%' THEN
    
    -- Update matching client(s)
    UPDATE public.clients
    SET marketing_consent = NEW.consent_given,
        updated_at = now()
    WHERE email = NEW.subject_email 
      AND company_id = NEW.company_id;
      
    -- Note: If multiple clients with same email, all get updated. Correct.
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_gdpr_to_client_consent"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_ticket_tags_from_services"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
    -- Cuando se crea un ticket_service, sincronizar tags del servicio al ticket
    IF TG_OP = 'INSERT' THEN
        -- Agregar tags del servicio al ticket si no existen
        INSERT INTO tickets_tags (ticket_id, tag_id)
        SELECT 
            NEW.ticket_id,
            st.tag_id
        FROM services_tags st
        JOIN global_tags gt ON st.tag_id = gt.id
        WHERE st.service_id = NEW.service_id
        AND NOT EXISTS (
            SELECT 1 FROM tickets_tags tt 
            WHERE tt.ticket_id = NEW.ticket_id 
            AND tt.tag_id = st.tag_id
        );
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."sync_ticket_tags_from_services"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."toggle_stage_visibility"("p_stage_id" "uuid", "p_operation" "text", "p_reassign_to" "uuid" DEFAULT NULL::"uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
  v_user_id uuid;
  v_is_generic boolean;
  v_count_tickets int;
  v_target_category text;
  v_source_category text;
  v_target_visible boolean;
BEGIN
  -- 1. Resolve User and Company
  SELECT company_id, id INTO v_company_id, v_user_id
  FROM public.users
  WHERE auth_user_id = auth.uid();

  IF v_company_id IS NULL THEN
     -- Fallback to clients table
     SELECT company_id, id INTO v_company_id, v_user_id
     FROM public.clients
     WHERE auth_user_id = auth.uid();
  END IF;

  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'User not associated with a company';
  END IF;

  -- 2. Validate Stage is Generic
  SELECT (company_id IS NULL), workflow_category INTO v_is_generic, v_source_category
  FROM ticket_stages
  WHERE id = p_stage_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Stage not found';
  END IF;

  IF NOT v_is_generic THEN
    RAISE EXCEPTION 'Only generic stages can be modified via this endpoint';
  END IF;

  -- 3. Execute Operation
  IF p_operation = 'hide' THEN
    
    -- 3a. Check Coverage
    IF NOT check_stage_coverage_after_hide(v_company_id, p_stage_id) THEN
      RAISE EXCEPTION 'Hiding this stage would leave its workflow category without any visible stage';
    END IF;

    -- 3b. Check Tickets Usage
    SELECT COUNT(*) INTO v_count_tickets
    FROM tickets
    WHERE company_id = v_company_id AND stage_id = p_stage_id;

    IF v_count_tickets > 0 THEN
      IF p_reassign_to IS NULL THEN
         RAISE EXCEPTION 'Tickets reference this stage; reassignment required (% tickets)', v_count_tickets;
      END IF;

      -- Validate Reassign Target
      SELECT workflow_category INTO v_target_category
      FROM ticket_stages
      WHERE id = p_reassign_to;

      IF NOT FOUND THEN
        RAISE EXCEPTION 'Reassignment target not found';
      END IF;

      IF v_source_category != v_target_category THEN
        RAISE EXCEPTION 'Target stage must be in the same workflow category';
      END IF;

      -- Check if target is visible
      SELECT EXISTS (
        SELECT 1 FROM ticket_stages ts
        WHERE ts.id = p_reassign_to
          AND (
            ts.company_id = v_company_id
            OR (ts.company_id IS NULL AND NOT EXISTS (
              SELECT 1 FROM hidden_stages hs WHERE hs.company_id = v_company_id AND hs.stage_id = p_reassign_to
            ))
          )
      ) INTO v_target_visible;

      IF NOT v_target_visible THEN
        RAISE EXCEPTION 'Target stage is not visible for this company';
      END IF;

      -- Reassign Tickets
      UPDATE tickets
      SET stage_id = p_reassign_to
      WHERE company_id = v_company_id AND stage_id = p_stage_id;
    END IF;

    -- 3c. Perform Hide
    INSERT INTO hidden_stages (company_id, stage_id, hidden_by)
    VALUES (v_company_id, p_stage_id, v_user_id)
    ON CONFLICT (company_id, stage_id) DO NOTHING;
    
    RETURN json_build_object('result', 'hidden');

  ELSIF p_operation = 'unhide' THEN
    DELETE FROM hidden_stages
    WHERE company_id = v_company_id AND stage_id = p_stage_id;
    
    RETURN json_build_object('result', 'unhidden');

  ELSE
    RAISE EXCEPTION 'Invalid operation: %', p_operation;
  END IF;
END;
$$;


ALTER FUNCTION "public"."toggle_stage_visibility"("p_stage_id" "uuid", "p_operation" "text", "p_reassign_to" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."toggle_unit_visibility"("p_unit_id" "uuid", "p_operation" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
  v_user_id uuid;
  v_is_generic boolean;
BEGIN
  -- Resolve User
  SELECT company_id, id INTO v_company_id, v_user_id
  FROM public.users
  WHERE auth_user_id = auth.uid();

  IF v_company_id IS NULL THEN
     SELECT company_id, id INTO v_company_id, v_user_id
     FROM public.clients
     WHERE auth_user_id = auth.uid();
  END IF;

  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'User not associated with a company';
  END IF;

  -- Validate Unit
  SELECT (company_id IS NULL) INTO v_is_generic
  FROM service_units
  WHERE id = p_unit_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Unit not found';
  END IF;

  IF NOT v_is_generic THEN
    RAISE EXCEPTION 'Only generic units can be hidden';
  END IF;

  -- Execute
  IF p_operation = 'hide' THEN
    -- Check if hidden_units table exists (Implicit, but if it fails, PLPGSQL will raise error)
    INSERT INTO hidden_units (company_id, unit_id, hidden_by)
    VALUES (v_company_id, p_unit_id, v_user_id)
    ON CONFLICT (company_id, unit_id) DO NOTHING;
    RETURN json_build_object('result', 'hidden');

  ELSIF p_operation = 'unhide' THEN
    DELETE FROM hidden_units
    WHERE company_id = v_company_id AND unit_id = p_unit_id;
    RETURN json_build_object('result', 'unhidden');

  ELSE
    RAISE EXCEPTION 'Invalid operation';
  END IF;
END;
$$;


ALTER FUNCTION "public"."toggle_unit_visibility"("p_unit_id" "uuid", "p_operation" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_audit_access_requests"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_user_id uuid;
    v_company_id uuid;
BEGIN
    -- Obtener user_id y company_id
    SELECT u.id, u.company_id INTO v_user_id, v_company_id
    FROM users u
    WHERE u.auth_user_id = auth.uid()
    LIMIT 1;
    
    -- Si no hay usuario, no auditar
    IF v_user_id IS NULL THEN
        IF TG_OP = 'DELETE' THEN
            RETURN OLD;
        ELSE
            RETURN NEW;
        END IF;
    END IF;
    
    -- Registrar cambios en solicitudes GDPR
    IF TG_OP = 'INSERT' THEN
        INSERT INTO gdpr_audit_log (
            user_id,
            company_id,
            action_type,
            table_name,
            record_id,
            subject_email,
            purpose,
            new_values,
            created_at
        ) VALUES (
            v_user_id,
            COALESCE(NEW.company_id, v_company_id),
            'access_request',
            'gdpr_access_requests',
            NEW.id,
            NEW.subject_email,
            'GDPR request created: ' || NEW.request_type,
            jsonb_build_object(
                'request_type', NEW.request_type,
                'processing_status', NEW.processing_status,
                'deadline_date', NEW.deadline_date
            ),
            now()
        );
    ELSIF TG_OP = 'UPDATE' THEN
        -- Solo auditar cambios de estado
        IF OLD.processing_status != NEW.processing_status OR
           OLD.verification_status != NEW.verification_status THEN
            INSERT INTO gdpr_audit_log (
                user_id,
                company_id,
                action_type,
                table_name,
                record_id,
                subject_email,
                purpose,
                old_values,
                new_values,
                created_at
            ) VALUES (
                v_user_id,
                COALESCE(NEW.company_id, v_company_id),
                'access_request',
                'gdpr_access_requests',
                NEW.id,
                NEW.subject_email,
                'GDPR request status updated',
                jsonb_build_object(
                    'processing_status', OLD.processing_status,
                    'verification_status', OLD.verification_status
                ),
                jsonb_build_object(
                    'processing_status', NEW.processing_status,
                    'verification_status', NEW.verification_status,
                    'completed_at', NEW.completed_at
                ),
                now()
            );
        END IF;
    END IF;
    
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
    
EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Error en audit log de access_requests: %', SQLERRM;
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION "public"."trigger_audit_access_requests"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_audit_consent_records"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_user_id uuid;
    v_company_id uuid;
BEGIN
    -- Obtener user_id y company_id
    SELECT u.id, u.company_id INTO v_user_id, v_company_id
    FROM users u
    WHERE u.auth_user_id = auth.uid()
    LIMIT 1;
    
    -- Si no hay usuario, no auditar
    IF v_user_id IS NULL THEN
        IF TG_OP = 'DELETE' THEN
            RETURN OLD;
        ELSE
            RETURN NEW;
        END IF;
    END IF;
    
    -- Registrar cambio de consentimiento
    IF TG_OP = 'INSERT' THEN
        INSERT INTO gdpr_audit_log (
            user_id,
            company_id,
            action_type,
            table_name,
            record_id,
            subject_email,
            purpose,
            new_values,
            created_at
        ) VALUES (
            v_user_id,
            COALESCE(NEW.company_id, v_company_id),
            'consent',
            'gdpr_consent_records',
            NEW.id,
            NEW.subject_email,
            'New consent record: ' || NEW.consent_type,
            jsonb_build_object(
                'consent_type', NEW.consent_type,
                'consent_given', NEW.consent_given,
                'consent_method', NEW.consent_method,
                'purpose', NEW.purpose
            ),
            now()
        );
    ELSIF TG_OP = 'UPDATE' THEN
        -- Solo auditar si cambia el consentimiento o se retira
        IF OLD.consent_given != NEW.consent_given OR 
           (OLD.withdrawn_at IS NULL AND NEW.withdrawn_at IS NOT NULL) THEN
            INSERT INTO gdpr_audit_log (
                user_id,
                company_id,
                action_type,
                table_name,
                record_id,
                subject_email,
                purpose,
                old_values,
                new_values,
                created_at
            ) VALUES (
                v_user_id,
                COALESCE(NEW.company_id, v_company_id),
                'consent',
                'gdpr_consent_records',
                NEW.id,
                NEW.subject_email,
                CASE 
                    WHEN NEW.withdrawn_at IS NOT NULL THEN 'Consent withdrawn'
                    ELSE 'Consent status changed'
                END,
                jsonb_build_object(
                    'consent_given', OLD.consent_given,
                    'withdrawn_at', OLD.withdrawn_at
                ),
                jsonb_build_object(
                    'consent_given', NEW.consent_given,
                    'withdrawn_at', NEW.withdrawn_at
                ),
                now()
            );
        END IF;
    END IF;
    
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
    
EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Error en audit log de consent_records: %', SQLERRM;
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION "public"."trigger_audit_consent_records"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_init_mail_folders"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    PERFORM initialize_mail_account_folders(NEW.id);
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_init_mail_folders"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_ticket_services_upsert"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
    -- On INSERT or UPDATE: ensure company_id is set using tickets.company_id if null
    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
        IF NEW.company_id IS NULL THEN
            UPDATE public.tickets SET updated_at = timezone('utc', now()) WHERE id = NEW.ticket_id; -- ensure ticket exists
            SELECT t.company_id INTO NEW.company_id FROM public.tickets t WHERE t.id = NEW.ticket_id;
        END IF;
        PERFORM public.recompute_ticket_total(NEW.ticket_id);
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        PERFORM public.recompute_ticket_total(OLD.ticket_id);
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."trigger_ticket_services_upsert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_update_last_accessed"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
    -- Solo actualizar en SELECT (cuando se lee el registro)
    -- Incrementar contador de accesos
    UPDATE clients
    SET 
        last_accessed_at = now(),
        access_count = COALESCE(access_count, 0) + 1
    WHERE id = NEW.id
    AND (last_accessed_at IS NULL OR last_accessed_at < now() - INTERVAL '1 hour');
    -- Solo actualizar si pasó más de 1 hora desde el último acceso
    
    RETURN NEW;
    
EXCEPTION WHEN OTHERS THEN
    -- No bloquear si falla
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_update_last_accessed"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_client_consent"("p_client_id" "uuid", "p_consent_type" "text", "p_consent_given" boolean, "p_consent_method" "text" DEFAULT 'manual'::"text", "p_consent_evidence" "jsonb" DEFAULT '{}'::"jsonb", "p_updating_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_client record;
    v_company_id uuid;
    v_old_consent boolean;
    v_consent_record_id uuid;
BEGIN
    -- Validar tipo de consentimiento
    IF p_consent_type NOT IN ('marketing', 'data_processing') THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Tipo de consentimiento inválido. Valores permitidos: marketing, data_processing'
        );
    END IF;
    
    -- Verificar acceso
    SELECT company_id INTO v_company_id
    FROM users
    WHERE auth_user_id = COALESCE(p_updating_user_id, auth.uid());
    
    -- Obtener cliente
    SELECT * INTO v_client
    FROM clients
    WHERE id = p_client_id
    AND company_id = v_company_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Cliente no encontrado o sin acceso'
        );
    END IF;
    
    -- Actualizar consentimiento en tabla clients
    IF p_consent_type = 'marketing' THEN
        v_old_consent := v_client.marketing_consent;
        
        UPDATE clients
        SET 
            marketing_consent = p_consent_given,
            marketing_consent_date = now(),
            marketing_consent_method = p_consent_method,
            updated_at = now()
        WHERE id = p_client_id;
    ELSE -- data_processing
        v_old_consent := v_client.data_processing_consent;
        
        UPDATE clients
        SET 
            data_processing_consent = p_consent_given,
            data_processing_consent_date = now(),
            updated_at = now()
        WHERE id = p_client_id;
    END IF;
    
    -- Crear registro en gdpr_consent_records
    INSERT INTO gdpr_consent_records (
        subject_id,
        subject_email,
        consent_type,
        purpose,
        consent_given,
        consent_method,
        consent_evidence,
        company_id,
        processed_by,
        legal_basis,
        created_at,
        updated_at
    ) VALUES (
        p_client_id,
        v_client.email,
        p_consent_type,
        CASE 
            WHEN p_consent_type = 'marketing' THEN 'Consentimiento para comunicaciones comerciales'
            ELSE 'Consentimiento para procesamiento de datos personales'
        END,
        p_consent_given,
        p_consent_method,
        p_consent_evidence,
        v_company_id,
        COALESCE(p_updating_user_id, auth.uid()),
        CASE 
            WHEN p_consent_type = 'marketing' THEN 'consent'
            ELSE 'contract'
        END,
        now(),
        now()
    )
    RETURNING id INTO v_consent_record_id;
    
    -- Registrar en audit log
    INSERT INTO gdpr_audit_log (
        user_id,
        company_id,
        action_type,
        table_name,
        record_id,
        subject_email,
        purpose,
        old_values,
        new_values,
        created_at
    ) VALUES (
        COALESCE(p_updating_user_id, auth.uid()),
        v_company_id,
        'consent',
        'clients',
        p_client_id,
        v_client.email,
        'Consent update: ' || p_consent_type,
        jsonb_build_object(p_consent_type || '_consent', v_old_consent),
        jsonb_build_object(p_consent_type || '_consent', p_consent_given),
        now()
    );
    
    RETURN jsonb_build_object(
        'success', true,
        'message', 'Consentimiento actualizado correctamente',
        'client_id', p_client_id,
        'consent_type', p_consent_type,
        'consent_given', p_consent_given,
        'consent_record_id', v_consent_record_id,
        'updated_at', now()
    );
    
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'error_detail', SQLSTATE
    );
END;
$$;


ALTER FUNCTION "public"."update_client_consent"("p_client_id" "uuid", "p_consent_type" "text", "p_consent_given" boolean, "p_consent_method" "text", "p_consent_evidence" "jsonb", "p_updating_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_client_consent"("p_client_id" "uuid", "p_consent_type" "text", "p_consent_given" boolean, "p_consent_method" "text", "p_consent_evidence" "jsonb", "p_updating_user_id" "uuid") IS 'Actualiza el consentimiento de un cliente y crea registro en gdpr_consent_records';



CREATE OR REPLACE FUNCTION "public"."update_client_stats_on_change"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- 1. Prevent recursion (already present)
  -- 2. Prevent updating stats if we are Anonymizing the user (or user is anonymized)
  -- This prevents the 'double audit log' issue where Anonymization Update -> Fires Stats Update -> Fires Audit Log again
  IF (NEW.email LIKE 'anonymized-%@deleted.com' OR NEW.name = 'ANONYMIZED') THEN
    RETURN NEW;
  END IF;

  -- We ONLY want to update stats here if it's a top-level update (depth 1)
  IF TG_OP = 'UPDATE' AND pg_trigger_depth() = 1 THEN
    UPDATE public.clients
    SET
      last_accessed_at = now(),
      access_count = COALESCE(access_count, 0) + 1
    WHERE id = NEW.id;
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."update_client_stats_on_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_company_user"("p_user_id" "uuid", "p_role" "text" DEFAULT NULL::"text", "p_active" boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    caller_id uuid;
    caller_role text;
    caller_company_id uuid;
    
    target_company_id uuid;
    target_role text;
    target_active boolean;
    
    v_new_role_id uuid;
BEGIN
    -- Get Caller Context
    SELECT u.id, ar.name, cm.company_id
    INTO caller_id, caller_role, caller_company_id
    FROM public.users u
    JOIN public.company_members cm ON u.id = cm.user_id
    JOIN public.app_roles ar ON cm.role_id = ar.id
    WHERE u.auth_user_id = auth.uid()
      AND cm.status = 'active'
    LIMIT 1;

    IF caller_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Usuario no encontrado o inactivo');
    END IF;

    -- Get Target Context
    SELECT u.company_id, ar.name, u.active
    INTO target_company_id, target_role, target_active
    FROM public.users u
    LEFT JOIN public.company_members cm ON u.id = cm.user_id AND cm.company_id = caller_company_id
    LEFT JOIN public.app_roles ar ON cm.role_id = ar.id
    WHERE u.id = p_user_id;

    IF target_company_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Usuario objetivo no encontrado');
    END IF;

    -- Check Same Company
    IF caller_company_id != target_company_id THEN
        RETURN json_build_object('success', false, 'error', 'No tienes permisos para modificar usuarios de otra empresa');
    END IF;

    -- Check Caller Permissions
    IF caller_role NOT IN ('owner', 'admin') THEN
        RETURN json_build_object('success', false, 'error', 'Solo owner o admin pueden modificar usuarios');
    END IF;

    -- UPDATE ROLE
    IF p_role IS NOT NULL THEN
        -- Get new role ID
        SELECT id INTO v_new_role_id FROM public.app_roles WHERE name = p_role;
        IF v_new_role_id IS NULL THEN
            RETURN json_build_object('success', false, 'error', 'Rol no válido');
        END IF;

        -- Validations
        IF p_role = 'admin' AND caller_role != 'admin' AND caller_role != 'owner' THEN
             -- Actually owner can assign admin. Code said "only admin can assign admin"? 
             -- Logic: Owner > Admin > Member.
             -- Original Code: IF p_role = 'admin' AND caller.role != 'admin' (WRONG logic in original?)
             -- Revised Logic: Owner can do anything. Admin can assign Member/Admin but not Owner?
             -- Let's stick to strict: Owner and Admin can manage.
             NULL;
        END IF;
        
        -- Admin cannot assign Owner
        IF p_role = 'owner' AND caller_role = 'admin' THEN
            RETURN json_build_object('success', false, 'error', 'Un administrador no puede asignar el rol owner');
        END IF;
        
        -- Cannot change own role
        IF caller_id = p_user_id THEN
             RETURN json_build_object('success', false, 'error', 'No puedes cambiar tu propio rol');
        END IF;

        -- Admin cannot change Owner's role
        IF caller_role = 'admin' AND target_role = 'owner' THEN
             RETURN json_build_object('success', false, 'error', 'Un administrador no puede modificar el rol de un owner');
        END IF;

        -- Update Membership
        UPDATE public.company_members
        SET role_id = v_new_role_id, updated_at = NOW()
        WHERE user_id = p_user_id AND company_id = caller_company_id;
    END IF;

    -- UPDATE ACTIVE
    IF p_active IS NOT NULL THEN
        IF caller_id = p_user_id AND p_active = false THEN
            RETURN json_build_object('success', false, 'error', 'No puedes desactivarte a ti mismo');
        END IF;
        
        IF caller_role = 'admin' AND target_role = 'owner' AND p_active = false THEN
             RETURN json_build_object('success', false, 'error', 'Un administrador no puede desactivar a un owner');
        END IF;

        UPDATE public.users SET active = p_active WHERE id = p_user_id;
    END IF;

    RETURN json_build_object(
        'success', true,
        'user_id', p_user_id,
        'role', COALESCE(p_role, target_role),
        'active', COALESCE(p_active, target_active)
    );

EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."update_company_user"("p_user_id" "uuid", "p_role" "text", "p_active" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" "text", "p_surname" "text", "p_email" "text", "p_telefono" "text" DEFAULT NULL::"text", "p_dni" "text" DEFAULT NULL::"text", "p_fecha_nacimiento" "date" DEFAULT NULL::"date", "p_profesion" "text" DEFAULT NULL::"text", "p_empresa" "text" DEFAULT NULL::"text", "p_notas" "text" DEFAULT NULL::"text", "p_avatar_url" "text" DEFAULT NULL::"text", "p_direccion_id" "uuid" DEFAULT NULL::"uuid", "p_activo" boolean DEFAULT true) RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    updated_rows INTEGER;
BEGIN
    UPDATE public.clients 
    SET
        name = p_nombre,
        surname = p_surname,
        email = p_email,
        phone = p_telefono,
        dni = p_dni,
        birth_date = p_fecha_nacimiento, -- Mapped from birth_date in clients
        internal_notes = p_notas,     -- Mapped from internal_notes in clients
        direccion_id = p_direccion_id,
        is_active = p_activo,         -- Mapped from is_active in clients
        updated_at = TIMEZONE('utc'::text, NOW())
    WHERE 
        id = customer_id;
        -- Removing target_user_id check as clients are linked to company_id, not directly to auth_user_id in a simple way here
        -- but keeping function signature for compatibility.
    
    GET DIAGNOSTICS updated_rows = ROW_COUNT;
    
    RETURN updated_rows > 0;
END;
$$;


ALTER FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" "text", "p_surname" "text", "p_email" "text", "p_telefono" "text", "p_dni" "text", "p_fecha_nacimiento" "date", "p_profesion" "text", "p_empresa" "text", "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid", "p_activo" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying DEFAULT NULL::character varying, "p_dni" character varying DEFAULT NULL::character varying, "p_fecha_nacimiento" "date" DEFAULT NULL::"date", "p_profesion" character varying DEFAULT NULL::character varying, "p_empresa" character varying DEFAULT NULL::character varying, "p_notas" "text" DEFAULT NULL::"text", "p_avatar_url" "text" DEFAULT NULL::"text", "p_direccion_id" "uuid" DEFAULT NULL::"uuid", "p_activo" boolean DEFAULT true) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    updated_rows INTEGER;
BEGIN
    UPDATE public.customers 
    SET
        nombre = p_nombre,
        apellidos = p_apellidos,
        email = p_email,
        telefono = p_telefono,
        dni = p_dni,
        fecha_nacimiento = p_fecha_nacimiento,
        profesion = p_profesion,
        empresa = p_empresa,
        notas = p_notas,
        avatar_url = p_avatar_url,
        direccion_id = p_direccion_id,
        activo = p_activo,
        updated_at = TIMEZONE('utc'::text, NOW())
    WHERE 
        id = customer_id AND 
        usuario_id = target_user_id;
    
    GET DIAGNOSTICS updated_rows = ROW_COUNT;
    
    RETURN updated_rows > 0;
END;
$$;


ALTER FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying, "p_fecha_nacimiento" "date", "p_profesion" character varying, "p_empresa" character varying, "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid", "p_activo" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying, "p_fecha_nacimiento" "date", "p_profesion" character varying, "p_empresa" character varying, "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid", "p_activo" boolean) IS 'Función RPC para actualizar clientes en modo desarrollo';



CREATE OR REPLACE FUNCTION "public"."update_device_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_device_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_payment_integrations_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_payment_integrations_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_quotes_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_quotes_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_service_variant_rpc"("p_variant_id" "uuid", "p_variant_name" "text" DEFAULT NULL::"text", "p_pricing" "jsonb" DEFAULT NULL::"jsonb", "p_features" "jsonb" DEFAULT NULL::"jsonb", "p_display_config" "jsonb" DEFAULT NULL::"jsonb", "p_is_active" boolean DEFAULT NULL::boolean, "p_sort_order" integer DEFAULT NULL::integer) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
  v_user_company_id uuid;
BEGIN
  -- Validate Auth
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get Service and Company ID to verify permissions
  SELECT s.company_id
  INTO v_company_id
  FROM service_variants sv
  JOIN services s ON s.id = sv.service_id
  WHERE sv.id = p_variant_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Variant not found';
  END IF;

  SELECT company_id INTO v_user_company_id FROM users WHERE auth_user_id = auth.uid();
  
  IF v_user_company_id IS NULL OR v_user_company_id != v_company_id THEN
    RAISE EXCEPTION 'Permission denied';
  END IF;

  -- Update
  UPDATE service_variants
  SET
    variant_name = COALESCE(p_variant_name, variant_name),
    pricing = COALESCE(p_pricing, pricing),
    features = COALESCE(p_features, features),
    display_config = COALESCE(p_display_config, display_config),
    is_active = COALESCE(p_is_active, is_active),
    sort_order = COALESCE(p_sort_order, sort_order),
    updated_at = now()
  WHERE id = p_variant_id;

  RETURN json_build_object('success', true, 'id', p_variant_id);
END;
$$;


ALTER FUNCTION "public"."update_service_variant_rpc"("p_variant_id" "uuid", "p_variant_name" "text", "p_pricing" "jsonb", "p_features" "jsonb", "p_display_config" "jsonb", "p_is_active" boolean, "p_sort_order" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_service_variants_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_service_variants_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_verifactu_settings_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_verifactu_settings_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."upsert_client"("payload" "jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    new_id uuid;
    result_record jsonb;
    current_user_id uuid;
BEGIN
    -- Get current user ID (if calling from authenticated context)
    current_user_id := auth.uid();
    
    -- Extract ID if present (for update)
    IF payload->>'id' IS NOT NULL THEN
        new_id := (payload->>'id')::uuid;
    ELSE
        new_id := gen_random_uuid();
    END IF;

    -- Perform Upsert
    INSERT INTO public.clients (
        id,
        name,
        surname, -- RENAMED
        dni,
        phone,
        client_type,
        business_name,
        cif_nif,
        trade_name,
        legal_representative_name,
        legal_representative_dni,
        email,
        direccion_id,
        mercantile_registry_data, 
        metadata,
        company_id,
        created_at,
        updated_at
    )
    VALUES (
        new_id,
        COALESCE(payload->>'name', ''),
        COALESCE(payload->>'surname', payload->>'apellidos', ''), -- Support both for transition
        COALESCE(payload->>'dni', ''),
        COALESCE(payload->>'phone', ''),
        COALESCE(payload->>'client_type', 'individual'), 
        payload->>'business_name',
        payload->>'cif_nif',
        payload->>'trade_name',
        payload->>'legal_representative_name',
        payload->>'legal_representative_dni',
        payload->>'email',
        (payload->>'direccion_id')::uuid,
        
        CASE 
            WHEN payload->'mercantile_registry_data' IS NULL OR jsonb_typeof(payload->'mercantile_registry_data') = 'null' THEN null
            ELSE payload->'mercantile_registry_data'
        END,

        CASE 
            WHEN payload->'metadata' IS NULL OR jsonb_typeof(payload->'metadata') = 'null' THEN '{}'::jsonb
            ELSE payload->'metadata'
        END,

        COALESCE((payload->>'company_id')::uuid, (payload->>'usuario_id')::uuid, current_user_id),
        NOW(),
        NOW()
    )
    ON CONFLICT (id) DO UPDATE SET
        name = EXCLUDED.name,
        surname = EXCLUDED.surname, -- RENAMED
        dni = EXCLUDED.dni,
        phone = EXCLUDED.phone,
        client_type = EXCLUDED.client_type,
        business_name = EXCLUDED.business_name,
        cif_nif = EXCLUDED.cif_nif,
        trade_name = EXCLUDED.trade_name,
        legal_representative_name = EXCLUDED.legal_representative_name,
        legal_representative_dni = EXCLUDED.legal_representative_dni,
        email = EXCLUDED.email,
        direccion_id = EXCLUDED.direccion_id,
        mercantile_registry_data = EXCLUDED.mercantile_registry_data,
        metadata = EXCLUDED.metadata,
        company_id = COALESCE(clients.company_id, EXCLUDED.company_id),
        updated_at = NOW()
    RETURNING to_jsonb(clients.*) INTO result_record;

    RETURN result_record;
END;
$$;


ALTER FUNCTION "public"."upsert_client"("payload" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."upsert_client_rpc"("p_first_name" "text", "p_last_name" "text", "p_email" "text", "p_phone" "text" DEFAULT NULL::"text", "p_address" "text" DEFAULT NULL::"text", "p_city" "text" DEFAULT NULL::"text", "p_fiscal_id" "text" DEFAULT NULL::"text", "p_client_id" "uuid" DEFAULT NULL::"uuid", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_company_id uuid;
  v_client_id uuid;
  v_normalized_email text;
  v_full_name text;
BEGIN
  -- Validate Auth
  v_company_id := (SELECT company_id FROM users WHERE auth_user_id = auth.uid());
  
  IF v_company_id IS NULL THEN
    RAISE EXCEPTION 'User not associated with a company';
  END IF;

  -- Normalize Inputs
  v_normalized_email := lower(trim(p_email));
  v_full_name := trim(p_first_name || ' ' || COALESCE(p_last_name, ''));
  
  -- Validation
  IF length(v_normalized_email) < 3 OR strpos(v_normalized_email, '@') = 0 THEN
    RAISE EXCEPTION 'Invalid email';
  END IF;

  IF p_client_id IS NOT NULL THEN
    -- UPDATE existing
    -- Verify ownership
    IF NOT EXISTS (SELECT 1 FROM clients WHERE id = p_client_id AND company_id = v_company_id) THEN
       RAISE EXCEPTION 'Client not found or access denied';
    END IF;

    UPDATE clients
    SET 
      name = v_full_name,
      email = v_normalized_email,
      phone = p_phone,
      address = p_address,
      city = p_city,
      fiscal_id = p_fiscal_id,
      metadata = COALESCE(clients.metadata, '{}'::jsonb) || p_metadata,
      updated_at = now()
    WHERE id = p_client_id
    RETURNING id INTO v_client_id;
    
    RETURN json_build_object('id', v_client_id, 'action', 'updated');

  ELSE
    -- INSERT new (Check dupe email within company)
    SELECT id INTO v_client_id FROM clients WHERE company_id = v_company_id AND email = v_normalized_email;
    
    IF v_client_id IS NOT NULL THEN
       -- Update existing if found by email
       UPDATE clients
       SET 
          name = v_full_name,
          phone = COALESCE(p_phone, phone),
          address = COALESCE(p_address, address),
          city = COALESCE(p_city, city),
          fiscal_id = COALESCE(p_fiscal_id, fiscal_id),
          updated_at = now()
       WHERE id = v_client_id;
       
       RETURN json_build_object('id', v_client_id, 'action', 'updated_by_email_match');
    ELSE
       -- Insert fresh
       INSERT INTO clients (
         company_id, name, email, phone, address, city, fiscal_id, metadata, status
       ) VALUES (
         v_company_id, v_full_name, v_normalized_email, p_phone, p_address, p_city, p_fiscal_id, p_metadata, 'active'
       )
       RETURNING id INTO v_client_id;
       
       RETURN json_build_object('id', v_client_id, 'action', 'created');
    END IF;
  END IF;
END;
$$;


ALTER FUNCTION "public"."upsert_client_rpc"("p_first_name" "text", "p_last_name" "text", "p_email" "text", "p_phone" "text", "p_address" "text", "p_city" "text", "p_fiscal_id" "text", "p_client_id" "uuid", "p_metadata" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."upsert_user_module"("p_user_id" "uuid", "p_module_key" "text", "p_status" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
begin
    -- Check permissions: Only self or Admin/Owner of the user's company? 
    -- For simplicty, RLS on user_modules table often handles this, but since this is SECURITY DEFINER, we should enforce checks.
    -- However, since this is called by Admin UI, we assume the caller is authorized. 
    -- Ideally we check if auth.uid() is the user OR is an admin of the user's company OR global admin.
    
    insert into public.user_modules (user_id, module_key, status, updated_at)
    values (p_user_id, p_module_key, p_status, now())
    on conflict (user_id, module_key)
    do update set
        status = EXCLUDED.status,
        updated_at = now();
end;
$$;


ALTER FUNCTION "public"."upsert_user_module"("p_user_id" "uuid", "p_module_key" "text", "p_status" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."upsert_user_module"("p_user_id" "uuid", "p_module_key" "text", "p_status" "public"."module_status") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_role text;
BEGIN
  -- Optional: check role of current user
  SELECT role INTO v_role FROM public.users WHERE auth_user_id = auth.uid();
  IF v_role NOT IN ('admin','owner') THEN
    RAISE EXCEPTION 'Insufficient permissions';
  END IF;

  INSERT INTO user_modules(user_id, module_key, status)
  VALUES (p_user_id, p_module_key, p_status)
  ON CONFLICT(user_id, module_key)
  DO UPDATE SET status = EXCLUDED.status, updated_at = now();
END;
$$;


ALTER FUNCTION "public"."upsert_user_module"("p_user_id" "uuid", "p_module_key" "text", "p_status" "public"."module_status") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."upsert_verifactu_settings"("psoftware_code" "text", "pissuer_nif" "text", "pcert_pem" "text", "pkey_pem" "text", "pkey_passphrase" "text", "penvironment" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_company uuid;
BEGIN
  -- Resuelve la empresa del usuario (ajusta helper si el tuyo difiere)
  SELECT companyid INTO v_company FROM public.users WHERE authuserid = auth.uid() LIMIT 1;
  IF v_company IS NULL THEN
    RAISE EXCEPTION 'No company for current user';
  END IF;

  INSERT INTO public.verifactu_settings(companyid, software_code, issuer_nif, cert_pem, key_pem, key_passphrase, environment)
  VALUES (v_company, psoftware_code, pissuer_nif, pcert_pem, pkey_pem, pkey_passphrase, penvironment)
  ON CONFLICT (companyid) DO UPDATE
    SET software_code   = EXCLUDED.software_code,
        issuer_nif      = EXCLUDED.issuer_nif,
        cert_pem        = EXCLUDED.cert_pem,
        key_pem         = EXCLUDED.key_pem,
        key_passphrase  = EXCLUDED.key_passphrase,
        environment     = EXCLUDED.environment,
        updated_at      = now();

  RETURN jsonb_build_object('ok', true, 'company_id', v_company);
END;
$$;


ALTER FUNCTION "public"."upsert_verifactu_settings"("psoftware_code" "text", "pissuer_nif" "text", "pcert_pem" "text", "pkey_pem" "text", "pkey_passphrase" "text", "penvironment" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."upsert_verifactu_settings"("p_company_id" "uuid", "p_software_code" "text", "p_software_name" "text", "p_software_version" "text", "p_issuer_nif" "text", "p_environment" "text", "p_is_active" boolean) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
    -- Validar: Owner o Admin de la empresa
    IF NOT EXISTS (
        SELECT 1 FROM public.company_members cm
        JOIN public.users u ON cm.user_id = u.id
        JOIN public.app_roles ar ON cm.role_id = ar.id
        WHERE u.auth_user_id = auth.uid()
          AND cm.company_id = p_company_id
          AND ar.name IN ('owner', 'admin')
          AND cm.status = 'active'
    ) THEN
        RETURN jsonb_build_object('ok', false, 'error', 'access_denied');
    END IF;
    
    INSERT INTO public.verifactu_settings (
        company_id, software_code, software_name, software_version,
        issuer_nif, environment, is_active
    ) VALUES (
        p_company_id, p_software_code, p_software_name, p_software_version,
        p_issuer_nif, p_environment, p_is_active
    )
    ON CONFLICT (company_id) DO UPDATE SET
        software_code = COALESCE(EXCLUDED.software_code, verifactu_settings.software_code),
        software_name = COALESCE(EXCLUDED.software_name, verifactu_settings.software_name),
        software_version = COALESCE(EXCLUDED.software_version, verifactu_settings.software_version),
        issuer_nif = COALESCE(EXCLUDED.issuer_nif, verifactu_settings.issuer_nif),
        environment = COALESCE(EXCLUDED.environment, verifactu_settings.environment),
        is_active = COALESCE(EXCLUDED.is_active, verifactu_settings.is_active),
        updated_at = NOW();
    
    RETURN jsonb_build_object('ok', true);
END;
$$;


ALTER FUNCTION "public"."upsert_verifactu_settings"("p_company_id" "uuid", "p_software_code" "text", "p_software_name" "text", "p_software_version" "text", "p_issuer_nif" "text", "p_environment" "text", "p_is_active" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_file_path"("file_path" "text", "company_uuid" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
  RETURN file_path LIKE (company_uuid::text || '/%');
END;
$$;


ALTER FUNCTION "public"."validate_file_path"("file_path" "text", "company_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_invoice_before_issue"("pinvoiceid" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
  v_invoice RECORD;
  v_errors text[] := ARRAY[]::text[];
BEGIN
  -- Obtener factura con serie
  SELECT 
    i.*,
    s.verifactu_enabled
  INTO v_invoice
  FROM public.invoices i
  JOIN public.invoice_series s ON s.id = i.series_id
  WHERE i.id = pinvoiceid;

  IF NOT FOUND THEN
    v_errors := v_errors || 'invoice_not_found';
    RETURN jsonb_build_object('valid', false, 'errors', v_errors);
  END IF;

  -- Validar serie habilitada para Verifactu
  IF v_invoice.verifactu_enabled IS DISTINCT FROM TRUE THEN
    v_errors := array_append(v_errors, 'series_not_verifactu');
  END IF;

  -- Validar totales positivos
  IF v_invoice.total IS NULL OR v_invoice.total <= 0 THEN
    v_errors := array_append(v_errors, 'invalid_total');
  END IF;

  -- Validar cliente y CIF/NIF/DNI
  IF v_invoice.client_id IS NULL THEN
    v_errors := array_append(v_errors, 'missing_client');
  ELSE
    -- Check if either cif_nif OR dni is present
    IF NOT EXISTS (
      SELECT 1 FROM public.clients c
      WHERE c.id = v_invoice.client_id
        AND (
             (COALESCE(c.cif_nif, '') <> '' AND trim(c.cif_nif) <> '')
             OR 
             (COALESCE(c.dni, '') <> '' AND trim(c.dni) <> '')
            )
    ) THEN
      v_errors := array_append(v_errors, 'missing_client_vat');
    END IF;
  END IF;

  -- Validar coherencia de totales
  IF COALESCE(v_invoice.subtotal, 0) + COALESCE(v_invoice.tax_amount, 0) 
     <> COALESCE(v_invoice.total, 0) THEN
    v_errors := array_append(v_errors, 'totals_mismatch');
  END IF;

  -- Validar estado/status válido para emitir
  IF v_invoice.state IN ('final', 'void') 
     OR v_invoice.status NOT IN ('draft', 'sent') THEN
    v_errors := array_append(v_errors, 'invalid_status_state');
  END IF;

  RETURN jsonb_build_object(
    'valid', array_length(v_errors, 1) IS NULL,
    'errors', v_errors
  );
END;
$$;


ALTER FUNCTION "public"."validate_invoice_before_issue"("pinvoiceid" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."validate_invoice_before_issue"("pinvoiceid" "uuid") IS 'Validates invoice data before VeriFactu emission. Checks: series enabled, totals, client CIF/NIF, and status.';



CREATE OR REPLACE FUNCTION "public"."verifactu_log_event"("pevent_type" "text", "pinvoice_id" "uuid", "pcompany_id" "uuid", "ppayload" "jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
BEGIN
  -- Insertar log en tabla de eventos
  INSERT INTO verifactu.events (
    event_type,
    invoice_id,
    company_id,
    payload,
    created_at
  ) VALUES (
    pevent_type,
    pinvoice_id,
    pcompany_id,
    ppayload,
    NOW()
  );
  
  -- O si usas otra tabla de logs
  -- INSERT INTO public.verifactu_logs (...)
  
EXCEPTION
  WHEN OTHERS THEN
    -- Log silencioso, no fallar
    RAISE WARNING 'Failed to log verifactu event: %', SQLERRM;
END;
$$;


ALTER FUNCTION "public"."verifactu_log_event"("pevent_type" "text", "pinvoice_id" "uuid", "pcompany_id" "uuid", "ppayload" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."verifactu_preflight_issue"("pinvoice_id" "uuid", "pdevice_id" "text" DEFAULT NULL::"text", "psoftware_id" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
DECLARE
    v_invoice_status text;
    v_series text;
    v_result json;
BEGIN
    -- Check invoice status and get series
    SELECT i.state, s.series_code INTO v_invoice_status, v_series
    FROM public.invoices i
    JOIN public.invoice_series s ON s.id = i.series_id
    WHERE i.id = pinvoice_id;
    
    IF v_invoice_status IS NULL THEN
        RAISE EXCEPTION 'Invoice not found';
    END IF;

    -- Allow 'draft' AND 'approved'
    IF v_invoice_status NOT IN ('draft', 'approved') THEN
        RAISE EXCEPTION 'invalid_status_state';
    END IF;

    -- Call finalize_invoice to perform the actual work (hashing, chaining, updating status)
    v_result := public.finalize_invoice(pinvoice_id, v_series, pdevice_id, psoftware_id);
    
    RETURN json_build_object('ok', true, 'data', v_result);
END;
$$;


ALTER FUNCTION "public"."verifactu_preflight_issue"("pinvoice_id" "uuid", "pdevice_id" "text", "psoftware_id" "text") OWNER TO "postgres";


CREATE PROCEDURE "public"."verifactu_process_pending_events"()
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  r RECORD;
  v_response jsonb;
BEGIN
  FOR r IN
    SELECT * FROM verifactu.events 
    WHERE status = 'pending' 
    ORDER BY created_at ASC 
    LIMIT 100
  LOOP
    -- Mark as sending
    UPDATE verifactu.events SET status = 'sending', sent_at = now() WHERE id = r.id;
    
    -- Mock Response
    v_response := jsonb_build_object(
      'status', 'ACCEPTED',
      'at', now(),
      'simulation', true,
      'echo', jsonb_build_object('id', r.id)
    );

    -- Mark as accepted
    UPDATE verifactu.events 
    SET status = 'accepted', response = v_response 
    WHERE id = r.id;

    -- Update Meta
    IF r.event_type = 'anulacion' THEN
      UPDATE verifactu.invoice_meta SET status = 'void' WHERE invoice_id = r.invoice_id;
    ELSE
      UPDATE verifactu.invoice_meta SET status = 'accepted' WHERE invoice_id = r.invoice_id;
    END IF;
    
  END LOOP;
END;
$$;


ALTER PROCEDURE "public"."verifactu_process_pending_events"() OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."invoices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "series_id" "uuid" NOT NULL,
    "invoice_number" "text" NOT NULL,
    "invoice_series" "text" NOT NULL,
    "full_invoice_number" "text" GENERATED ALWAYS AS ((("invoice_series" || '-'::"text") || "invoice_number")) STORED,
    "invoice_type" "public"."invoice_type" DEFAULT 'normal'::"public"."invoice_type" NOT NULL,
    "invoice_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "due_date" "date" NOT NULL,
    "subtotal" numeric(12,2) DEFAULT 0 NOT NULL,
    "tax_amount" numeric(12,2) DEFAULT 0 NOT NULL,
    "total" numeric(12,2) DEFAULT 0 NOT NULL,
    "paid_amount" numeric(12,2) DEFAULT 0 NOT NULL,
    "currency" "text" DEFAULT 'EUR'::"text" NOT NULL,
    "status" "public"."invoice_status" DEFAULT 'draft'::"public"."invoice_status" NOT NULL,
    "payment_method" "public"."payment_method",
    "notes" "text",
    "internal_notes" "text",
    "rectifies_invoice_id" "uuid",
    "rectification_reason" "text",
    "verifactu_hash" "text",
    "verifactu_signature" "text",
    "verifactu_timestamp" timestamp with time zone,
    "verifactu_qr_code" "text",
    "verifactu_xml" "text",
    "verifactu_chain_position" integer,
    "anonymized_at" timestamp with time zone,
    "retention_until" "date" GENERATED ALWAYS AS (("invoice_date" + '7 years'::interval)) STORED,
    "gdpr_legal_basis" "text" DEFAULT 'legal_obligation'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "created_by" "uuid",
    "deleted_at" timestamp with time zone,
    "state" "text" DEFAULT 'draft'::"text",
    "total_tax_base" numeric(14,2),
    "total_vat" numeric(14,2),
    "total_gross" numeric(14,2),
    "source_quote_id" "uuid",
    "finalized_at" timestamp with time zone,
    "canonical_payload" "jsonb",
    "hash_prev" "text",
    "hash_current" "text",
    "invoice_month" "date",
    "payment_status" "text" DEFAULT 'pending'::"text",
    "payment_date" timestamp with time zone,
    "payment_reference" "text",
    "payment_link_token" "text",
    "payment_link_expires_at" timestamp with time zone,
    "payment_link_provider" "text",
    "recurrence_period" character varying(7),
    "stripe_payment_url" "text",
    "paypal_payment_url" "text",
    "stripe_payment_token" "text",
    "paypal_payment_token" "text",
    "lead_id" "uuid",
    CONSTRAINT "invoices_payment_status_check" CHECK (("payment_status" = ANY (ARRAY['pending'::"text", 'pending_local'::"text", 'partial'::"text", 'paid'::"text", 'refunded'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "valid_dates" CHECK (("due_date" >= "invoice_date")),
    CONSTRAINT "valid_paid_amount_logic" CHECK (((("total" >= (0)::numeric) AND ("paid_amount" >= (0)::numeric) AND ("paid_amount" <= "total")) OR (("total" < (0)::numeric) AND ("paid_amount" <= (0)::numeric) AND ("paid_amount" >= "total")))),
    CONSTRAINT "valid_total" CHECK (("total" = ("subtotal" + "tax_amount")))
);


ALTER TABLE "public"."invoices" OWNER TO "postgres";


COMMENT ON TABLE "public"."invoices" IS 'Facturas emitidas con soporte Veri*Factu y GDPR';



COMMENT ON COLUMN "public"."invoices"."payment_link_provider" IS 'Payment provider used for the payment link (paypal or stripe)';



COMMENT ON COLUMN "public"."invoices"."recurrence_period" IS 'Para facturas generadas de presupuestos recurrentes, indica el período (YYYY-MM)';



COMMENT ON COLUMN "public"."invoices"."stripe_payment_url" IS 'Direct Stripe checkout URL for this invoice';



COMMENT ON COLUMN "public"."invoices"."paypal_payment_url" IS 'Direct PayPal approval URL for this invoice';



COMMENT ON COLUMN "public"."invoices"."stripe_payment_token" IS 'Unique token for Stripe payment tracking';



COMMENT ON COLUMN "public"."invoices"."paypal_payment_token" IS 'Unique token for PayPal payment tracking';



CREATE OR REPLACE FUNCTION "public"."verifactu_status"("i" "public"."invoices") RETURNS "text"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'temp'
    AS $$
  select status from verifactu.invoice_meta where invoice_id = i.id;
$$;


ALTER FUNCTION "public"."verifactu_status"("i" "public"."invoices") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."quote_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "quote_id" "uuid" NOT NULL,
    "company_id" "uuid" NOT NULL,
    "line_number" integer NOT NULL,
    "description" "text" NOT NULL,
    "quantity" numeric(10,2) DEFAULT 1 NOT NULL,
    "unit_price" numeric(12,2) NOT NULL,
    "tax_rate" numeric(5,2) DEFAULT 21.00 NOT NULL,
    "tax_amount" numeric(12,2) DEFAULT 0 NOT NULL,
    "discount_percent" numeric(5,2) DEFAULT 0,
    "discount_amount" numeric(12,2) DEFAULT 0,
    "subtotal" numeric(12,2) DEFAULT 0 NOT NULL,
    "total" numeric(12,2) DEFAULT 0 NOT NULL,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "service_id" "uuid",
    "product_id" "uuid",
    "variant_id" "uuid",
    "billing_period" "text",
    CONSTRAINT "chk_quote_items_billing_period_values" CHECK ((("billing_period" IS NULL) OR ("billing_period" = ANY (ARRAY['one-time'::"text", 'monthly'::"text", 'quarterly'::"text", 'annually'::"text", 'annual'::"text", 'yearly'::"text", 'custom'::"text"])))),
    CONSTRAINT "chk_quote_items_single_reference" CHECK (((("service_id" IS NOT NULL) AND ("product_id" IS NULL)) OR (("service_id" IS NULL) AND ("product_id" IS NOT NULL)) OR (("service_id" IS NULL) AND ("product_id" IS NULL)))),
    CONSTRAINT "valid_discount" CHECK ((("discount_percent" >= (0)::numeric) AND ("discount_percent" <= (100)::numeric))),
    CONSTRAINT "valid_price" CHECK (("unit_price" >= (0)::numeric)),
    CONSTRAINT "valid_quantity_nonzero" CHECK (("quantity" <> (0)::numeric)),
    CONSTRAINT "valid_tax_rate" CHECK ((("tax_rate" >= (0)::numeric) AND ("tax_rate" <= (100)::numeric)))
);


ALTER TABLE "public"."quote_items" OWNER TO "postgres";


COMMENT ON TABLE "public"."quote_items" IS 'Líneas de detalle de los presupuestos';



COMMENT ON COLUMN "public"."quote_items"."variant_id" IS 'Referencia a la variante del servicio seleccionada (si aplica)';



COMMENT ON COLUMN "public"."quote_items"."billing_period" IS 'Periodicidad aplicada a este item (one-time, monthly, quarterly, annually/yearly, custom)';



CREATE TABLE IF NOT EXISTS "public"."ticket_stages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(100) NOT NULL,
    "position" integer NOT NULL,
    "color" character varying(7) DEFAULT '#6b7280'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone,
    "company_id" "uuid",
    "stage_category" "public"."stage_category" DEFAULT 'open'::"public"."stage_category",
    "workflow_category" "public"."workflow_category"
);


ALTER TABLE "public"."ticket_stages" OWNER TO "postgres";


COMMENT ON COLUMN "public"."ticket_stages"."company_id" IS 'NULL indicates a generic/system-wide stage available to all companies. 
   Non-NULL values are company-specific stages.';



COMMENT ON COLUMN "public"."ticket_stages"."stage_category" IS 'Categoría del stage: open, in_progress, completed, on_hold';



CREATE TABLE IF NOT EXISTS "public"."app_roles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "label" "text" NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."app_roles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."companies" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text",
    "settings" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone,
    "website" "text",
    "legacy_negocio_id" "text",
    "logo_url" "text",
    "subscription_tier" character varying(50) DEFAULT 'basic'::character varying,
    "max_users" integer DEFAULT 10,
    "is_active" boolean DEFAULT true,
    "nif" character varying(20),
    "google_calendar_display_config" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."companies" OWNER TO "postgres";


COMMENT ON COLUMN "public"."companies"."nif" IS 'NIF/CIF de la empresa. Obligatorio para facturación y VeriFactu.';



COMMENT ON COLUMN "public"."companies"."google_calendar_display_config" IS 'Stores configuration for Google Calendar integration status and preferences';



CREATE TABLE IF NOT EXISTS "public"."company_invitations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "email" "text" NOT NULL,
    "invited_by_user_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'member'::"text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "token" "text" DEFAULT ("gen_random_uuid"())::"text" NOT NULL,
    "message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone DEFAULT ("now"() + '7 days'::interval),
    "responded_at" timestamp with time zone,
    CONSTRAINT "company_invitations_role_check" CHECK (("role" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'member'::"text", 'professional'::"text", 'agent'::"text", 'client'::"text"]))),
    CONSTRAINT "company_invitations_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'accepted'::"text", 'rejected'::"text", 'expired'::"text"])))
);


ALTER TABLE "public"."company_invitations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "email" "text" NOT NULL,
    "name" "text",
    "active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone,
    "permissions" "jsonb" DEFAULT '{"moduloFacturas": false, "moduloMaterial": false, "moduloServicios": false, "moduloPresupuestos": false}'::"jsonb",
    "auth_user_id" "uuid",
    "is_dpo" boolean DEFAULT false,
    "gdpr_training_completed" boolean DEFAULT false,
    "gdpr_training_date" timestamp with time zone,
    "data_access_level" "text" DEFAULT 'standard'::"text",
    "last_privacy_policy_accepted" timestamp with time zone,
    "failed_login_attempts" integer DEFAULT 0,
    "account_locked_until" timestamp with time zone,
    "surname" "text",
    "last_session_at" timestamp with time zone,
    "app_role_id" "uuid"
);


ALTER TABLE "public"."users" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."admin_company_analysis" WITH ("security_invoker"='true') AS
 SELECT "c"."id",
    "c"."name",
    "c"."slug",
    "c"."created_at",
    "count"("u"."id") AS "total_users",
    "count"("u"."id") FILTER (WHERE ("ar"."name" = 'owner'::"text")) AS "owners_count",
    "count"("u"."id") FILTER (WHERE ("ar"."name" = 'admin'::"text")) AS "admins_count",
    "count"("u"."id") FILTER (WHERE ("ar"."name" = 'member'::"text")) AS "members_count",
    "count"("ci"."id") FILTER (WHERE ("ci"."status" = 'pending'::"text")) AS "pending_invitations",
    "string_agg"("u"."email", ', '::"text") FILTER (WHERE ("ar"."name" = 'owner'::"text")) AS "owner_emails"
   FROM ((("public"."companies" "c"
     LEFT JOIN "public"."users" "u" ON ((("c"."id" = "u"."company_id") AND ("u"."active" = true))))
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
     LEFT JOIN "public"."company_invitations" "ci" ON ((("c"."id" = "ci"."company_id") AND ("ci"."status" = 'pending'::"text"))))
  WHERE ("c"."deleted_at" IS NULL)
  GROUP BY "c"."id", "c"."name", "c"."slug", "c"."created_at"
  ORDER BY "c"."created_at" DESC;


ALTER VIEW "public"."admin_company_analysis" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pending_users" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email" "text" NOT NULL,
    "full_name" "text" NOT NULL,
    "company_name" "text",
    "auth_user_id" "uuid",
    "confirmation_token" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone DEFAULT ("now"() + '24:00:00'::interval),
    "confirmed_at" timestamp with time zone,
    "given_name" "text",
    "surname" "text",
    "company_id" "uuid",
    "company_nif" character varying(20)
);


ALTER TABLE "public"."pending_users" OWNER TO "postgres";


COMMENT ON COLUMN "public"."pending_users"."company_nif" IS 'NIF/CIF de la empresa a crear tras la confirmación del registro.';



CREATE OR REPLACE VIEW "public"."admin_pending_users" WITH ("security_invoker"='true') AS
 SELECT "id",
    "email",
    "full_name",
    "company_name",
    "created_at",
    "expires_at",
    "confirmed_at",
        CASE
            WHEN ("confirmed_at" IS NOT NULL) THEN 'confirmed'::"text"
            WHEN ("expires_at" < "now"()) THEN 'expired'::"text"
            ELSE 'pending'::"text"
        END AS "status"
   FROM "public"."pending_users" "p"
  WHERE (EXISTS ( SELECT 1
           FROM ("public"."users" "u"
             LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
          WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) AND ("u"."active" = true))))
  ORDER BY "created_at" DESC;


ALTER VIEW "public"."admin_pending_users" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ai_usage_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "feature_key" "text" NOT NULL,
    "saved_seconds" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."ai_usage_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."app_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "default_convert_policy" "text" DEFAULT 'manual'::"text" NOT NULL,
    "ask_before_convert" boolean DEFAULT true NOT NULL,
    "enforce_globally" boolean DEFAULT false NOT NULL,
    "default_payment_terms" "text",
    "default_invoice_delay_days" integer DEFAULT 0 NOT NULL,
    "default_prices_include_tax" boolean,
    "default_iva_enabled" boolean,
    "default_iva_rate" numeric,
    "default_irpf_enabled" boolean,
    "default_irpf_rate" numeric,
    "default_auto_send_quote_email" boolean DEFAULT false,
    CONSTRAINT "app_settings_default_convert_policy_check" CHECK (("default_convert_policy" = ANY (ARRAY['manual'::"text", 'on_accept'::"text", 'automatic'::"text", 'scheduled'::"text"])))
);


ALTER TABLE "public"."app_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."attachments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "job_id" "uuid",
    "file_name" "text" NOT NULL,
    "file_path" "text" NOT NULL,
    "file_size" integer,
    "mime_type" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone
);


ALTER TABLE "public"."attachments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."audit_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "actor_id" "uuid",
    "entity_type" "text" NOT NULL,
    "entity_id" "text" NOT NULL,
    "action" "text" NOT NULL,
    "old_data" "jsonb",
    "new_data" "jsonb",
    "ip_address" "text",
    "user_agent" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "actor_email" "text"
);


ALTER TABLE "public"."audit_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."availability_exceptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "start_time" timestamp with time zone NOT NULL,
    "end_time" timestamp with time zone NOT NULL,
    "reason" "text",
    "type" "text" DEFAULT 'block'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."availability_exceptions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."availability_schedules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "booking_type_id" "uuid",
    "day_of_week" integer NOT NULL,
    "start_time" time without time zone NOT NULL,
    "end_time" time without time zone NOT NULL,
    "is_unavailable" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "availability_schedules_day_of_week_check" CHECK ((("day_of_week" >= 0) AND ("day_of_week" <= 6)))
);


ALTER TABLE "public"."availability_schedules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."booking_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "booking_id" "uuid" NOT NULL,
    "changed_by" "uuid",
    "changed_by_user_id" "uuid",
    "previous_status" "text",
    "new_status" "text",
    "change_type" "text" NOT NULL,
    "details" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "company_id" "uuid" NOT NULL
);


ALTER TABLE "public"."booking_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."booking_types" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "owner_id" "uuid",
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "description" "text",
    "duration" integer NOT NULL,
    "price" numeric(10,2) DEFAULT 0,
    "currency" "text" DEFAULT 'EUR'::"text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."booking_types" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bookings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "booking_type_id" "uuid" NOT NULL,
    "resource_id" "uuid",
    "customer_name" "text" NOT NULL,
    "customer_email" "text" NOT NULL,
    "customer_phone" "text",
    "start_time" timestamp with time zone NOT NULL,
    "end_time" timestamp with time zone NOT NULL,
    "status" "text" DEFAULT 'confirmed'::"text" NOT NULL,
    "google_event_id" "text",
    "meeting_link" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "service_id" "uuid",
    "professional_id" "uuid",
    "room_id" "uuid",
    "client_id" "uuid",
    "total_price" numeric DEFAULT 0,
    "payment_status" "text" DEFAULT 'pending'::"text",
    "deposit_paid" numeric DEFAULT 0,
    "coupon_id" "uuid",
    "discount_amount" numeric DEFAULT 0,
    "quote_id" "uuid",
    "form_responses" "jsonb" DEFAULT '{}'::"jsonb",
    "booking_type" "text" DEFAULT 'service'::"text",
    CONSTRAINT "bookings_payment_status_check" CHECK (("payment_status" = ANY (ARRAY['pending'::"text", 'partial'::"text", 'paid'::"text", 'refunded'::"text"]))),
    CONSTRAINT "bookings_status_check" CHECK (("status" = ANY (ARRAY['confirmed'::"text", 'cancelled'::"text", 'pending'::"text", 'rescheduled'::"text"])))
);


ALTER TABLE "public"."bookings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_assignments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "company_member_id" "uuid" NOT NULL,
    "assigned_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "assigned_by" "uuid"
);


ALTER TABLE "public"."client_assignments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_clinical_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "content" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid" DEFAULT "auth"."uid"()
);


ALTER TABLE "public"."client_clinical_notes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_contacts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "name" "text" NOT NULL,
    "email" "text",
    "phone" "text",
    "role" "text",
    "is_primary" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."client_contacts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_documents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "file_path" "text" NOT NULL,
    "file_type" "text",
    "size" bigint,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "created_by" "uuid"
);


ALTER TABLE "public"."client_documents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "company_id" "uuid" NOT NULL,
    "author_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "key_id" "uuid" NOT NULL,
    "nonce" "bytea" NOT NULL,
    "encrypted_content" "bytea" NOT NULL
);


ALTER TABLE "public"."client_notes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_portal_users" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "email" "text" NOT NULL,
    "auth_user_id" "uuid",
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid"
);


ALTER TABLE "public"."client_portal_users" OWNER TO "postgres";


COMMENT ON TABLE "public"."client_portal_users" IS 'Maps a login email to a specific client within a company for client portal scoping.';



CREATE TABLE IF NOT EXISTS "public"."client_variant_assignments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "service_id" "uuid" NOT NULL,
    "variant_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid"
);


ALTER TABLE "public"."client_variant_assignments" OWNER TO "postgres";


COMMENT ON TABLE "public"."client_variant_assignments" IS 'Asignaciones de variantes personalizadas a clientes específicos. Si un cliente tiene una asignación, solo verá esa variante.';



CREATE TABLE IF NOT EXISTS "public"."clients" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "email" "text",
    "phone" "text",
    "address" "jsonb" DEFAULT '{}'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone,
    "surname" character varying(200),
    "dni" character varying(50),
    "marketing_consent" boolean DEFAULT false,
    "marketing_consent_date" timestamp with time zone,
    "marketing_consent_method" "text",
    "data_processing_consent" boolean DEFAULT false,
    "data_processing_consent_date" timestamp with time zone DEFAULT "now"(),
    "data_processing_legal_basis" "text" DEFAULT 'contract'::"text",
    "data_retention_until" timestamp with time zone,
    "deletion_requested_at" timestamp with time zone,
    "deletion_reason" "text",
    "anonymized_at" timestamp with time zone,
    "is_minor" boolean DEFAULT false,
    "parental_consent_verified" boolean DEFAULT false,
    "parental_consent_date" timestamp with time zone,
    "data_minimization_applied" boolean DEFAULT false,
    "last_data_review_date" timestamp with time zone,
    "access_restrictions" "jsonb" DEFAULT '{}'::"jsonb",
    "last_accessed_at" timestamp with time zone,
    "access_count" integer DEFAULT 0,
    "is_active" boolean DEFAULT true,
    "direccion_id" "uuid",
    "client_type" "text" DEFAULT 'individual'::"text" NOT NULL,
    "business_name" "text",
    "cif_nif" "text",
    "trade_name" "text",
    "legal_representative_name" "text",
    "legal_representative_dni" "text",
    "mercantile_registry_data" "jsonb" DEFAULT '{}'::"jsonb",
    "auth_user_id" "uuid",
    "birth_date" "date",
    "payment_method" "text",
    "payment_terms" "text",
    "iban" "text",
    "bic" "text",
    "currency" "text" DEFAULT 'EUR'::"text",
    "tax_region" "text",
    "billing_email" "text",
    "status" "text" DEFAULT 'lead'::"text",
    "source" "text",
    "assigned_to" "uuid",
    "industry" "text",
    "tags" "text"[],
    "website" "text",
    "language" "text" DEFAULT 'es'::"text",
    "internal_notes" "text",
    "credit_limit" numeric(10,2) DEFAULT 0,
    "default_discount" numeric(5,2) DEFAULT 0,
    "tier" "text" DEFAULT 'C'::"text",
    "consent_status" "public"."consent_status" DEFAULT 'pending'::"public"."consent_status",
    "consent_date" timestamp with time zone,
    "consent_ip" "text",
    "privacy_policy_version" "text",
    "invitation_token" "uuid",
    "invitation_sent_at" timestamp with time zone,
    "invitation_status" "public"."invitation_status" DEFAULT 'not_sent'::"public"."invitation_status",
    "health_data_consent" boolean DEFAULT false
);


ALTER TABLE "public"."clients" OWNER TO "postgres";


COMMENT ON COLUMN "public"."clients"."auth_user_id" IS 'Links client to auth.users for portal login capability';



COMMENT ON COLUMN "public"."clients"."birth_date" IS 'Client date of birth for marketing automation';



CREATE TABLE IF NOT EXISTS "public"."professionals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "company_id" "uuid" NOT NULL,
    "display_name" "text" NOT NULL,
    "title" "text",
    "bio" "text",
    "avatar_url" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "email" "text",
    CONSTRAINT "professionals_user_or_email_check" CHECK ((("user_id" IS NOT NULL) OR ("email" IS NOT NULL)))
);


ALTER TABLE "public"."professionals" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."client_visible_bookings" WITH ("security_invoker"='true') AS
 SELECT "b"."id",
    "b"."company_id",
    "b"."client_id",
    "b"."service_id",
    "b"."professional_id",
    "b"."start_time",
    "b"."end_time",
    "b"."status",
    "b"."payment_status",
    "b"."total_price",
    "b"."customer_email",
    "b"."created_at",
    "s"."name" AS "service_name",
    "s"."duration_minutes" AS "service_duration",
    "p"."display_name" AS "professional_name"
   FROM (("public"."bookings" "b"
     JOIN "public"."services" "s" ON (("b"."service_id" = "s"."id")))
     LEFT JOIN "public"."professionals" "p" ON (("b"."professional_id" = "p"."id")))
  WHERE (("p"."company_id" = "b"."company_id") AND (("b"."client_id" IN ( SELECT "clients"."id"
           FROM "public"."clients"
          WHERE ("clients"."auth_user_id" = "auth"."uid"()))) OR ("b"."customer_email" = ("auth"."jwt"() ->> 'email'::"text"))));


ALTER VIEW "public"."client_visible_bookings" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."client_visible_quotes" WITH ("security_invoker"='true') AS
 SELECT "id",
    "company_id",
    "client_id",
    "quote_number",
    "year",
    "sequence_number",
    "status",
    "quote_date",
    "valid_until",
    "accepted_at",
    "rejected_at",
    "invoiced_at",
    "invoice_id",
    "title",
    "description",
    "notes",
    "terms_conditions",
    "subtotal",
    "tax_amount",
    "total_amount",
    "discount_percent",
    "discount_amount",
    "currency",
    "language",
    "client_viewed_at",
    "client_ip_address",
    "client_user_agent",
    "pdf_url",
    "pdf_generated_at",
    "digital_signature",
    "signature_timestamp",
    "created_by",
    "created_at",
    "updated_at",
    "is_anonymized",
    "anonymized_at",
    "retention_until",
    "convert_policy",
    "deposit_percentage",
    "invoice_on_date",
    "conversion_status",
    "ticket_id",
    "recurrence_type",
    "recurrence_interval",
    "recurrence_day",
    "recurrence_start_date",
    "recurrence_end_date",
    "next_run_at",
    "last_run_at",
    "quote_month",
    "rectifies_invoice_id",
    "scheduled_conversion_date",
    "rectification_reason",
    "full_quote_number"
   FROM "public"."client_get_visible_quotes"() "client_get_visible_quotes"("id", "company_id", "client_id", "quote_number", "year", "sequence_number", "status", "quote_date", "valid_until", "accepted_at", "rejected_at", "invoiced_at", "invoice_id", "title", "description", "notes", "terms_conditions", "subtotal", "tax_amount", "total_amount", "discount_percent", "discount_amount", "currency", "language", "client_viewed_at", "client_ip_address", "client_user_agent", "pdf_url", "pdf_generated_at", "digital_signature", "signature_timestamp", "created_by", "created_at", "updated_at", "is_anonymized", "anonymized_at", "retention_until", "convert_policy", "deposit_percentage", "invoice_on_date", "conversion_status", "ticket_id", "recurrence_type", "recurrence_interval", "recurrence_day", "recurrence_start_date", "recurrence_end_date", "next_run_at", "last_run_at", "quote_month", "rectifies_invoice_id", "scheduled_conversion_date", "rectification_reason", "full_quote_number");


ALTER VIEW "public"."client_visible_quotes" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."client_visible_services" WITH ("security_invoker"='true') AS
 SELECT "id",
    "name",
    "description",
    "estimated_hours",
    "base_price",
    "created_at",
    "updated_at",
    "deleted_at",
    "is_active",
    "category",
    "legacy_negocio_id",
    "company_id",
    "tax_rate",
    "unit_type",
    "min_quantity",
    "max_quantity",
    "difficulty_level",
    "profit_margin",
    "cost_price",
    "requires_parts",
    "requires_diagnosis",
    "warranty_days",
    "skill_requirements",
    "tools_required",
    "can_be_remote",
    "priority_level",
    "has_variants",
    "base_features",
    "is_public",
    "features"
   FROM "public"."services" "s"
  WHERE ("is_public" = true);


ALTER VIEW "public"."client_visible_services" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."client_visible_tickets" WITH ("security_invoker"='true') AS
 SELECT "id",
    "ticket_number",
    "client_id",
    "company_id",
    "stage_id",
    "title",
    "description",
    "priority",
    "due_date",
    "comments",
    "total_amount",
    "created_at",
    "updated_at",
    "deleted_at",
    "estimated_hours",
    "actual_hours",
    "is_opened"
   FROM "public"."client_get_visible_tickets"() "client_get_visible_tickets"("id", "ticket_number", "client_id", "company_id", "stage_id", "title", "description", "priority", "due_date", "comments", "total_amount", "created_at", "updated_at", "deleted_at", "estimated_hours", "actual_hours", "is_opened");


ALTER VIEW "public"."client_visible_tickets" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."clients_tags" (
    "client_id" "uuid" NOT NULL,
    "tag_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."clients_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."company_members" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "company_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'active'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "role_id" "uuid",
    CONSTRAINT "company_members_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'invited'::"text", 'suspended'::"text", 'pending'::"text"])))
);


ALTER TABLE "public"."company_members" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."company_modules" (
    "company_id" "uuid" NOT NULL,
    "module_key" "text" NOT NULL,
    "status" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "company_modules_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'inactive'::"text"])))
);


ALTER TABLE "public"."company_modules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."company_settings" (
    "company_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "convert_policy" "text",
    "ask_before_convert" boolean,
    "enforce_company_defaults" boolean DEFAULT false NOT NULL,
    "payment_terms" "text",
    "invoice_on_date" "date",
    "default_invoice_delay_days" integer,
    "prices_include_tax" boolean,
    "iva_enabled" boolean,
    "iva_rate" numeric,
    "irpf_enabled" boolean,
    "irpf_rate" numeric,
    "auto_send_quote_email" boolean DEFAULT false,
    "allow_direct_contracting" boolean DEFAULT false,
    "copy_features_between_variants" boolean DEFAULT false,
    "allow_local_payment" boolean DEFAULT false,
    "ticket_stage_on_delete" "uuid",
    "ticket_stage_on_staff_reply" "uuid",
    "ticket_stage_on_client_reply" "uuid",
    "ticket_client_view_estimated_hours" boolean DEFAULT true,
    "ticket_client_can_close" boolean DEFAULT true,
    "ticket_client_can_create_devices" boolean DEFAULT true,
    "ticket_default_internal_comment" boolean DEFAULT false,
    "ticket_auto_assign_on_reply" boolean DEFAULT false,
    "agent_module_access" "jsonb" DEFAULT '["dashboard", "clients", "moduloSAT", "moduloFacturas", "moduloPresupuestos", "moduloServicios", "moduloProductos", "moduloChat", "moduloAnaliticas"]'::"jsonb",
    "payment_integrations" "text"[] DEFAULT '{stripe,cash}'::"text"[],
    "booking_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "automation" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "company_settings_convert_policy_check" CHECK (("convert_policy" = ANY (ARRAY['manual'::"text", 'on_accept'::"text", 'automatic'::"text", 'scheduled'::"text"])))
);


ALTER TABLE "public"."company_settings" OWNER TO "postgres";


COMMENT ON COLUMN "public"."company_settings"."copy_features_between_variants" IS 'If true, features are copied between variants in services';



COMMENT ON COLUMN "public"."company_settings"."allow_local_payment" IS 'Permite a los clientes registrar pagos en efectivo/local';



COMMENT ON COLUMN "public"."company_settings"."automation" IS 'Stores configuration for automated communications like reminders and reviews.';



CREATE TABLE IF NOT EXISTS "public"."company_stage_order" (
    "company_id" "uuid" NOT NULL,
    "stage_id" "uuid" NOT NULL,
    "position" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."company_stage_order" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."company_ticket_sequences" (
    "company_id" "uuid" NOT NULL,
    "last_val" integer DEFAULT 0,
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."company_ticket_sequences" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."content_posts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "status" "public"."content_status" DEFAULT 'idea'::"public"."content_status",
    "platform" "text" NOT NULL,
    "scheduled_date" timestamp with time zone,
    "content_url" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."content_posts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contract_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "content_html" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."contract_templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contracts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "content_html" "text" NOT NULL,
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "signature_data" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "signed_pdf_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "signed_at" timestamp with time zone,
    "created_by" "uuid",
    CONSTRAINT "contracts_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'sent'::"text", 'signed'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."contracts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coupons" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "code" "text" NOT NULL,
    "discount_type" "text" NOT NULL,
    "discount_value" numeric NOT NULL,
    "start_date" timestamp with time zone,
    "end_date" timestamp with time zone,
    "usage_limit" integer,
    "usage_count" integer DEFAULT 0,
    "active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "coupons_discount_type_check" CHECK (("discount_type" = ANY (ARRAY['percent'::"text", 'fixed'::"text"])))
);


ALTER TABLE "public"."coupons" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."device_components" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "device_id" "uuid" NOT NULL,
    "component_name" character varying(100) NOT NULL,
    "component_status" character varying(50) NOT NULL,
    "replacement_needed" boolean DEFAULT false,
    "replacement_cost" numeric(10,2),
    "supplier" character varying(100),
    "part_number" character varying(100),
    "installed_at" timestamp with time zone,
    "warranty_months" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "notes" "text"
);


ALTER TABLE "public"."device_components" OWNER TO "postgres";


COMMENT ON TABLE "public"."device_components" IS 'Gestión detallada de componentes y partes de dispositivos';



CREATE TABLE IF NOT EXISTS "public"."device_media" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "device_id" "uuid" NOT NULL,
    "media_type" character varying(20) NOT NULL,
    "file_url" "text" NOT NULL,
    "file_name" character varying(255),
    "file_size" integer,
    "mime_type" character varying(100),
    "media_context" character varying(50),
    "description" "text",
    "taken_by" "uuid",
    "taken_at" timestamp with time zone DEFAULT "now"(),
    "ai_analysis" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "ticket_device_id" "uuid"
);


ALTER TABLE "public"."device_media" OWNER TO "postgres";


COMMENT ON TABLE "public"."device_media" IS 'Imágenes y documentos asociados a dispositivos';



COMMENT ON COLUMN "public"."device_media"."ticket_device_id" IS 'Links this media to a specific ticket-device relationship. Captures device state at the time of repair.';



CREATE TABLE IF NOT EXISTS "public"."device_status_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "device_id" "uuid" NOT NULL,
    "previous_status" character varying(50),
    "new_status" character varying(50) NOT NULL,
    "changed_by" "uuid",
    "changed_at" timestamp with time zone DEFAULT "now"(),
    "notes" "text",
    "location" character varying(100),
    "technician_notes" "text"
);


ALTER TABLE "public"."device_status_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."device_status_history" IS 'Historial completo de cambios de estado de dispositivos';



CREATE TABLE IF NOT EXISTS "public"."domains" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "domain" "text" NOT NULL,
    "is_verified" boolean DEFAULT false,
    "verification_record" "text",
    "dkim_record" "text",
    "spf_record" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "company_id" "uuid",
    "status" "text" DEFAULT 'pending_verification'::"text",
    "provider" "text" DEFAULT 'manual'::"text"
);


ALTER TABLE "public"."domains" OWNER TO "postgres";


COMMENT ON COLUMN "public"."domains"."status" IS 'Status of the domain verification (e.g. pending_verification, verified, failed)';



COMMENT ON COLUMN "public"."domains"."provider" IS 'Provider of the domain (e.g. aws, manual)';



CREATE TABLE IF NOT EXISTS "public"."employee_commissions_config" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "employee_id" "uuid" NOT NULL,
    "service_id" "uuid" NOT NULL,
    "commission_percentage" numeric(5,2) DEFAULT 0,
    "fixed_amount" numeric(10,2) DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."employee_commissions_config" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."employee_documents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "employee_id" "uuid" NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" character varying(255) NOT NULL,
    "file_path" character varying(500) NOT NULL,
    "file_type" character varying(50),
    "uploaded_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."employee_documents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."employee_productivity_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "employee_id" "uuid" NOT NULL,
    "booking_id" "uuid",
    "service_name" "text" NOT NULL,
    "service_price" numeric(10,2) NOT NULL,
    "calculated_commission" numeric(10,2) DEFAULT 0 NOT NULL,
    "performed_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."employee_productivity_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."employees" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "nif" character varying(20),
    "social_security_number" character varying(50),
    "iban" character varying(50),
    "job_title" character varying(100),
    "hire_date" "date",
    "contract_type" character varying(50) DEFAULT 'indefinido'::character varying,
    "salary_base" numeric(10,2),
    "commission_rate" numeric(5,2) DEFAULT 0,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."employees" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gdpr_access_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "request_type" "text" NOT NULL,
    "subject_email" "text" NOT NULL,
    "subject_name" "text",
    "subject_identifier" "text",
    "company_id" "uuid",
    "requested_by" "uuid",
    "request_details" "jsonb" DEFAULT '{}'::"jsonb",
    "verification_method" "text",
    "verification_status" "text" DEFAULT 'pending'::"text",
    "processing_status" "text" DEFAULT 'received'::"text",
    "response_data" "jsonb",
    "response_file_url" "text",
    "legal_basis_for_delay" "text",
    "deadline_date" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "valid_processing_status" CHECK (("processing_status" = ANY (ARRAY['received'::"text", 'in_progress'::"text", 'completed'::"text", 'rejected'::"text"]))),
    CONSTRAINT "valid_request_type" CHECK (("request_type" = ANY (ARRAY['access'::"text", 'rectification'::"text", 'erasure'::"text", 'portability'::"text", 'restriction'::"text", 'objection'::"text"]))),
    CONSTRAINT "valid_verification_status" CHECK (("verification_status" = ANY (ARRAY['pending'::"text", 'verified'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."gdpr_access_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gdpr_audit_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "company_id" "uuid",
    "action_type" "text" NOT NULL,
    "table_name" "text" NOT NULL,
    "record_id" "uuid",
    "subject_email" "text",
    "old_values" "jsonb",
    "new_values" "jsonb",
    "legal_basis" "text",
    "purpose" "text",
    "ip_address" "inet",
    "user_agent" "text",
    "session_id" "text",
    "request_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."gdpr_audit_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gdpr_breach_incidents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "incident_reference" "text" NOT NULL,
    "breach_type" "text"[] NOT NULL,
    "discovered_at" timestamp with time zone NOT NULL,
    "reported_at" timestamp with time zone,
    "reported_to_dpa" boolean DEFAULT false,
    "dpa_reference" "text",
    "data_subjects_notified" boolean DEFAULT false,
    "notification_method" "text",
    "affected_data_categories" "text"[],
    "estimated_affected_subjects" integer,
    "likely_consequences" "text",
    "mitigation_measures" "text",
    "preventive_measures" "text",
    "severity_level" "text",
    "company_id" "uuid",
    "reported_by" "uuid",
    "incident_details" "jsonb" DEFAULT '{}'::"jsonb",
    "resolution_status" "text" DEFAULT 'open'::"text",
    "resolved_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "valid_resolution_status" CHECK (("resolution_status" = ANY (ARRAY['open'::"text", 'investigating'::"text", 'contained'::"text", 'resolved'::"text"]))),
    CONSTRAINT "valid_severity" CHECK (("severity_level" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'critical'::"text"])))
);


ALTER TABLE "public"."gdpr_breach_incidents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gdpr_consent_records" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "subject_id" "uuid",
    "subject_email" "text" NOT NULL,
    "consent_type" "text" NOT NULL,
    "purpose" "text" NOT NULL,
    "consent_given" boolean NOT NULL,
    "consent_method" "text" NOT NULL,
    "consent_evidence" "jsonb" DEFAULT '{}'::"jsonb",
    "withdrawn_at" timestamp with time zone,
    "withdrawal_method" "text",
    "withdrawal_evidence" "jsonb" DEFAULT '{}'::"jsonb",
    "company_id" "uuid",
    "processed_by" "uuid",
    "legal_basis" "text",
    "data_processing_purposes" "text"[],
    "retention_period" interval,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean GENERATED ALWAYS AS (("withdrawn_at" IS NULL)) STORED
);


ALTER TABLE "public"."gdpr_consent_records" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."gdpr_consent_overview" WITH ("security_invoker"='true') AS
 SELECT "cr"."subject_email",
    "cr"."consent_type",
    "cr"."purpose",
    "cr"."consent_given",
    "cr"."consent_method",
    "cr"."created_at" AS "consent_date",
    "cr"."withdrawn_at",
    "cr"."is_active",
    "c"."name" AS "client_name"
   FROM ("public"."gdpr_consent_records" "cr"
     LEFT JOIN "public"."clients" "c" ON (("c"."email" = "cr"."subject_email")))
  WHERE ("cr"."company_id" IN ( SELECT "users"."company_id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"())))
  ORDER BY "cr"."created_at" DESC;


ALTER VIEW "public"."gdpr_consent_overview" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gdpr_consent_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "token" "text" DEFAULT ("gen_random_uuid"())::"text" NOT NULL,
    "client_id" "uuid",
    "subject_email" "text" NOT NULL,
    "company_id" "uuid" NOT NULL,
    "consent_types" "text"[] NOT NULL,
    "purpose" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone DEFAULT ("now"() + '30 days'::interval),
    "accepted_at" timestamp with time zone,
    "evidence" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "gdpr_consent_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'accepted'::"text", 'declined'::"text", 'expired'::"text"])))
);


ALTER TABLE "public"."gdpr_consent_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."gdpr_processing_activities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "activity_name" "text" NOT NULL,
    "purpose" "text" NOT NULL,
    "legal_basis" "text" NOT NULL,
    "data_categories" "text"[] NOT NULL,
    "data_subjects" "text"[] NOT NULL,
    "recipients" "text"[],
    "retention_period" interval,
    "security_measures" "jsonb" DEFAULT '{}'::"jsonb",
    "cross_border_transfers" "jsonb" DEFAULT '{}'::"jsonb",
    "dpo_assessment" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true,
    "company_id" "uuid"
);


ALTER TABLE "public"."gdpr_processing_activities" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."gdpr_processing_inventory" WITH ("security_invoker"='true') AS
 SELECT "pa"."activity_name",
    "pa"."purpose",
    "pa"."legal_basis",
    "pa"."data_categories",
    "pa"."data_subjects",
    "pa"."recipients",
    "pa"."retention_period",
    "pa"."cross_border_transfers",
    "count"(DISTINCT "c"."id") AS "affected_subjects_count",
    "pa"."created_at",
    "pa"."updated_at"
   FROM ("public"."gdpr_processing_activities" "pa"
     LEFT JOIN "public"."clients" "c" ON (("c"."company_id" IN ( SELECT "companies"."id"
           FROM "public"."companies"
          WHERE ("companies"."id" IN ( SELECT "users"."company_id"
                   FROM "public"."users"
                  WHERE ("users"."auth_user_id" = "auth"."uid"())))))))
  WHERE ("pa"."is_active" = true)
  GROUP BY "pa"."id", "pa"."activity_name", "pa"."purpose", "pa"."legal_basis", "pa"."data_categories", "pa"."data_subjects", "pa"."recipients", "pa"."retention_period", "pa"."cross_border_transfers", "pa"."created_at", "pa"."updated_at";


ALTER VIEW "public"."gdpr_processing_inventory" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."global_tags" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "color" "text" NOT NULL,
    "category" "text",
    "scope" "text"[],
    "description" "text",
    "company_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "category_color" "text" DEFAULT '#6B7280'::"text"
);


ALTER TABLE "public"."global_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."google_calendar_configs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "calendar_id" "text",
    "calendar_id_booking" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."google_calendar_configs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."hidden_stages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "stage_id" "uuid" NOT NULL,
    "hidden_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "hidden_by" "uuid"
);


ALTER TABLE "public"."hidden_stages" OWNER TO "postgres";


COMMENT ON TABLE "public"."hidden_stages" IS 'Almacena qué estados genéricos del sistema ha ocultado cada empresa. Las operaciones se gestionan mediante la Edge Function hide-stage que valida y escribe con service_role.';



COMMENT ON COLUMN "public"."hidden_stages"."company_id" IS 'ID de la empresa que oculta el estado';



COMMENT ON COLUMN "public"."hidden_stages"."stage_id" IS 'ID del estado genérico que se oculta (debe tener company_id = NULL)';



COMMENT ON COLUMN "public"."hidden_stages"."hidden_at" IS 'Fecha y hora en que se ocultó el estado';



COMMENT ON COLUMN "public"."hidden_stages"."hidden_by" IS 'Usuario que ocultó el estado';



CREATE TABLE IF NOT EXISTS "public"."hidden_units" (
    "company_id" "uuid" NOT NULL,
    "unit_id" "uuid" NOT NULL,
    "hidden_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."hidden_units" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."integrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "provider" "text" NOT NULL,
    "access_token" "text" NOT NULL,
    "refresh_token" "text",
    "expires_at" timestamp with time zone NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "company_id" "uuid",
    "provider_email" "text",
    CONSTRAINT "integrations_provider_check" CHECK (("provider" = 'google_calendar'::"text"))
);


ALTER TABLE "public"."integrations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."invoice_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "invoice_id" "uuid" NOT NULL,
    "line_order" integer DEFAULT 0 NOT NULL,
    "description" "text" NOT NULL,
    "quantity" numeric(12,3) DEFAULT 1 NOT NULL,
    "unit_price" numeric(12,2) NOT NULL,
    "discount_percent" numeric(5,2) DEFAULT 0 NOT NULL,
    "tax_rate" numeric(5,2) DEFAULT 21.00 NOT NULL,
    "tax_amount" numeric(12,2) NOT NULL,
    "subtotal" numeric(12,2) NOT NULL,
    "total" numeric(12,2) NOT NULL,
    "product_id" "uuid",
    "service_id" "uuid",
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "valid_discount" CHECK ((("discount_percent" >= (0)::numeric) AND ("discount_percent" <= (100)::numeric))),
    CONSTRAINT "valid_item_total" CHECK (("total" = ("subtotal" + "tax_amount"))),
    CONSTRAINT "valid_quantity_nonzero" CHECK (("quantity" <> (0)::numeric)),
    CONSTRAINT "valid_tax_rate" CHECK ((("tax_rate" >= (0)::numeric) AND ("tax_rate" <= (100)::numeric))),
    CONSTRAINT "valid_unit_price" CHECK (("unit_price" >= (0)::numeric))
);


ALTER TABLE "public"."invoice_items" OWNER TO "postgres";


COMMENT ON TABLE "public"."invoice_items" IS 'Líneas/conceptos de las facturas';



CREATE TABLE IF NOT EXISTS "public"."invoice_meta" (
    "invoice_id" "uuid" NOT NULL,
    "status" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."invoice_meta" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."invoice_payments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "invoice_id" "uuid" NOT NULL,
    "payment_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "amount" numeric(12,2) NOT NULL,
    "payment_method" "public"."payment_method" NOT NULL,
    "reference" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "created_by" "uuid",
    CONSTRAINT "valid_payment_amount" CHECK (("amount" > (0)::numeric))
);


ALTER TABLE "public"."invoice_payments" OWNER TO "postgres";


COMMENT ON TABLE "public"."invoice_payments" IS 'Pagos recibidos de facturas';



CREATE TABLE IF NOT EXISTS "public"."invoice_series" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "series_code" "text" NOT NULL,
    "series_name" "text" NOT NULL,
    "year" integer DEFAULT EXTRACT(year FROM CURRENT_DATE) NOT NULL,
    "prefix" "text" NOT NULL,
    "next_number" integer DEFAULT 1 NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "is_default" boolean DEFAULT false NOT NULL,
    "verifactu_enabled" boolean DEFAULT true NOT NULL,
    "last_verifactu_hash" "text",
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "created_by" "uuid"
);


ALTER TABLE "public"."invoice_series" OWNER TO "postgres";


COMMENT ON TABLE "public"."invoice_series" IS 'Series de facturación con numeración automática';



CREATE TABLE IF NOT EXISTS "public"."invoice_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "is_default" boolean DEFAULT false NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "html_template" "text" NOT NULL,
    "css_styles" "text",
    "show_company_logo" boolean DEFAULT true NOT NULL,
    "show_payment_info" boolean DEFAULT true NOT NULL,
    "show_tax_breakdown" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    "created_by" "uuid"
);


ALTER TABLE "public"."invoice_templates" OWNER TO "postgres";


COMMENT ON TABLE "public"."invoice_templates" IS 'Plantillas de diseño para PDFs de facturas';



CREATE OR REPLACE VIEW "public"."invoiceseries" WITH ("security_invoker"='true') AS
 SELECT "id",
    "company_id",
    "series_code",
    "series_name",
    "year",
    "prefix",
    "next_number",
    "is_active",
    "is_default",
    "verifactu_enabled",
    "last_verifactu_hash",
    "created_at",
    "updated_at",
    "created_by"
   FROM "public"."invoice_series";


ALTER VIEW "public"."invoiceseries" OWNER TO "postgres";


COMMENT ON VIEW "public"."invoiceseries" IS 'Compatibility view for legacy code that referenced invoiceseries (maps to invoice_series)';



CREATE TABLE IF NOT EXISTS "public"."item_tags" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "tag_id" "uuid" NOT NULL,
    "record_id" "uuid" NOT NULL,
    "record_type" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid"
);


ALTER TABLE "public"."item_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."job_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "job_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "note" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "company_id" "uuid" NOT NULL
);


ALTER TABLE "public"."job_notes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."lead_interactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "lead_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "type" "text" NOT NULL,
    "summary" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."lead_interactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."lead_sources" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."lead_sources" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."leads" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "account_id" "uuid",
    "company_id" "uuid" NOT NULL,
    "source" "public"."lead_source" DEFAULT 'other'::"public"."lead_source" NOT NULL,
    "status" "public"."lead_status" DEFAULT 'new'::"public"."lead_status" NOT NULL,
    "first_name" "text",
    "last_name" "text",
    "email" "text",
    "phone" "text",
    "interest" "text",
    "notes" "text",
    "assigned_to" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "lead_source_id" "uuid",
    "gdpr_consent_sent_at" timestamp with time zone,
    "gdpr_accepted" boolean DEFAULT false
);


ALTER TABLE "public"."leads" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."loyalty_points" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "company_id" "uuid",
    "customer_id" "uuid",
    "points" integer NOT NULL,
    "reason" "text" NOT NULL,
    "booking_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "source" "text"
);


ALTER TABLE "public"."loyalty_points" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mail_accounts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "email" "text" NOT NULL,
    "provider" "text" NOT NULL,
    "sender_name" "text",
    "settings" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "mail_accounts_provider_check" CHECK (("provider" = ANY (ARRAY['ses'::"text", 'smtp'::"text", 'gmail_import'::"text"])))
);


ALTER TABLE "public"."mail_accounts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mail_attachments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "message_id" "uuid" NOT NULL,
    "filename" "text" NOT NULL,
    "size" integer,
    "content_type" "text",
    "storage_path" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."mail_attachments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mail_contacts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "name" "text",
    "email" "text" NOT NULL,
    "phone" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."mail_contacts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mail_folders" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "account_id" "uuid" NOT NULL,
    "parent_id" "uuid",
    "name" "text" NOT NULL,
    "path" "text" NOT NULL,
    "type" "text" NOT NULL,
    "system_role" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "mail_folders_type_check" CHECK (("type" = ANY (ARRAY['system'::"text", 'user'::"text"])))
);


ALTER TABLE "public"."mail_folders" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mail_threads" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "account_id" "uuid" NOT NULL,
    "subject" "text",
    "snippet" "text",
    "last_message_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."mail_threads" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."marketing_campaigns" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "type" "public"."campaign_type" DEFAULT 'email'::"public"."campaign_type" NOT NULL,
    "subject" "text",
    "content" "text" NOT NULL,
    "target_audience" "jsonb" DEFAULT '{}'::"jsonb",
    "status" "public"."campaign_status" DEFAULT 'draft'::"public"."campaign_status",
    "scheduled_at" timestamp with time zone,
    "sent_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "trigger_type" "public"."campaign_trigger_type" DEFAULT 'manual'::"public"."campaign_trigger_type",
    "is_active" boolean DEFAULT false,
    "config" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."marketing_campaigns" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."marketing_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "campaign_id" "uuid",
    "client_id" "uuid",
    "channel" "public"."campaign_type" NOT NULL,
    "sent_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" DEFAULT 'sent'::"text"
);


ALTER TABLE "public"."marketing_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."marketing_metrics" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "date" "date" NOT NULL,
    "channel" "text" NOT NULL,
    "spend" numeric DEFAULT 0,
    "impressions" integer DEFAULT 0,
    "clicks" integer DEFAULT 0,
    "leads_attributed" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "marketing_metrics_channel_check" CHECK (("channel" = ANY (ARRAY['google_ads'::"text", 'instagram_ads'::"text", 'tiktok_ads'::"text", 'organic'::"text", 'email'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."marketing_metrics" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."modules" (
    "key" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "enabled_by_default" boolean DEFAULT true,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "position" integer DEFAULT 0
);


ALTER TABLE "public"."modules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."modules_catalog" (
    "key" "text" NOT NULL,
    "label" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."modules_catalog" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notification_logs" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "company_id" "uuid",
    "booking_id" "uuid",
    "template_id" "uuid",
    "recipient" "text" NOT NULL,
    "channel" "text" NOT NULL,
    "status" "text" NOT NULL,
    "error_message" "text",
    "sent_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "notification_logs_status_check" CHECK (("status" = ANY (ARRAY['sent'::"text", 'failed'::"text", 'queued'::"text"])))
);


ALTER TABLE "public"."notification_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notification_templates" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "company_id" "uuid",
    "name" "text" NOT NULL,
    "type" "text" NOT NULL,
    "trigger_event" "text" NOT NULL,
    "subject" "text",
    "body" "text" NOT NULL,
    "active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "notification_templates_trigger_event_check" CHECK (("trigger_event" = ANY (ARRAY['booking_created'::"text", 'booking_cancelled'::"text", 'reminder_24h'::"text", 'reminder_1h'::"text", 'followup_review'::"text"]))),
    CONSTRAINT "notification_templates_type_check" CHECK (("type" = ANY (ARRAY['email'::"text", 'sms'::"text", 'whatsapp'::"text", 'push'::"text"])))
);


ALTER TABLE "public"."notification_templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "recipient_id" "uuid",
    "type" "text" NOT NULL,
    "reference_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "content" "text",
    "is_read" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "client_recipient_id" "uuid"
);


ALTER TABLE "public"."notifications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payment_integrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "provider" "text" NOT NULL,
    "is_active" boolean DEFAULT false NOT NULL,
    "is_sandbox" boolean DEFAULT true NOT NULL,
    "credentials_encrypted" "text" NOT NULL,
    "webhook_secret_encrypted" "text",
    "webhook_url" "text",
    "last_verified_at" timestamp with time zone,
    "verification_status" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "payment_integrations_provider_check" CHECK (("provider" = ANY (ARRAY['paypal'::"text", 'stripe'::"text"]))),
    CONSTRAINT "payment_integrations_verification_status_check" CHECK (("verification_status" = ANY (ARRAY['pending'::"text", 'verified'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."payment_integrations" OWNER TO "postgres";


COMMENT ON TABLE "public"."payment_integrations" IS 'Stores encrypted payment provider credentials (PayPal/Stripe) per company';



CREATE TABLE IF NOT EXISTS "public"."payment_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "invoice_id" "uuid" NOT NULL,
    "company_id" "uuid" NOT NULL,
    "provider" "text" NOT NULL,
    "external_id" "text",
    "amount" numeric(12,2) NOT NULL,
    "currency" "text" DEFAULT 'EUR'::"text" NOT NULL,
    "status" "text" NOT NULL,
    "provider_response" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "payment_transactions_provider_check" CHECK (("provider" = ANY (ARRAY['paypal'::"text", 'stripe'::"text", 'manual'::"text"]))),
    CONSTRAINT "payment_transactions_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'completed'::"text", 'failed'::"text", 'refunded'::"text"])))
);


ALTER TABLE "public"."payment_transactions" OWNER TO "postgres";


COMMENT ON TABLE "public"."payment_transactions" IS 'Records individual payment transactions for invoices';



CREATE TABLE IF NOT EXISTS "public"."product_brands" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "company_id" "uuid",
    "description" "text",
    "logo_url" "text",
    "website" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "deleted_at" timestamp with time zone
);


ALTER TABLE "public"."product_brands" OWNER TO "postgres";


COMMENT ON TABLE "public"."product_brands" IS 'Normalized table for product brands. Supports both global (company_id IS NULL) and company-specific brands.';



COMMENT ON COLUMN "public"."product_brands"."company_id" IS 'NULL for global brands, UUID for company-specific brands';



CREATE TABLE IF NOT EXISTS "public"."product_catalog" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "brand" "text",
    "model" "text",
    "category" "text",
    "sku" "text",
    "specs" "jsonb" DEFAULT '{}'::"jsonb",
    "compatibility" "jsonb" DEFAULT '[]'::"jsonb",
    "company_id" "uuid",
    "source" "text" DEFAULT 'manual'::"text",
    "image_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone,
    "search_vector" "tsvector" GENERATED ALWAYS AS ("to_tsvector"('"spanish"'::"regconfig", (((((("name" || ' '::"text") || COALESCE("brand", ''::"text")) || ' '::"text") || COALESCE("model", ''::"text")) || ' '::"text") || COALESCE("sku", ''::"text")))) STORED,
    "ean" "text",
    "embedding" "public"."vector"(768),
    "description" "text"
);


ALTER TABLE "public"."product_catalog" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."product_categories" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "company_id" "uuid",
    "description" "text",
    "parent_id" "uuid",
    "icon" "text",
    "color" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "deleted_at" timestamp with time zone
);


ALTER TABLE "public"."product_categories" OWNER TO "postgres";


COMMENT ON TABLE "public"."product_categories" IS 'Normalized table for product categories with hierarchical support. Supports both global and company-specific categories.';



COMMENT ON COLUMN "public"."product_categories"."parent_id" IS 'Allows for subcategories (e.g., Hardware > RAM)';



CREATE TABLE IF NOT EXISTS "public"."product_models" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "brand_id" "uuid" NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone
);


ALTER TABLE "public"."product_models" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."products" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(200) NOT NULL,
    "brand" character varying(100),
    "model" character varying(100),
    "description" "text",
    "price" numeric(10,2) DEFAULT 0.00,
    "stock_quantity" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone,
    "company_id" "uuid" NOT NULL,
    "brand_id" "uuid",
    "category_id" "uuid",
    "catalog_product_id" "uuid",
    "min_stock_level" integer DEFAULT 5,
    "barcode" "text",
    "location" "text"
);


ALTER TABLE "public"."products" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."professional_documents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "professional_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "file_url" "text" NOT NULL,
    "type" "text",
    "is_signed" boolean DEFAULT false,
    "signed_at" timestamp with time zone,
    "signature_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."professional_documents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."professional_schedules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "professional_id" "uuid" NOT NULL,
    "day_of_week" integer NOT NULL,
    "start_time" time without time zone,
    "end_time" time without time zone,
    "break_start" time without time zone,
    "break_end" time without time zone,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "professional_schedules_day_of_week_check" CHECK ((("day_of_week" >= 0) AND ("day_of_week" <= 6)))
);


ALTER TABLE "public"."professional_schedules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."professional_services" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "professional_id" "uuid" NOT NULL,
    "service_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."professional_services" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."professional_titles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."professional_titles" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."profiles" WITH ("security_invoker"='true') AS
 SELECT "u"."auth_user_id" AS "user_id",
    "u"."company_id",
    "ar"."name" AS "role",
    "u"."last_session_at"
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE ("u"."deleted_at" IS NULL);


ALTER VIEW "public"."profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_activity" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "company_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "client_id" "uuid",
    "activity_type" "text" NOT NULL,
    "details" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."project_activity" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_comments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "content" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "client_id" "uuid"
);


ALTER TABLE "public"."project_comments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_files" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "file_path" "text" NOT NULL,
    "file_type" "text",
    "size" bigint,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "is_folder" boolean DEFAULT false,
    "parent_id" "uuid"
);


ALTER TABLE "public"."project_files" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_notification_preferences" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "client_id" "uuid",
    "notify_on_new_task" boolean DEFAULT true,
    "notify_on_task_completed" boolean DEFAULT true,
    "notify_on_task_assigned" boolean DEFAULT true,
    "notify_on_new_comment" boolean DEFAULT true,
    "notify_on_project_update" boolean DEFAULT true,
    "notify_on_deadline_approaching" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "check_user_xor_client" CHECK (((("user_id" IS NOT NULL) AND ("client_id" IS NULL)) OR (("user_id" IS NULL) AND ("client_id" IS NOT NULL))))
);


ALTER TABLE "public"."project_notification_preferences" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_permissions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "client_can_create_tasks" boolean DEFAULT false,
    "client_can_edit_tasks" boolean DEFAULT false,
    "client_can_delete_tasks" boolean DEFAULT false,
    "client_can_assign_tasks" boolean DEFAULT false,
    "client_can_complete_tasks" boolean DEFAULT true,
    "client_can_comment" boolean DEFAULT true,
    "client_can_view_all_comments" boolean DEFAULT true,
    "client_can_edit_project" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "client_can_move_stage" boolean DEFAULT false
);


ALTER TABLE "public"."project_permissions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_reads" (
    "project_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "client_id" "uuid",
    "last_read_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "project_reads_user_or_client_check" CHECK (((("user_id" IS NOT NULL) AND ("client_id" IS NULL)) OR (("user_id" IS NULL) AND ("client_id" IS NOT NULL))))
);


ALTER TABLE "public"."project_reads" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_stages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "position" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "is_review" boolean DEFAULT false,
    "is_default" boolean DEFAULT false,
    "is_landing" boolean DEFAULT false,
    "is_final" boolean DEFAULT false
);


ALTER TABLE "public"."project_stages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."project_tasks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "is_completed" boolean DEFAULT false,
    "due_date" "date",
    "assigned_to" "uuid",
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "position" integer DEFAULT 0
);


ALTER TABLE "public"."project_tasks" OWNER TO "postgres";


COMMENT ON COLUMN "public"."project_tasks"."assigned_to" IS 'User ID (auth.users) or Client ID (clients.id) assigned to the task';



CREATE TABLE IF NOT EXISTS "public"."projects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "client_id" "uuid",
    "stage_id" "uuid",
    "name" "text" NOT NULL,
    "description" "text",
    "start_date" "date",
    "end_date" "date",
    "priority" "text",
    "position" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "is_archived" boolean DEFAULT false,
    "permissions" "jsonb" DEFAULT '{"client_can_comment": true, "client_can_edit_tasks": false, "client_can_assign_tasks": false, "client_can_create_tasks": false, "client_can_delete_tasks": false, "client_can_edit_project": false, "client_can_complete_tasks": true, "client_can_view_all_comments": true}'::"jsonb",
    "is_internal_archived" boolean DEFAULT false,
    CONSTRAINT "projects_priority_check" CHECK (("priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'critical'::"text"])))
);


ALTER TABLE "public"."projects" OWNER TO "postgres";


COMMENT ON COLUMN "public"."projects"."is_internal_archived" IS 'If true, this project is hidden from admin/staff dashboards but remains visible to clients.';



CREATE TABLE IF NOT EXISTS "public"."quote_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" character varying(200) NOT NULL,
    "description" "text",
    "title_template" character varying(500),
    "description_template" "text",
    "notes_template" "text",
    "terms_conditions_template" "text",
    "default_items" "jsonb",
    "default_valid_days" integer DEFAULT 30,
    "default_tax_rate" numeric(5,2) DEFAULT 21.00,
    "is_active" boolean DEFAULT true,
    "usage_count" integer DEFAULT 0,
    "last_used_at" timestamp with time zone,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."quote_templates" OWNER TO "postgres";


COMMENT ON TABLE "public"."quote_templates" IS 'Plantillas reutilizables para crear presupuestos rápidamente';



CREATE TABLE IF NOT EXISTS "public"."resources" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "type" "text" NOT NULL,
    "capacity" integer DEFAULT 1,
    "description" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."resources" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."role_permissions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "role" "text" NOT NULL,
    "permission" "text" NOT NULL,
    "granted" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "role_id" "uuid"
);


ALTER TABLE "public"."role_permissions" OWNER TO "postgres";


COMMENT ON TABLE "public"."role_permissions" IS 'Stores customizable permissions per role per company';



CREATE TABLE IF NOT EXISTS "public"."rooms" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "capacity" integer DEFAULT 1 NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."rooms" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."scheduled_jobs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "scheduled_at" timestamp with time zone NOT NULL,
    "executed_at" timestamp with time zone,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "job_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "retry_count" integer DEFAULT 0 NOT NULL,
    "last_error" "text",
    CONSTRAINT "scheduled_jobs_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'succeeded'::"text", 'failed'::"text", 'canceled'::"text"])))
);


ALTER TABLE "public"."scheduled_jobs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."scheduled_notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "booking_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "scheduled_for" timestamp with time zone NOT NULL,
    "sent_at" timestamp with time zone,
    "error" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "scheduled_notifications_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'failed'::"text"]))),
    CONSTRAINT "scheduled_notifications_type_check" CHECK (("type" = ANY (ARRAY['reminder_24h'::"text", 'reminder_1h'::"text", 'review_request'::"text"])))
);


ALTER TABLE "public"."scheduled_notifications" OWNER TO "postgres";


COMMENT ON TABLE "public"."scheduled_notifications" IS 'Tracks automated emails sent to clients to prevent duplicates.';



CREATE TABLE IF NOT EXISTS "public"."service_categories" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(100) NOT NULL,
    "color" character varying(7) DEFAULT '#6b7280'::character varying,
    "icon" character varying(50) DEFAULT 'fas fa-cog'::character varying,
    "description" "text",
    "company_id" "uuid" NOT NULL,
    "is_active" boolean DEFAULT true,
    "sort_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."service_categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."service_units" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "name" "text" NOT NULL,
    "code" "text" NOT NULL,
    "description" "text",
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "deleted_at" timestamp with time zone
);


ALTER TABLE "public"."service_units" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."service_variants" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "service_id" "uuid" NOT NULL,
    "variant_name" "text" NOT NULL,
    "estimated_hours" numeric DEFAULT 0,
    "cost_price" numeric DEFAULT 0,
    "profit_margin" numeric DEFAULT 30.00,
    "discount_percentage" numeric DEFAULT 0,
    "features" "jsonb" DEFAULT '{"limits": {}, "excluded": [], "included": []}'::"jsonb",
    "display_config" "jsonb" DEFAULT '{"badge": null, "color": null, "highlight": false}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "sort_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "pricing" "jsonb",
    "is_hidden" boolean DEFAULT false,
    CONSTRAINT "check_pricing_structure" CHECK ((("pricing" IS NULL) OR (("jsonb_typeof"("pricing") = 'array'::"text") AND ("jsonb_array_length"("pricing") > 0)))),
    CONSTRAINT "service_variants_cost_price_check" CHECK (("cost_price" >= (0)::numeric)),
    CONSTRAINT "service_variants_discount_percentage_check" CHECK ((("discount_percentage" >= (0)::numeric) AND ("discount_percentage" <= (100)::numeric))),
    CONSTRAINT "service_variants_profit_margin_check" CHECK ((("profit_margin" >= (0)::numeric) AND ("profit_margin" <= (100)::numeric)))
);


ALTER TABLE "public"."service_variants" OWNER TO "postgres";


COMMENT ON TABLE "public"."service_variants" IS 'Variantes de servicios: diferentes niveles (Esencial, Avanzado, Superior) y periodicidades (mensual, anual) de un mismo servicio base';



COMMENT ON COLUMN "public"."service_variants"."is_hidden" IS 'Si true, la variante no se muestra en el catálogo público';



CREATE TABLE IF NOT EXISTS "public"."services_tags" (
    "service_id" "uuid" NOT NULL,
    "tag_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."services_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."social_metrics" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "date" "date" NOT NULL,
    "platform" "text" NOT NULL,
    "followers" integer DEFAULT 0,
    "engagement_rate" numeric(5,2) DEFAULT 0,
    "posts_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "social_metrics_platform_check" CHECK (("platform" = ANY (ARRAY['instagram'::"text", 'tiktok'::"text", 'facebook'::"text", 'linkedin'::"text", 'google_business'::"text"])))
);


ALTER TABLE "public"."social_metrics" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stock_movements" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "product_id" "uuid" NOT NULL,
    "quantity_change" integer NOT NULL,
    "movement_type" "text" NOT NULL,
    "reference_id" "uuid",
    "user_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "stock_movements_movement_type_check" CHECK (("movement_type" = ANY (ARRAY['purchase'::"text", 'sale'::"text", 'adjustment'::"text", 'return'::"text", 'initial'::"text"])))
);


ALTER TABLE "public"."stock_movements" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."supplier_products" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "supplier_id" "uuid" NOT NULL,
    "catalog_product_id" "uuid" NOT NULL,
    "supplier_sku" "text",
    "price" numeric DEFAULT 0 NOT NULL,
    "currency" "text" DEFAULT 'EUR'::"text",
    "url" "text",
    "last_checked_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."supplier_products" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."suppliers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "email" "text",
    "phone" "text",
    "website" "text",
    "address" "text",
    "tax_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone
);


ALTER TABLE "public"."suppliers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tag_scopes" (
    "id" "text" NOT NULL,
    "label" "text" NOT NULL,
    "color" "text",
    "description" "text",
    "module_key" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."tag_scopes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ticket_comment_attachments" (
    "comment_id" "uuid" NOT NULL,
    "attachment_id" "uuid" NOT NULL,
    "linked_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ticket_comment_attachments" OWNER TO "postgres";


COMMENT ON TABLE "public"."ticket_comment_attachments" IS 'Link table between ticket_comments and attachments';



CREATE TABLE IF NOT EXISTS "public"."ticket_comment_versions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "comment_id" "uuid" NOT NULL,
    "content" "text" NOT NULL,
    "changed_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ticket_comment_versions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ticket_comments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ticket_id" "uuid" NOT NULL,
    "user_id" "uuid" DEFAULT "auth"."uid"(),
    "comment" "text" NOT NULL,
    "is_internal" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "client_id" "uuid",
    "parent_id" "uuid",
    "deleted_at" timestamp with time zone,
    "edited_at" timestamp with time zone
);


ALTER TABLE "public"."ticket_comments" OWNER TO "postgres";


COMMENT ON TABLE "public"."ticket_comments" IS 'Comments for tickets with multitenant RLS and author constraints';



CREATE TABLE IF NOT EXISTS "public"."ticket_devices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ticket_id" "uuid" NOT NULL,
    "device_id" "uuid" NOT NULL,
    "relation_type" character varying(50) DEFAULT 'repair'::character varying,
    "assigned_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "progress_percentage" integer DEFAULT 0,
    "current_task" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ticket_devices" OWNER TO "postgres";


COMMENT ON TABLE "public"."ticket_devices" IS 'Relación entre tickets y dispositivos para workflow completo';



CREATE TABLE IF NOT EXISTS "public"."ticket_macros" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "content" "text" NOT NULL,
    "created_by" "uuid",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ticket_macros" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ticket_products" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ticket_id" "uuid" NOT NULL,
    "product_id" "uuid",
    "quantity" integer DEFAULT 1 NOT NULL,
    "price_per_unit" numeric(12,2) DEFAULT 0 NOT NULL,
    "total_price" numeric(12,2) DEFAULT 0 NOT NULL,
    "company_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "catalog_product_id" "uuid",
    CONSTRAINT "ticket_products_quantity_check" CHECK (("quantity" > 0))
);


ALTER TABLE "public"."ticket_products" OWNER TO "postgres";


COMMENT ON TABLE "public"."ticket_products" IS 'Relación de productos asociados a tickets con cantidades y precios.';



COMMENT ON COLUMN "public"."ticket_products"."price_per_unit" IS 'Precio por unidad al momento de agregar el producto al ticket.';



COMMENT ON COLUMN "public"."ticket_products"."total_price" IS 'Cantidad * precio por unidad.';



CREATE TABLE IF NOT EXISTS "public"."ticket_services" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ticket_id" "uuid" NOT NULL,
    "service_id" "uuid" NOT NULL,
    "quantity" integer DEFAULT 1,
    "price_per_unit" numeric(10,2),
    "total_price" numeric(10,2),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "company_id" "uuid",
    "variant_id" "uuid"
);


ALTER TABLE "public"."ticket_services" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ticket_timeline" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ticket_id" "uuid" NOT NULL,
    "company_id" "uuid" NOT NULL,
    "actor_id" "uuid",
    "event_type" "text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "is_public" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ticket_timeline" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tickets_tags" (
    "ticket_id" "uuid" NOT NULL,
    "tag_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."tickets_tags" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."tickets_ticket_number_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."tickets_ticket_number_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."tickets_ticket_number_seq" OWNED BY "public"."tickets"."ticket_number";



CREATE OR REPLACE VIEW "public"."user_company_context" WITH ("security_invoker"='true') AS
 SELECT "auth"."uid"() AS "auth_user_id",
    "u"."company_id",
    "ar"."name" AS "role"
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"());


ALTER VIEW "public"."user_company_context" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_modules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "module_key" "text" NOT NULL,
    "status" "text" DEFAULT 'activado'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_modules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_preferences" (
    "user_id" "uuid" NOT NULL,
    "email_notifications" boolean DEFAULT true,
    "sms_notifications" boolean DEFAULT false,
    "marketing_accepted" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_preferences" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."users_with_company" WITH ("security_invoker"='true') AS
 SELECT "u"."id",
    "u"."email",
    "u"."name",
    "u"."surname",
    "u"."permissions",
    "u"."created_at" AS "user_created_at",
    "c"."id" AS "company_id",
    "c"."name" AS "company_name",
    "c"."website" AS "company_website",
    "c"."legacy_negocio_id"
   FROM ("public"."users" "u"
     JOIN "public"."companies" "c" ON (("u"."company_id" = "c"."id")))
  WHERE (("u"."deleted_at" IS NULL) AND ("c"."deleted_at" IS NULL) AND ("u"."company_id" IN ( SELECT "user_company_context"."company_id"
           FROM "public"."user_company_context")));


ALTER VIEW "public"."users_with_company" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_current_user_modules" WITH ("security_invoker"='true') AS
 SELECT "m"."key",
    "m"."name",
    "m"."description",
    "m"."enabled_by_default",
    "m"."is_active",
    "m"."created_at",
    "m"."updated_at",
    "m"."position"
   FROM ("public"."modules" "m"
     JOIN "jsonb_array_elements"("public"."get_effective_modules"()) "gem"("value") ON (("m"."key" = ("gem"."value" ->> 'key'::"text"))))
  WHERE ((("gem"."value" ->> 'enabled'::"text"))::boolean = true);


ALTER VIEW "public"."v_current_user_modules" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."valid_users_view" WITH ("security_invoker"='true') AS
 SELECT "p"."id",
    "p"."company_id",
    "p"."email",
    "p"."name",
    "ar"."name" AS "role",
    "p"."active",
    "p"."created_at",
    "p"."updated_at",
    "p"."deleted_at",
    "p"."permissions",
    "p"."auth_user_id",
    "p"."is_dpo",
    "p"."gdpr_training_completed",
    "p"."gdpr_training_date",
    "p"."data_access_level",
    "p"."last_privacy_policy_accepted",
    "p"."failed_login_attempts",
    "p"."account_locked_until",
    "p"."surname",
    "p"."last_session_at",
    ("a"."id" IS NOT NULL) AS "has_auth"
   FROM (("public"."users" "p"
     LEFT JOIN "auth"."users" "a" ON (("p"."id" = "a"."id")))
     LEFT JOIN "public"."app_roles" "ar" ON (("p"."app_role_id" = "ar"."id")));


ALTER VIEW "public"."valid_users_view" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."verifactu_cert_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "version" integer NOT NULL,
    "stored_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "rotated_by" "uuid",
    "cert_pem_enc" "text",
    "key_pem_enc" "text",
    "key_pass_enc" "text",
    "integrity_hash" "text",
    "notes" "text"
);


ALTER TABLE "public"."verifactu_cert_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."verifactu_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "companyid" "uuid" NOT NULL,
    "invoiceid" "uuid",
    "eventtype" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    CONSTRAINT "verifactu_events_eventtype_check" CHECK (("eventtype" = ANY (ARRAY['issue'::"text", 'rectify'::"text", 'cancel'::"text", 'resend'::"text", 'aeat_ack'::"text", 'aeat_error'::"text"])))
);


ALTER TABLE "public"."verifactu_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."verifactu_function_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "timestamp" timestamp without time zone DEFAULT "now"(),
    "function" "text",
    "user_id" "uuid",
    "request_payload" "jsonb",
    "error" "text",
    "auth_role" "text",
    "status" integer,
    "remote_ip" "text"
);


ALTER TABLE "public"."verifactu_function_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."verifactu_invoice_meta" (
    "invoice_id" "uuid" NOT NULL,
    "status" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."verifactu_invoice_meta" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."verifactu_settings" (
    "company_id" "uuid" NOT NULL,
    "software_code" "text" NOT NULL,
    "issuer_nif" "text" NOT NULL,
    "environment" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "cert_pem_enc" "text",
    "key_pem_enc" "text",
    "key_pass_enc" "text",
    CONSTRAINT "verifactu_settings_environment_check" CHECK (("environment" = ANY (ARRAY['pre'::"text", 'prod'::"text"])))
);


ALTER TABLE "public"."verifactu_settings" OWNER TO "postgres";


COMMENT ON TABLE "public"."verifactu_settings" IS 'Configuración VeriFactu por empresa. Certificados almacenados encriptados.';



CREATE OR REPLACE VIEW "public"."visible_stages_by_company" WITH ("security_invoker"='true') AS
 SELECT "ts"."id",
    "ts"."name",
    "ts"."position",
    "ts"."color",
    "ts"."created_at",
    "ts"."updated_at",
    "ts"."deleted_at",
    "ts"."company_id",
    "c"."id" AS "viewing_company_id",
        CASE
            WHEN ("ts"."company_id" IS NULL) THEN 'generic'::"text"
            WHEN ("ts"."company_id" = "c"."id") THEN 'company'::"text"
            ELSE 'other'::"text"
        END AS "stage_type",
        CASE
            WHEN ("hs"."id" IS NOT NULL) THEN true
            ELSE false
        END AS "is_hidden"
   FROM (("public"."ticket_stages" "ts"
     CROSS JOIN "public"."companies" "c")
     LEFT JOIN "public"."hidden_stages" "hs" ON ((("hs"."stage_id" = "ts"."id") AND ("hs"."company_id" = "c"."id") AND ("ts"."company_id" IS NULL))))
  WHERE ((("ts"."company_id" IS NULL) AND ("hs"."id" IS NULL)) OR ("ts"."company_id" = "c"."id"));


ALTER VIEW "public"."visible_stages_by_company" OWNER TO "postgres";


COMMENT ON VIEW "public"."visible_stages_by_company" IS 'Vista que muestra los estados visibles para cada empresa (genéricos no ocultos + propios)';



CREATE TABLE IF NOT EXISTS "public"."waitlist" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "service_id" "uuid" NOT NULL,
    "start_time" timestamp with time zone NOT NULL,
    "end_time" timestamp with time zone NOT NULL,
    "status" "public"."waitlist_status" DEFAULT 'pending'::"public"."waitlist_status" NOT NULL,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."waitlist" OWNER TO "postgres";


ALTER TABLE ONLY "public"."tickets" ALTER COLUMN "ticket_number" SET DEFAULT "nextval"('"public"."tickets_ticket_number_seq"'::"regclass");



ALTER TABLE ONLY "public"."addresses"
    ADD CONSTRAINT "addresses_direccion_locality_usuario_unique" UNIQUE ("direccion", "locality_id", "usuario_id");



ALTER TABLE ONLY "public"."addresses"
    ADD CONSTRAINT "addresses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_usage_logs"
    ADD CONSTRAINT "ai_usage_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."app_roles"
    ADD CONSTRAINT "app_roles_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."app_roles"
    ADD CONSTRAINT "app_roles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."app_settings"
    ADD CONSTRAINT "app_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."attachments"
    ADD CONSTRAINT "attachments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."availability_exceptions"
    ADD CONSTRAINT "availability_exceptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."availability_schedules"
    ADD CONSTRAINT "availability_schedules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."booking_history"
    ADD CONSTRAINT "booking_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."booking_types"
    ADD CONSTRAINT "booking_types_company_id_slug_key" UNIQUE ("company_id", "slug");



ALTER TABLE ONLY "public"."booking_types"
    ADD CONSTRAINT "booking_types_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bookings"
    ADD CONSTRAINT "bookings_pkey" PRIMARY KEY ("id");



ALTER TABLE "public"."clients"
    ADD CONSTRAINT "check_client_identification" CHECK (((COALESCE("is_active", true) = false) OR ((COALESCE("client_type", 'individual'::"text") = 'business'::"text") AND ("cif_nif" IS NOT NULL)) OR ((COALESCE("client_type", 'individual'::"text") = 'individual'::"text") AND (("dni" IS NOT NULL) OR ("cif_nif" IS NOT NULL))))) NOT VALID;



ALTER TABLE ONLY "public"."client_assignments"
    ADD CONSTRAINT "client_assignments_client_id_company_member_id_key" UNIQUE ("client_id", "company_member_id");



ALTER TABLE ONLY "public"."client_assignments"
    ADD CONSTRAINT "client_assignments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_clinical_notes"
    ADD CONSTRAINT "client_clinical_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_contacts"
    ADD CONSTRAINT "client_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_documents"
    ADD CONSTRAINT "client_documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_notes"
    ADD CONSTRAINT "client_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_portal_users"
    ADD CONSTRAINT "client_portal_users_company_id_client_id_email_key" UNIQUE ("company_id", "client_id", "email");



ALTER TABLE ONLY "public"."client_portal_users"
    ADD CONSTRAINT "client_portal_users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_variant_assignments"
    ADD CONSTRAINT "client_variant_assignments_client_id_service_id_key" UNIQUE ("client_id", "service_id");



ALTER TABLE ONLY "public"."client_variant_assignments"
    ADD CONSTRAINT "client_variant_assignments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_id_company_unique" UNIQUE ("id", "company_id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clients_tags"
    ADD CONSTRAINT "clients_tags_pkey" PRIMARY KEY ("client_id", "tag_id");



ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."company_invitations"
    ADD CONSTRAINT "company_invitations_company_email_uniq" UNIQUE ("company_id", "email");



ALTER TABLE ONLY "public"."company_invitations"
    ADD CONSTRAINT "company_invitations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."company_invitations"
    ADD CONSTRAINT "company_invitations_token_key" UNIQUE ("token");



ALTER TABLE ONLY "public"."company_members"
    ADD CONSTRAINT "company_members_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."company_members"
    ADD CONSTRAINT "company_members_user_id_company_id_key" UNIQUE ("user_id", "company_id");



ALTER TABLE ONLY "public"."company_modules"
    ADD CONSTRAINT "company_modules_pkey" PRIMARY KEY ("company_id", "module_key");



ALTER TABLE ONLY "public"."company_settings"
    ADD CONSTRAINT "company_settings_pkey" PRIMARY KEY ("company_id");



ALTER TABLE ONLY "public"."company_stage_order"
    ADD CONSTRAINT "company_stage_order_pkey" PRIMARY KEY ("company_id", "stage_id");



ALTER TABLE ONLY "public"."company_ticket_sequences"
    ADD CONSTRAINT "company_ticket_sequences_pkey" PRIMARY KEY ("company_id");



ALTER TABLE ONLY "public"."content_posts"
    ADD CONSTRAINT "content_posts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contract_templates"
    ADD CONSTRAINT "contract_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "contracts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coupons"
    ADD CONSTRAINT "coupons_company_id_code_key" UNIQUE ("company_id", "code");



ALTER TABLE ONLY "public"."coupons"
    ADD CONSTRAINT "coupons_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."device_components"
    ADD CONSTRAINT "device_components_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."device_media"
    ADD CONSTRAINT "device_media_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."device_status_history"
    ADD CONSTRAINT "device_status_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."devices"
    ADD CONSTRAINT "devices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "distinct_auth_user" UNIQUE ("auth_user_id");



ALTER TABLE ONLY "public"."employee_commissions_config"
    ADD CONSTRAINT "employee_commissions_config_employee_id_service_id_key" UNIQUE ("employee_id", "service_id");



ALTER TABLE ONLY "public"."employee_commissions_config"
    ADD CONSTRAINT "employee_commissions_config_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."employee_documents"
    ADD CONSTRAINT "employee_documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."employee_productivity_logs"
    ADD CONSTRAINT "employee_productivity_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."employees"
    ADD CONSTRAINT "employees_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."employees"
    ADD CONSTRAINT "employees_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."gdpr_access_requests"
    ADD CONSTRAINT "gdpr_access_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gdpr_audit_log"
    ADD CONSTRAINT "gdpr_audit_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gdpr_breach_incidents"
    ADD CONSTRAINT "gdpr_breach_incidents_incident_reference_key" UNIQUE ("incident_reference");



ALTER TABLE ONLY "public"."gdpr_breach_incidents"
    ADD CONSTRAINT "gdpr_breach_incidents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gdpr_consent_records"
    ADD CONSTRAINT "gdpr_consent_records_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gdpr_consent_requests"
    ADD CONSTRAINT "gdpr_consent_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."gdpr_consent_requests"
    ADD CONSTRAINT "gdpr_consent_requests_token_key" UNIQUE ("token");



ALTER TABLE ONLY "public"."gdpr_processing_activities"
    ADD CONSTRAINT "gdpr_processing_activities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."global_tags"
    ADD CONSTRAINT "global_tags_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."google_calendar_configs"
    ADD CONSTRAINT "google_calendar_configs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."google_calendar_configs"
    ADD CONSTRAINT "google_calendar_configs_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."hidden_stages"
    ADD CONSTRAINT "hidden_stages_company_id_stage_id_key" UNIQUE ("company_id", "stage_id");



ALTER TABLE ONLY "public"."hidden_stages"
    ADD CONSTRAINT "hidden_stages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."hidden_units"
    ADD CONSTRAINT "hidden_units_pkey" PRIMARY KEY ("company_id", "unit_id");



ALTER TABLE ONLY "public"."integrations"
    ADD CONSTRAINT "integrations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."integrations"
    ADD CONSTRAINT "integrations_user_id_provider_key" UNIQUE ("user_id", "provider");



ALTER TABLE ONLY "public"."invoice_items"
    ADD CONSTRAINT "invoice_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoice_meta"
    ADD CONSTRAINT "invoice_meta_pkey" PRIMARY KEY ("invoice_id");



ALTER TABLE ONLY "public"."invoice_payments"
    ADD CONSTRAINT "invoice_payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoice_series"
    ADD CONSTRAINT "invoice_series_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoice_templates"
    ADD CONSTRAINT "invoice_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_payment_link_token_key" UNIQUE ("payment_link_token");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_paypal_payment_token_key" UNIQUE ("paypal_payment_token");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_stripe_payment_token_key" UNIQUE ("stripe_payment_token");



ALTER TABLE ONLY "public"."item_tags"
    ADD CONSTRAINT "item_tags_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."job_notes"
    ADD CONSTRAINT "job_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."lead_interactions"
    ADD CONSTRAINT "lead_interactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."lead_sources"
    ADD CONSTRAINT "lead_sources_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."localities"
    ADD CONSTRAINT "localities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."localities"
    ADD CONSTRAINT "localities_postal_code_unique" UNIQUE ("postal_code");



ALTER TABLE ONLY "public"."loyalty_points"
    ADD CONSTRAINT "loyalty_points_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mail_accounts"
    ADD CONSTRAINT "mail_accounts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mail_accounts"
    ADD CONSTRAINT "mail_accounts_user_id_email_key" UNIQUE ("user_id", "email");



ALTER TABLE ONLY "public"."mail_attachments"
    ADD CONSTRAINT "mail_attachments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mail_contacts"
    ADD CONSTRAINT "mail_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mail_contacts"
    ADD CONSTRAINT "mail_contacts_user_id_email_key" UNIQUE ("user_id", "email");



ALTER TABLE ONLY "public"."domains"
    ADD CONSTRAINT "mail_domains_domain_key" UNIQUE ("domain");



ALTER TABLE ONLY "public"."domains"
    ADD CONSTRAINT "mail_domains_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mail_folders"
    ADD CONSTRAINT "mail_folders_account_id_path_key" UNIQUE ("account_id", "path");



ALTER TABLE ONLY "public"."mail_folders"
    ADD CONSTRAINT "mail_folders_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mail_messages"
    ADD CONSTRAINT "mail_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mail_threads"
    ADD CONSTRAINT "mail_threads_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."marketing_campaigns"
    ADD CONSTRAINT "marketing_campaigns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."marketing_logs"
    ADD CONSTRAINT "marketing_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."marketing_metrics"
    ADD CONSTRAINT "marketing_metrics_company_id_date_channel_key" UNIQUE ("company_id", "date", "channel");



ALTER TABLE ONLY "public"."marketing_metrics"
    ADD CONSTRAINT "marketing_metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."modules_catalog"
    ADD CONSTRAINT "modules_catalog_pkey" PRIMARY KEY ("key");



ALTER TABLE ONLY "public"."modules"
    ADD CONSTRAINT "modules_pkey" PRIMARY KEY ("key");



ALTER TABLE ONLY "public"."notification_logs"
    ADD CONSTRAINT "notification_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notification_templates"
    ADD CONSTRAINT "notification_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_integrations"
    ADD CONSTRAINT "payment_integrations_company_id_provider_key" UNIQUE ("company_id", "provider");



ALTER TABLE ONLY "public"."payment_integrations"
    ADD CONSTRAINT "payment_integrations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pending_users"
    ADD CONSTRAINT "pending_users_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."pending_users"
    ADD CONSTRAINT "pending_users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_brands"
    ADD CONSTRAINT "product_brands_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_catalog"
    ADD CONSTRAINT "product_catalog_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_categories"
    ADD CONSTRAINT "product_categories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_models"
    ADD CONSTRAINT "product_models_brand_id_name_company_id_key" UNIQUE ("brand_id", "name", "company_id");



ALTER TABLE ONLY "public"."product_models"
    ADD CONSTRAINT "product_models_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."professional_documents"
    ADD CONSTRAINT "professional_documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."professional_schedules"
    ADD CONSTRAINT "professional_schedules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."professional_schedules"
    ADD CONSTRAINT "professional_schedules_professional_id_day_of_week_key" UNIQUE ("professional_id", "day_of_week");



ALTER TABLE ONLY "public"."professional_services"
    ADD CONSTRAINT "professional_services_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."professional_services"
    ADD CONSTRAINT "professional_services_professional_id_service_id_key" UNIQUE ("professional_id", "service_id");



ALTER TABLE ONLY "public"."professional_titles"
    ADD CONSTRAINT "professional_titles_company_id_name_key" UNIQUE ("company_id", "name");



ALTER TABLE ONLY "public"."professional_titles"
    ADD CONSTRAINT "professional_titles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."professionals"
    ADD CONSTRAINT "professionals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."professionals"
    ADD CONSTRAINT "professionals_user_id_company_id_key" UNIQUE ("user_id", "company_id");



ALTER TABLE ONLY "public"."project_activity"
    ADD CONSTRAINT "project_activity_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_comments"
    ADD CONSTRAINT "project_comments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_files"
    ADD CONSTRAINT "project_files_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_notification_preferences"
    ADD CONSTRAINT "project_notification_preferences_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_permissions"
    ADD CONSTRAINT "project_permissions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_permissions"
    ADD CONSTRAINT "project_permissions_project_id_key" UNIQUE ("project_id");



ALTER TABLE ONLY "public"."project_stages"
    ADD CONSTRAINT "project_stages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_tasks"
    ADD CONSTRAINT "project_tasks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."quote_items"
    ADD CONSTRAINT "quote_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."quote_templates"
    ADD CONSTRAINT "quote_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."resources"
    ADD CONSTRAINT "resources_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."role_permissions"
    ADD CONSTRAINT "role_permissions_company_id_role_permission_key" UNIQUE ("company_id", "role", "permission");



ALTER TABLE ONLY "public"."role_permissions"
    ADD CONSTRAINT "role_permissions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."rooms"
    ADD CONSTRAINT "rooms_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."scheduled_jobs"
    ADD CONSTRAINT "scheduled_jobs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."service_categories"
    ADD CONSTRAINT "service_categories_name_company_id_key" UNIQUE ("name", "company_id");



ALTER TABLE ONLY "public"."service_categories"
    ADD CONSTRAINT "service_categories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."service_units"
    ADD CONSTRAINT "service_units_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."service_variants"
    ADD CONSTRAINT "service_variants_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."services_tags"
    ADD CONSTRAINT "services_tags_pkey" PRIMARY KEY ("service_id", "tag_id");



ALTER TABLE ONLY "public"."social_metrics"
    ADD CONSTRAINT "social_metrics_company_id_date_platform_key" UNIQUE ("company_id", "date", "platform");



ALTER TABLE ONLY "public"."social_metrics"
    ADD CONSTRAINT "social_metrics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stock_movements"
    ADD CONSTRAINT "stock_movements_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."supplier_products"
    ADD CONSTRAINT "supplier_products_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."suppliers"
    ADD CONSTRAINT "suppliers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tag_scopes"
    ADD CONSTRAINT "tag_scopes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ticket_comment_attachments"
    ADD CONSTRAINT "ticket_comment_attachments_pkey" PRIMARY KEY ("comment_id", "attachment_id");



ALTER TABLE ONLY "public"."ticket_comment_versions"
    ADD CONSTRAINT "ticket_comment_versions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ticket_comments"
    ADD CONSTRAINT "ticket_comments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ticket_devices"
    ADD CONSTRAINT "ticket_devices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ticket_devices"
    ADD CONSTRAINT "ticket_devices_ticket_id_device_id_relation_type_key" UNIQUE ("ticket_id", "device_id", "relation_type");



ALTER TABLE ONLY "public"."ticket_macros"
    ADD CONSTRAINT "ticket_macros_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ticket_products"
    ADD CONSTRAINT "ticket_products_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ticket_services"
    ADD CONSTRAINT "ticket_services_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ticket_services"
    ADD CONSTRAINT "ticket_services_ticket_id_service_id_key" UNIQUE ("ticket_id", "service_id");



ALTER TABLE ONLY "public"."ticket_stages"
    ADD CONSTRAINT "ticket_stages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ticket_timeline"
    ADD CONSTRAINT "ticket_timeline_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tickets"
    ADD CONSTRAINT "tickets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tickets_tags"
    ADD CONSTRAINT "tickets_tags_pkey" PRIMARY KEY ("ticket_id", "tag_id");



ALTER TABLE ONLY "public"."tickets"
    ADD CONSTRAINT "tickets_ticket_number_key" UNIQUE ("ticket_number");



ALTER TABLE ONLY "public"."product_brands"
    ADD CONSTRAINT "unique_brand_per_company" UNIQUE NULLS NOT DISTINCT ("name", "company_id");



ALTER TABLE ONLY "public"."product_categories"
    ADD CONSTRAINT "unique_category_per_company" UNIQUE NULLS NOT DISTINCT ("name", "company_id");



ALTER TABLE ONLY "public"."project_notification_preferences"
    ADD CONSTRAINT "unique_client_project" UNIQUE ("project_id", "client_id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "unique_invoice_number_per_series" UNIQUE ("series_id", "invoice_number");



ALTER TABLE ONLY "public"."invoice_series"
    ADD CONSTRAINT "unique_series_per_company_year" UNIQUE ("company_id", "series_code", "year");



ALTER TABLE ONLY "public"."project_notification_preferences"
    ADD CONSTRAINT "unique_user_project" UNIQUE ("project_id", "user_id");



ALTER TABLE ONLY "public"."user_modules"
    ADD CONSTRAINT "user_modules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_modules"
    ADD CONSTRAINT "user_modules_user_id_module_key_key" UNIQUE ("user_id", "module_key");



ALTER TABLE ONLY "public"."user_preferences"
    ADD CONSTRAINT "user_preferences_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_auth_user_id_key" UNIQUE ("auth_user_id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."verifactu_cert_history"
    ADD CONSTRAINT "verifactu_cert_history_company_id_version_key" UNIQUE ("company_id", "version");



ALTER TABLE ONLY "public"."verifactu_cert_history"
    ADD CONSTRAINT "verifactu_cert_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."verifactu_events"
    ADD CONSTRAINT "verifactu_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."verifactu_function_log"
    ADD CONSTRAINT "verifactu_function_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."verifactu_invoice_meta"
    ADD CONSTRAINT "verifactu_invoice_meta_pkey" PRIMARY KEY ("invoice_id");



ALTER TABLE ONLY "public"."verifactu_settings"
    ADD CONSTRAINT "verifactu_settings_pkey" PRIMARY KEY ("company_id");



ALTER TABLE ONLY "public"."waitlist"
    ADD CONSTRAINT "waitlist_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."services"
    ADD CONSTRAINT "works_pkey" PRIMARY KEY ("id");



CREATE INDEX "addresses_locality_id_idx" ON "public"."addresses" USING "btree" ("locality_id");



CREATE INDEX "addresses_usuario_id_idx" ON "public"."addresses" USING "btree" ("usuario_id");



CREATE INDEX "idx_addresses_company_id" ON "public"."addresses" USING "btree" ("company_id");



CREATE INDEX "idx_addresses_company_usuario" ON "public"."addresses" USING "btree" ("company_id", "usuario_id");



CREATE INDEX "idx_ai_logs_company" ON "public"."ai_usage_logs" USING "btree" ("company_id");



CREATE INDEX "idx_ai_logs_created_at" ON "public"."ai_usage_logs" USING "btree" ("created_at");



CREATE INDEX "idx_ai_usage_logs_company_id" ON "public"."ai_usage_logs" USING "btree" ("company_id");



CREATE INDEX "idx_ai_usage_logs_user_id" ON "public"."ai_usage_logs" USING "btree" ("user_id");



CREATE INDEX "idx_attachments_company" ON "public"."attachments" USING "btree" ("company_id") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_audit_company_date" ON "public"."audit_logs" USING "btree" ("company_id", "created_at" DESC);



CREATE INDEX "idx_audit_entity" ON "public"."audit_logs" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_availability_exceptions_company_id" ON "public"."availability_exceptions" USING "btree" ("company_id");



CREATE INDEX "idx_availability_exceptions_user_id" ON "public"."availability_exceptions" USING "btree" ("user_id");



CREATE INDEX "idx_availability_schedules_user_id" ON "public"."availability_schedules" USING "btree" ("user_id");



CREATE INDEX "idx_bookings_booking_type" ON "public"."bookings" USING "btree" ("booking_type_id");



CREATE INDEX "idx_bookings_client_start_time" ON "public"."bookings" USING "btree" ("client_id", "start_time" DESC);



CREATE INDEX "idx_bookings_customer_email" ON "public"."bookings" USING "btree" ("customer_email");



CREATE INDEX "idx_bookings_google_event_id" ON "public"."bookings" USING "btree" ("google_event_id");



CREATE INDEX "idx_bookings_professional" ON "public"."bookings" USING "btree" ("professional_id");



CREATE INDEX "idx_bookings_service" ON "public"."bookings" USING "btree" ("service_id");



CREATE INDEX "idx_bookings_service_id" ON "public"."bookings" USING "btree" ("service_id");



CREATE INDEX "idx_client_variant_assignments_client_service" ON "public"."client_variant_assignments" USING "btree" ("client_id", "service_id");



CREATE INDEX "idx_client_variant_assignments_variant" ON "public"."client_variant_assignments" USING "btree" ("variant_id");



CREATE INDEX "idx_clients_active" ON "public"."clients" USING "btree" ("is_active") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_clients_anonymized" ON "public"."clients" USING "btree" ("anonymized_at") WHERE ("anonymized_at" IS NOT NULL);



CREATE UNIQUE INDEX "idx_clients_auth_user_company" ON "public"."clients" USING "btree" ("auth_user_id", "company_id") WHERE ("auth_user_id" IS NOT NULL);



CREATE INDEX "idx_clients_auth_user_id" ON "public"."clients" USING "btree" ("auth_user_id") WHERE ("auth_user_id" IS NOT NULL);



CREATE INDEX "idx_clients_company" ON "public"."clients" USING "btree" ("company_id") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_clients_deletion_requested" ON "public"."clients" USING "btree" ("deletion_requested_at") WHERE ("deletion_requested_at" IS NOT NULL);



CREATE INDEX "idx_clients_invitation_token" ON "public"."clients" USING "btree" ("invitation_token");



CREATE INDEX "idx_clients_last_accessed" ON "public"."clients" USING "btree" ("last_accessed_at");



CREATE INDEX "idx_clients_marketing_consent" ON "public"."clients" USING "btree" ("marketing_consent");



CREATE INDEX "idx_clients_retention_expired" ON "public"."clients" USING "btree" ("data_retention_until") WHERE ("data_retention_until" IS NOT NULL);



CREATE INDEX "idx_clients_retention_until" ON "public"."clients" USING "btree" ("data_retention_until");



CREATE INDEX "idx_companies_is_active" ON "public"."companies" USING "btree" ("is_active");



CREATE INDEX "idx_companies_nif" ON "public"."companies" USING "btree" ("nif") WHERE ("nif" IS NOT NULL);



CREATE INDEX "idx_companies_slug" ON "public"."companies" USING "btree" ("slug");



CREATE INDEX "idx_companies_subscription_tier" ON "public"."companies" USING "btree" ("subscription_tier");



CREATE INDEX "idx_company_invitations_company" ON "public"."company_invitations" USING "btree" ("company_id");



CREATE INDEX "idx_company_invitations_email" ON "public"."company_invitations" USING "btree" ("email");



CREATE INDEX "idx_company_invitations_status" ON "public"."company_invitations" USING "btree" ("status");



CREATE INDEX "idx_company_invitations_token" ON "public"."company_invitations" USING "btree" ("token");



CREATE INDEX "idx_company_members_user_status" ON "public"."company_members" USING "btree" ("user_id", "status") INCLUDE ("company_id");



CREATE INDEX "idx_company_stage_order_company" ON "public"."company_stage_order" USING "btree" ("company_id");



CREATE INDEX "idx_company_stage_order_company_position" ON "public"."company_stage_order" USING "btree" ("company_id", "position");



CREATE INDEX "idx_device_components_device_id" ON "public"."device_components" USING "btree" ("device_id");



CREATE INDEX "idx_device_media_device_id" ON "public"."device_media" USING "btree" ("device_id");



CREATE INDEX "idx_device_status_history_changed_at" ON "public"."device_status_history" USING "btree" ("changed_at");



CREATE INDEX "idx_device_status_history_device_id" ON "public"."device_status_history" USING "btree" ("device_id");



CREATE INDEX "idx_devices_brand_model" ON "public"."devices" USING "btree" ("brand", "model");



CREATE INDEX "idx_devices_client_id" ON "public"."devices" USING "btree" ("client_id");



CREATE INDEX "idx_devices_company_id" ON "public"."devices" USING "btree" ("company_id");



CREATE INDEX "idx_devices_deleted_at" ON "public"."devices" USING "btree" ("deleted_at");



CREATE INDEX "idx_devices_device_type" ON "public"."devices" USING "btree" ("device_type");



CREATE INDEX "idx_devices_received_at" ON "public"."devices" USING "btree" ("received_at");



CREATE INDEX "idx_devices_status" ON "public"."devices" USING "btree" ("status");



CREATE INDEX "idx_emp_comm_config_company" ON "public"."employee_commissions_config" USING "btree" ("company_id");



CREATE INDEX "idx_emp_comm_config_employee" ON "public"."employee_commissions_config" USING "btree" ("employee_id");



CREATE INDEX "idx_employee_documents_employee_id" ON "public"."employee_documents" USING "btree" ("employee_id");



CREATE INDEX "idx_employees_company_id" ON "public"."employees" USING "btree" ("company_id");



CREATE INDEX "idx_employees_user_id" ON "public"."employees" USING "btree" ("user_id");



CREATE INDEX "idx_gcr_company" ON "public"."gdpr_consent_requests" USING "btree" ("company_id");



CREATE INDEX "idx_gcr_email" ON "public"."gdpr_consent_requests" USING "btree" ("subject_email");



CREATE INDEX "idx_gcr_status" ON "public"."gdpr_consent_requests" USING "btree" ("status");



CREATE INDEX "idx_gdpr_access_requests_company_id" ON "public"."gdpr_access_requests" USING "btree" ("company_id");



CREATE INDEX "idx_gdpr_access_requests_deadline" ON "public"."gdpr_access_requests" USING "btree" ("deadline_date");



CREATE INDEX "idx_gdpr_access_requests_email" ON "public"."gdpr_access_requests" USING "btree" ("subject_email");



CREATE INDEX "idx_gdpr_access_requests_status" ON "public"."gdpr_access_requests" USING "btree" ("processing_status");



CREATE INDEX "idx_gdpr_access_requests_subject_email" ON "public"."gdpr_access_requests" USING "btree" ("subject_email");



CREATE INDEX "idx_gdpr_audit_log_created_at" ON "public"."gdpr_audit_log" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_gdpr_audit_log_subject_email" ON "public"."gdpr_audit_log" USING "btree" ("subject_email");



CREATE INDEX "idx_gdpr_audit_log_table_record" ON "public"."gdpr_audit_log" USING "btree" ("table_name", "record_id");



CREATE INDEX "idx_gdpr_audit_log_user_id" ON "public"."gdpr_audit_log" USING "btree" ("user_id");



CREATE INDEX "idx_gdpr_consent_records_active" ON "public"."gdpr_consent_records" USING "btree" ("is_active");



CREATE INDEX "idx_gdpr_consent_records_email" ON "public"."gdpr_consent_records" USING "btree" ("subject_email");



CREATE INDEX "idx_gdpr_consent_records_subject_email" ON "public"."gdpr_consent_records" USING "btree" ("subject_email");



CREATE INDEX "idx_gdpr_consent_records_subject_id" ON "public"."gdpr_consent_records" USING "btree" ("subject_id");



CREATE INDEX "idx_gdpr_consent_records_type" ON "public"."gdpr_consent_records" USING "btree" ("consent_type");



CREATE INDEX "idx_hidden_stages_company" ON "public"."hidden_stages" USING "btree" ("company_id");



CREATE INDEX "idx_hidden_stages_company_stage" ON "public"."hidden_stages" USING "btree" ("company_id", "stage_id");



CREATE INDEX "idx_hidden_stages_stage" ON "public"."hidden_stages" USING "btree" ("stage_id");



CREATE INDEX "idx_hidden_units_unit" ON "public"."hidden_units" USING "btree" ("unit_id");



CREATE INDEX "idx_invoice_items_invoice" ON "public"."invoice_items" USING "btree" ("invoice_id");



CREATE INDEX "idx_invoice_items_product" ON "public"."invoice_items" USING "btree" ("product_id") WHERE ("product_id" IS NOT NULL);



CREATE INDEX "idx_invoice_items_service" ON "public"."invoice_items" USING "btree" ("service_id") WHERE ("service_id" IS NOT NULL);



CREATE INDEX "idx_invoice_payments_date" ON "public"."invoice_payments" USING "btree" ("payment_date" DESC);



CREATE INDEX "idx_invoice_payments_invoice" ON "public"."invoice_payments" USING "btree" ("invoice_id");



CREATE INDEX "idx_invoice_series_active" ON "public"."invoice_series" USING "btree" ("company_id", "is_active");



CREATE INDEX "idx_invoice_series_company" ON "public"."invoice_series" USING "btree" ("company_id");



CREATE INDEX "idx_invoice_templates_company" ON "public"."invoice_templates" USING "btree" ("company_id");



CREATE INDEX "idx_invoices_client" ON "public"."invoices" USING "btree" ("client_id");



CREATE INDEX "idx_invoices_client_date_deleted" ON "public"."invoices" USING "btree" ("client_id", "invoice_date" DESC) WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_invoices_company" ON "public"."invoices" USING "btree" ("company_id");



CREATE INDEX "idx_invoices_date" ON "public"."invoices" USING "btree" ("invoice_date" DESC);



CREATE INDEX "idx_invoices_full_number" ON "public"."invoices" USING "btree" ("full_invoice_number");



CREATE INDEX "idx_invoices_lead_id" ON "public"."invoices" USING "btree" ("lead_id");



CREATE INDEX "idx_invoices_payment_status" ON "public"."invoices" USING "btree" ("company_id", "payment_status");



CREATE INDEX "idx_invoices_paypal_token" ON "public"."invoices" USING "btree" ("paypal_payment_token") WHERE ("paypal_payment_token" IS NOT NULL);



CREATE INDEX "idx_invoices_retention" ON "public"."invoices" USING "btree" ("retention_until") WHERE ("anonymized_at" IS NULL);



CREATE INDEX "idx_invoices_series" ON "public"."invoices" USING "btree" ("series_id");



CREATE INDEX "idx_invoices_source_quote_id" ON "public"."invoices" USING "btree" ("source_quote_id") WHERE ("source_quote_id" IS NOT NULL);



CREATE INDEX "idx_invoices_status" ON "public"."invoices" USING "btree" ("status");



CREATE INDEX "idx_invoices_stripe_token" ON "public"."invoices" USING "btree" ("stripe_payment_token") WHERE ("stripe_payment_token" IS NOT NULL);



CREATE INDEX "idx_invoices_verifactu" ON "public"."invoices" USING "btree" ("verifactu_chain_position") WHERE ("verifactu_hash" IS NOT NULL);



CREATE INDEX "idx_job_notes_company" ON "public"."job_notes" USING "btree" ("company_id");



CREATE INDEX "idx_mail_contacts_user_email" ON "public"."mail_contacts" USING "btree" ("user_id", "email");



CREATE INDEX "idx_mail_folders_account" ON "public"."mail_folders" USING "btree" ("account_id");



CREATE INDEX "idx_mail_folders_parent" ON "public"."mail_folders" USING "btree" ("parent_id");



CREATE INDEX "idx_mail_messages_account" ON "public"."mail_messages" USING "btree" ("account_id");



CREATE INDEX "idx_mail_messages_folder" ON "public"."mail_messages" USING "btree" ("folder_id");



CREATE INDEX "idx_mail_messages_received" ON "public"."mail_messages" USING "btree" ("received_at" DESC);



CREATE INDEX "idx_mail_messages_thread" ON "public"."mail_messages" USING "btree" ("thread_id");



CREATE INDEX "idx_mail_threads_account_updated" ON "public"."mail_threads" USING "btree" ("account_id", "last_message_at" DESC);



CREATE INDEX "idx_marketing_campaigns_automation" ON "public"."marketing_campaigns" USING "btree" ("company_id", "trigger_type", "is_active");



CREATE INDEX "idx_marketing_metrics_company_date" ON "public"."marketing_metrics" USING "btree" ("company_id", "date");



CREATE INDEX "idx_notifications_company" ON "public"."notifications" USING "btree" ("company_id");



CREATE INDEX "idx_notifications_recipient" ON "public"."notifications" USING "btree" ("recipient_id");



CREATE INDEX "idx_notifications_unread" ON "public"."notifications" USING "btree" ("recipient_id") WHERE ("is_read" = false);



CREATE UNIQUE INDEX "idx_one_default_per_company" ON "public"."project_stages" USING "btree" ("company_id") WHERE ("is_default" = true);



CREATE UNIQUE INDEX "idx_one_landing_per_company" ON "public"."project_stages" USING "btree" ("company_id") WHERE ("is_landing" = true);



CREATE UNIQUE INDEX "idx_one_review_per_company" ON "public"."project_stages" USING "btree" ("company_id") WHERE ("is_review" = true);



CREATE INDEX "idx_payment_integrations_active" ON "public"."payment_integrations" USING "btree" ("company_id", "provider") WHERE ("is_active" = true);



CREATE INDEX "idx_payment_integrations_company" ON "public"."payment_integrations" USING "btree" ("company_id");



CREATE INDEX "idx_payment_transactions_company" ON "public"."payment_transactions" USING "btree" ("company_id");



CREATE INDEX "idx_payment_transactions_external" ON "public"."payment_transactions" USING "btree" ("provider", "external_id");



CREATE INDEX "idx_payment_transactions_invoice" ON "public"."payment_transactions" USING "btree" ("invoice_id");



CREATE INDEX "idx_pending_users_auth_id" ON "public"."pending_users" USING "btree" ("auth_user_id");



CREATE INDEX "idx_pending_users_company" ON "public"."pending_users" USING "btree" ("company_id") WHERE ("company_id" IS NOT NULL);



CREATE INDEX "idx_pending_users_email" ON "public"."pending_users" USING "btree" ("email");



CREATE INDEX "idx_pending_users_token" ON "public"."pending_users" USING "btree" ("confirmation_token");



CREATE INDEX "idx_prod_logs_company" ON "public"."employee_productivity_logs" USING "btree" ("company_id");



CREATE INDEX "idx_prod_logs_date" ON "public"."employee_productivity_logs" USING "btree" ("performed_at");



CREATE INDEX "idx_prod_logs_employee" ON "public"."employee_productivity_logs" USING "btree" ("employee_id");



CREATE INDEX "idx_product_brands_company" ON "public"."product_brands" USING "btree" ("company_id") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_product_brands_name" ON "public"."product_brands" USING "btree" ("name") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_product_categories_company" ON "public"."product_categories" USING "btree" ("company_id") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_product_categories_name" ON "public"."product_categories" USING "btree" ("name") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_product_categories_parent" ON "public"."product_categories" USING "btree" ("parent_id") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_products_brand_id" ON "public"."products" USING "btree" ("brand_id") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_products_category_id" ON "public"."products" USING "btree" ("category_id") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_products_company" ON "public"."products" USING "btree" ("company_id");



CREATE INDEX "idx_products_company_deleted" ON "public"."products" USING "btree" ("company_id", "deleted_at");



CREATE INDEX "idx_professional_services_professional" ON "public"."professional_services" USING "btree" ("professional_id");



CREATE INDEX "idx_professional_services_service" ON "public"."professional_services" USING "btree" ("service_id");



CREATE INDEX "idx_professionals_company" ON "public"."professionals" USING "btree" ("company_id");



CREATE INDEX "idx_professionals_company_display_name" ON "public"."professionals" USING "btree" ("company_id", "display_name");



CREATE INDEX "idx_professionals_user" ON "public"."professionals" USING "btree" ("user_id");



CREATE INDEX "idx_project_activity_created_at" ON "public"."project_activity" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_project_activity_project_id" ON "public"."project_activity" USING "btree" ("project_id");



CREATE INDEX "idx_project_comments_project_id" ON "public"."project_comments" USING "btree" ("project_id");



CREATE INDEX "idx_project_comments_user_id" ON "public"."project_comments" USING "btree" ("user_id");



CREATE INDEX "idx_project_notif_prefs_client" ON "public"."project_notification_preferences" USING "btree" ("client_id");



CREATE INDEX "idx_project_notif_prefs_project" ON "public"."project_notification_preferences" USING "btree" ("project_id");



CREATE INDEX "idx_project_notif_prefs_user" ON "public"."project_notification_preferences" USING "btree" ("user_id");



CREATE INDEX "idx_project_notification_preferences_project_client" ON "public"."project_notification_preferences" USING "btree" ("project_id", "client_id");



CREATE INDEX "idx_project_notification_preferences_project_user" ON "public"."project_notification_preferences" USING "btree" ("project_id", "user_id");



CREATE INDEX "idx_quote_items_company" ON "public"."quote_items" USING "btree" ("company_id");



CREATE INDEX "idx_quote_items_line_number" ON "public"."quote_items" USING "btree" ("quote_id", "line_number");



CREATE INDEX "idx_quote_items_product" ON "public"."quote_items" USING "btree" ("product_id");



CREATE INDEX "idx_quote_items_quote" ON "public"."quote_items" USING "btree" ("quote_id");



CREATE INDEX "idx_quote_items_service" ON "public"."quote_items" USING "btree" ("service_id");



CREATE INDEX "idx_quote_items_service_quote" ON "public"."quote_items" USING "btree" ("service_id", "quote_id");



CREATE INDEX "idx_quote_items_variant" ON "public"."quote_items" USING "btree" ("variant_id");



CREATE INDEX "idx_quote_templates_active" ON "public"."quote_templates" USING "btree" ("company_id", "is_active");



CREATE INDEX "idx_quote_templates_company" ON "public"."quote_templates" USING "btree" ("company_id");



CREATE INDEX "idx_quotes_client" ON "public"."quotes" USING "btree" ("client_id");



CREATE INDEX "idx_quotes_company" ON "public"."quotes" USING "btree" ("company_id");



CREATE INDEX "idx_quotes_company_client_date" ON "public"."quotes" USING "btree" ("company_id", "client_id", "quote_date" DESC);



CREATE INDEX "idx_quotes_full_number" ON "public"."quotes" USING "btree" ("full_quote_number");



CREATE INDEX "idx_quotes_invoice" ON "public"."quotes" USING "btree" ("invoice_id");



CREATE INDEX "idx_quotes_next_run_at" ON "public"."quotes" USING "btree" ("next_run_at");



CREATE INDEX "idx_quotes_quote_date" ON "public"."quotes" USING "btree" ("quote_date");



CREATE INDEX "idx_quotes_recurrence_type" ON "public"."quotes" USING "btree" ("recurrence_type");



CREATE INDEX "idx_quotes_retention" ON "public"."quotes" USING "btree" ("retention_until") WHERE (NOT "is_anonymized");



CREATE INDEX "idx_quotes_scheduled_conversion" ON "public"."quotes" USING "btree" ("scheduled_conversion_date") WHERE (("scheduled_conversion_date" IS NOT NULL) AND ("status" = 'accepted'::"public"."quote_status"));



CREATE INDEX "idx_quotes_status" ON "public"."quotes" USING "btree" ("status");



CREATE UNIQUE INDEX "idx_quotes_unique_number" ON "public"."quotes" USING "btree" ("company_id", "year", "sequence_number");



CREATE INDEX "idx_quotes_valid_until" ON "public"."quotes" USING "btree" ("valid_until");



CREATE INDEX "idx_role_permissions_company_role" ON "public"."role_permissions" USING "btree" ("company_id", "role");



CREATE INDEX "idx_sched_notif_pending" ON "public"."scheduled_notifications" USING "btree" ("status", "type", "booking_id");



CREATE INDEX "idx_scheduled_jobs_status_time" ON "public"."scheduled_jobs" USING "btree" ("status", "scheduled_at");



CREATE INDEX "idx_scheduled_jobs_type" ON "public"."scheduled_jobs" USING "btree" ("job_type");



CREATE INDEX "idx_service_categories_active" ON "public"."service_categories" USING "btree" ("is_active");



CREATE INDEX "idx_service_categories_company" ON "public"."service_categories" USING "btree" ("company_id");



CREATE INDEX "idx_service_categories_sort" ON "public"."service_categories" USING "btree" ("sort_order");



CREATE INDEX "idx_service_variants_active" ON "public"."service_variants" USING "btree" ("service_id", "is_active");



CREATE INDEX "idx_service_variants_pricing" ON "public"."service_variants" USING "gin" ("pricing");



CREATE INDEX "idx_service_variants_service_id" ON "public"."service_variants" USING "btree" ("service_id");



CREATE INDEX "idx_services_category" ON "public"."services" USING "btree" ("category");



CREATE INDEX "idx_services_company_active" ON "public"."services" USING "btree" ("company_id", "is_active");



CREATE INDEX "idx_services_company_active_name" ON "public"."services" USING "btree" ("company_id", "is_active", "name");



CREATE INDEX "idx_services_company_id" ON "public"."services" USING "btree" ("company_id");



CREATE INDEX "idx_services_difficulty" ON "public"."services" USING "btree" ("difficulty_level");



CREATE INDEX "idx_services_is_active" ON "public"."services" USING "btree" ("is_active");



CREATE INDEX "idx_services_is_bookable" ON "public"."services" USING "btree" ("is_bookable") WHERE ("is_bookable" = true);



CREATE INDEX "idx_services_is_public" ON "public"."services" USING "btree" ("is_public");



CREATE INDEX "idx_services_price_range" ON "public"."services" USING "btree" ("base_price");



CREATE INDEX "idx_services_priority" ON "public"."services" USING "btree" ("priority_level");



CREATE INDEX "idx_social_metrics_company_date" ON "public"."social_metrics" USING "btree" ("company_id", "date");



CREATE INDEX "idx_tca_attachment" ON "public"."ticket_comment_attachments" USING "btree" ("attachment_id");



CREATE INDEX "idx_tca_comment" ON "public"."ticket_comment_attachments" USING "btree" ("comment_id");



CREATE INDEX "idx_ticket_comments_company_id" ON "public"."ticket_comments" USING "btree" ("company_id");



CREATE INDEX "idx_ticket_comments_created_at" ON "public"."ticket_comments" USING "btree" ("created_at");



CREATE INDEX "idx_ticket_comments_ticket_id" ON "public"."ticket_comments" USING "btree" ("ticket_id");



CREATE INDEX "idx_ticket_comments_user_id" ON "public"."ticket_comments" USING "btree" ("user_id");



CREATE INDEX "idx_ticket_devices_device_id" ON "public"."ticket_devices" USING "btree" ("device_id");



CREATE INDEX "idx_ticket_devices_ticket_id" ON "public"."ticket_devices" USING "btree" ("ticket_id");



CREATE INDEX "idx_ticket_macros_company" ON "public"."ticket_macros" USING "btree" ("company_id");



CREATE INDEX "idx_ticket_products_company" ON "public"."ticket_products" USING "btree" ("company_id");



CREATE INDEX "idx_ticket_products_company_product" ON "public"."ticket_products" USING "btree" ("company_id", "product_id");



CREATE INDEX "idx_ticket_products_product" ON "public"."ticket_products" USING "btree" ("product_id");



CREATE INDEX "idx_ticket_products_ticket" ON "public"."ticket_products" USING "btree" ("ticket_id");



CREATE INDEX "idx_ticket_services_company_service" ON "public"."ticket_services" USING "btree" ("company_id", "service_id");



CREATE INDEX "idx_ticket_services_ticket_id" ON "public"."ticket_services" USING "btree" ("ticket_id");



CREATE INDEX "idx_ticket_services_variant_id" ON "public"."ticket_services" USING "btree" ("variant_id");



CREATE INDEX "idx_ticket_stages_category" ON "public"."ticket_stages" USING "btree" ("stage_category");



CREATE INDEX "idx_ticket_stages_company" ON "public"."ticket_stages" USING "btree" ("company_id");



CREATE INDEX "idx_ticket_timeline_created" ON "public"."ticket_timeline" USING "btree" ("created_at");



CREATE INDEX "idx_ticket_timeline_ticket" ON "public"."ticket_timeline" USING "btree" ("ticket_id");



CREATE INDEX "idx_tickets_client_id" ON "public"."tickets" USING "btree" ("client_id");



CREATE INDEX "idx_tickets_company_created" ON "public"."tickets" USING "btree" ("company_id", "created_at" DESC);



CREATE INDEX "idx_tickets_company_id" ON "public"."tickets" USING "btree" ("company_id");



CREATE INDEX "idx_tickets_created_at" ON "public"."tickets" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_tickets_deleted_at" ON "public"."tickets" USING "btree" ("deleted_at") WHERE ("deleted_at" IS NULL);



CREATE INDEX "idx_tickets_is_opened" ON "public"."tickets" USING "btree" ("is_opened");



CREATE INDEX "idx_tickets_stage_id" ON "public"."tickets" USING "btree" ("stage_id");



CREATE INDEX "idx_users_auth_user_id" ON "public"."users" USING "btree" ("auth_user_id");



CREATE INDEX "idx_users_last_session_at" ON "public"."users" USING "btree" ("last_session_at");



CREATE INDEX "idx_users_lookup_covering" ON "public"."users" USING "btree" ("id") INCLUDE ("email", "name", "surname");



CREATE INDEX "idx_verifactu_cert_history_company" ON "public"."verifactu_cert_history" USING "btree" ("company_id");



CREATE INDEX "idx_waitlist_client" ON "public"."waitlist" USING "btree" ("client_id");



CREATE INDEX "idx_waitlist_company" ON "public"."waitlist" USING "btree" ("company_id");



CREATE INDEX "idx_waitlist_service_time" ON "public"."waitlist" USING "btree" ("service_id", "start_time");



CREATE INDEX "item_tags_record_idx" ON "public"."item_tags" USING "btree" ("record_id", "record_type");



CREATE INDEX "item_tags_tag_idx" ON "public"."item_tags" USING "btree" ("tag_id");



CREATE UNIQUE INDEX "item_tags_unique_idx" ON "public"."item_tags" USING "btree" ("tag_id", "record_id", "record_type");



CREATE INDEX "ix_invoices_company_created_month" ON "public"."invoices" USING "btree" ("company_id", "created_by", "invoice_month");



CREATE INDEX "ix_invoices_date" ON "public"."invoices" USING "btree" ("invoice_date" DESC);



CREATE INDEX "ix_quotes_company_created_month" ON "public"."quotes" USING "btree" ("company_id", "created_by", "quote_month");



CREATE INDEX "ix_tickets_company_month" ON "public"."tickets" USING "btree" ("company_id", "ticket_month");



CREATE INDEX "ix_tickets_due_date" ON "public"."tickets" USING "btree" ("due_date");



CREATE INDEX "ix_verifactu_events_company" ON "public"."verifactu_events" USING "btree" ("companyid", "created_at" DESC);



CREATE INDEX "ix_verifactu_events_invoice" ON "public"."verifactu_events" USING "btree" ("invoiceid", "created_at" DESC);



CREATE INDEX "localities_name_idx" ON "public"."localities" USING "btree" ("name");



CREATE INDEX "product_catalog_embedding_idx" ON "public"."product_catalog" USING "hnsw" ("embedding" "public"."vector_ip_ops");



CREATE INDEX "product_catalog_search_idx" ON "public"."product_catalog" USING "gin" ("search_vector");



CREATE UNIQUE INDEX "project_reads_client_idx" ON "public"."project_reads" USING "btree" ("project_id", "client_id") WHERE ("client_id" IS NOT NULL);



CREATE UNIQUE INDEX "project_reads_user_idx" ON "public"."project_reads" USING "btree" ("project_id", "user_id") WHERE ("user_id" IS NOT NULL);



CREATE UNIQUE INDEX "service_units_company_code_uniq" ON "public"."service_units" USING "btree" (COALESCE("company_id", '00000000-0000-0000-0000-000000000000'::"uuid"), "lower"("code")) WHERE ("deleted_at" IS NULL);



CREATE UNIQUE INDEX "service_units_company_name_uniq" ON "public"."service_units" USING "btree" (COALESCE("company_id", '00000000-0000-0000-0000-000000000000'::"uuid"), "lower"("name")) WHERE ("deleted_at" IS NULL);



CREATE UNIQUE INDEX "services_name_company_unique_idx" ON "public"."services" USING "btree" ("name", "company_id");



CREATE UNIQUE INDEX "uniq_invoice_series_one_default_per_company" ON "public"."invoice_series" USING "btree" ("company_id") WHERE ("is_default" = true);



CREATE UNIQUE INDEX "uniq_invoice_templates_one_default_per_company" ON "public"."invoice_templates" USING "btree" ("company_id") WHERE ("is_default" = true);



CREATE UNIQUE INDEX "unique_default_stage_per_company" ON "public"."project_stages" USING "btree" ("company_id") WHERE ("is_default" = true);



CREATE UNIQUE INDEX "unique_final_stage_per_company" ON "public"."project_stages" USING "btree" ("company_id") WHERE ("is_final" = true);



CREATE UNIQUE INDEX "unique_landing_stage_per_company" ON "public"."project_stages" USING "btree" ("company_id") WHERE ("is_landing" = true);



CREATE UNIQUE INDEX "unique_review_stage_per_company" ON "public"."project_stages" USING "btree" ("company_id") WHERE ("is_review" = true);



CREATE UNIQUE INDEX "uq_active_quote_per_ticket" ON "public"."quotes" USING "btree" ("company_id", "ticket_id") WHERE (("ticket_id" IS NOT NULL) AND ("status" = ANY (ARRAY['draft'::"public"."quote_status", 'sent'::"public"."quote_status", 'viewed'::"public"."quote_status", 'accepted'::"public"."quote_status"])) AND ("invoice_id" IS NULL) AND (NOT "is_anonymized"));



CREATE UNIQUE INDEX "uq_company_invitations_pending_one_per_email_company" ON "public"."company_invitations" USING "btree" ("company_id", "email") WHERE ("status" = 'pending'::"text");



CREATE UNIQUE INDEX "ux_ticket_stages_company_cancel" ON "public"."ticket_stages" USING "btree" ("company_id") WHERE ("workflow_category" = 'cancel'::"public"."workflow_category");



CREATE UNIQUE INDEX "ux_ticket_stages_company_final" ON "public"."ticket_stages" USING "btree" ("company_id") WHERE ("workflow_category" = 'final'::"public"."workflow_category");



CREATE UNIQUE INDEX "ux_ticket_stages_system_name" ON "public"."ticket_stages" USING "btree" ("name") WHERE ("company_id" IS NULL);



CREATE UNIQUE INDEX "verifactu_settings_company_id_key" ON "public"."verifactu_settings" USING "btree" ("company_id");



CREATE OR REPLACE TRIGGER "anonymize_old_invoices_trigger" BEFORE UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."anonymize_invoice_data"();



CREATE OR REPLACE TRIGGER "audit_access_requests_changes" AFTER INSERT OR UPDATE ON "public"."gdpr_access_requests" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_audit_access_requests"();



COMMENT ON TRIGGER "audit_access_requests_changes" ON "public"."gdpr_access_requests" IS 'Registra cambios en solicitudes de acceso GDPR';



CREATE OR REPLACE TRIGGER "audit_consent_records_changes" AFTER INSERT OR UPDATE ON "public"."gdpr_consent_records" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_audit_consent_records"();



COMMENT ON TRIGGER "audit_consent_records_changes" ON "public"."gdpr_consent_records" IS 'Registra cambios en consentimientos GDPR';



CREATE OR REPLACE TRIGGER "audit_trigger_bookings" AFTER INSERT OR DELETE OR UPDATE ON "public"."bookings" FOR EACH ROW EXECUTE FUNCTION "public"."handle_global_audit"();



CREATE OR REPLACE TRIGGER "audit_trigger_clients" AFTER INSERT OR DELETE OR UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."handle_global_audit"();



CREATE OR REPLACE TRIGGER "audit_trigger_companies" AFTER INSERT OR DELETE OR UPDATE ON "public"."companies" FOR EACH ROW EXECUTE FUNCTION "public"."handle_global_audit"();



CREATE OR REPLACE TRIGGER "audit_trigger_company_members" AFTER INSERT OR DELETE OR UPDATE ON "public"."company_members" FOR EACH ROW EXECUTE FUNCTION "public"."handle_global_audit"();



CREATE OR REPLACE TRIGGER "audit_trigger_invoices" AFTER INSERT OR DELETE OR UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."handle_global_audit"();



CREATE OR REPLACE TRIGGER "audit_trigger_tickets" AFTER INSERT OR DELETE OR UPDATE ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."handle_global_audit"();



CREATE OR REPLACE TRIGGER "audit_trigger_users" AFTER INSERT OR DELETE OR UPDATE ON "public"."users" FOR EACH ROW EXECUTE FUNCTION "public"."handle_global_audit"();



CREATE OR REPLACE TRIGGER "audit_trigger_verifactu" AFTER INSERT OR DELETE OR UPDATE ON "public"."verifactu_settings" FOR EACH ROW EXECUTE FUNCTION "public"."handle_global_audit"();



CREATE OR REPLACE TRIGGER "clients_updated_at" BEFORE UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."handle_updated_at"();



CREATE OR REPLACE TRIGGER "companies_updated_at" BEFORE UPDATE ON "public"."companies" FOR EACH ROW EXECUTE FUNCTION "public"."handle_updated_at"();



CREATE OR REPLACE TRIGGER "ensure_initial_stage_insert" BEFORE INSERT ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."set_initial_ticket_stage"();



CREATE OR REPLACE TRIGGER "gdpr_audit_clients" AFTER INSERT OR DELETE OR UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."gdpr_audit_clients_trigger"();



CREATE OR REPLACE TRIGGER "gdpr_audit_clients_trigger" AFTER INSERT OR DELETE OR UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."gdpr_audit_clients_changes"();



CREATE OR REPLACE TRIGGER "google-calendar-sync" AFTER INSERT OR DELETE OR UPDATE ON "public"."bookings" FOR EACH ROW EXECUTE FUNCTION "supabase_functions"."http_request"('https://ufutyjbqfjrlzkprvyvs.supabase.co/functions/v1/google-calendar-sync', 'POST', '{"Authorization":"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVmdXR5amJxZmpybHprcHJ2eXZzIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2MjM0Njg2NCwiZXhwIjoyMDc3NzA2ODY0fQ.iyNKHYg9C5AaQ7IfJ5dKAETz9S6NoGNOpgYWgCmJ05g","Content-type":"application/json"}', '{}', '5000');



CREATE OR REPLACE TRIGGER "handle_updated_at" BEFORE UPDATE ON "public"."client_clinical_notes" FOR EACH ROW EXECUTE FUNCTION "extensions"."moddatetime"('updated_at');



CREATE OR REPLACE TRIGGER "invoices_immutability_trigger" BEFORE UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."invoices_immutability_guard"();



CREATE OR REPLACE TRIGGER "lead-assignment" AFTER UPDATE ON "public"."leads" FOR EACH ROW EXECUTE FUNCTION "supabase_functions"."http_request"('https://ufutyjbqfjrlzkprvyvs.supabase.co/functions/v1/notify-lead-assignment', 'POST', '{"Content-type":"application/json","Authorization":"Bearer sb_secret_g27uyjuwEIRZDUsnH2oyxw_TqNsYmhO"}', '{}', '5000');



CREATE OR REPLACE TRIGGER "on_booking_change" AFTER INSERT OR UPDATE ON "public"."bookings" FOR EACH ROW EXECUTE FUNCTION "public"."log_booking_changes"();



CREATE OR REPLACE TRIGGER "on_booking_changes" AFTER INSERT OR UPDATE OF "status", "start_time", "end_time" ON "public"."bookings" FOR EACH ROW EXECUTE FUNCTION "public"."notify_booking_notifier"();



CREATE OR REPLACE TRIGGER "on_client_created_link" BEFORE INSERT ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."handle_new_client_link"();



CREATE OR REPLACE TRIGGER "on_gdpr_consent_change" AFTER INSERT OR UPDATE OF "consent_given" ON "public"."gdpr_consent_records" FOR EACH ROW EXECUTE FUNCTION "public"."handle_gdpr_consent_notification"();



CREATE OR REPLACE TRIGGER "on_gdpr_consent_sync_client" AFTER INSERT OR UPDATE ON "public"."gdpr_consent_records" FOR EACH ROW EXECUTE FUNCTION "public"."sync_gdpr_to_client_consent"();



CREATE OR REPLACE TRIGGER "on_gdpr_request_created" AFTER INSERT ON "public"."gdpr_access_requests" FOR EACH ROW EXECUTE FUNCTION "public"."notify_owner_on_gdpr_request"();



CREATE OR REPLACE TRIGGER "on_mail_account_created" AFTER INSERT ON "public"."mail_accounts" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_init_mail_folders"();



CREATE OR REPLACE TRIGGER "on_project_comment_created" AFTER INSERT ON "public"."project_comments" FOR EACH ROW EXECUTE FUNCTION "public"."handle_new_project_comment"();



CREATE OR REPLACE TRIGGER "on_ticket_stage_change" BEFORE UPDATE ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."handle_ticket_state_transition"();



CREATE OR REPLACE TRIGGER "on_user_created_link" BEFORE INSERT ON "public"."users" FOR EACH ROW EXECUTE FUNCTION "public"."handle_new_user_link"();



CREATE OR REPLACE TRIGGER "recalculate_invoice_totals_on_item_delete" AFTER DELETE ON "public"."invoice_items" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_invoice_totals_trigger"();



CREATE OR REPLACE TRIGGER "recalculate_invoice_totals_on_item_insert" AFTER INSERT ON "public"."invoice_items" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_invoice_totals_trigger"();



CREATE OR REPLACE TRIGGER "recalculate_invoice_totals_on_item_update" AFTER UPDATE ON "public"."invoice_items" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_invoice_totals_trigger"();



CREATE OR REPLACE TRIGGER "recalculate_invoice_totals_on_payment" AFTER INSERT OR DELETE OR UPDATE ON "public"."invoice_payments" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_invoice_totals_payment_trigger"();



CREATE OR REPLACE TRIGGER "set_professional_titles_updated_at" BEFORE UPDATE ON "public"."professional_titles" FOR EACH ROW EXECUTE FUNCTION "public"."handle_updated_at"();



CREATE OR REPLACE TRIGGER "t_invoices_immutable_after_issue" BEFORE UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."fn_invoice_immutable_after_issue"();



CREATE OR REPLACE TRIGGER "ticket_auto_assign_trigger" BEFORE INSERT ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."handle_ticket_auto_assignment"();



CREATE OR REPLACE TRIGGER "ticket_services_upsert_trigger" AFTER INSERT OR DELETE OR UPDATE ON "public"."ticket_services" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_ticket_services_upsert"();



CREATE OR REPLACE TRIGGER "tr_activate_recurring_service" AFTER UPDATE OF "payment_status" ON "public"."invoices" FOR EACH ROW WHEN (("new"."payment_status" = 'paid'::"text")) EXECUTE FUNCTION "public"."activate_recurring_service_on_payment"();



CREATE OR REPLACE TRIGGER "tr_device_status_change" BEFORE UPDATE ON "public"."devices" FOR EACH ROW EXECUTE FUNCTION "public"."log_device_status_change"();



CREATE OR REPLACE TRIGGER "tr_devices_updated_at" BEFORE UPDATE ON "public"."devices" FOR EACH ROW EXECUTE FUNCTION "public"."update_device_updated_at"();



CREATE OR REPLACE TRIGGER "trg_app_settings_updated_at" BEFORE UPDATE ON "public"."app_settings" FOR EACH ROW EXECUTE FUNCTION "public"."fn_touch_updated_at"();



CREATE OR REPLACE TRIGGER "trg_audit_invoices" AFTER INSERT OR UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."gdpr_audit_trigger"();



CREATE OR REPLACE TRIGGER "trg_auto_move_to_review" AFTER INSERT OR UPDATE OF "is_completed" ON "public"."project_tasks" FOR EACH ROW EXECUTE FUNCTION "public"."auto_move_project_to_review"();



CREATE OR REPLACE TRIGGER "trg_company_settings_updated_at" BEFORE UPDATE ON "public"."company_settings" FOR EACH ROW EXECUTE FUNCTION "public"."fn_touch_updated_at"();



CREATE OR REPLACE TRIGGER "trg_company_stage_order_updated_at" BEFORE UPDATE ON "public"."company_stage_order" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at_timestamp"();



CREATE OR REPLACE TRIGGER "trg_invoices_immutable" BEFORE UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."invoices_immutability_guard"();



CREATE OR REPLACE TRIGGER "trg_notify_assignment" AFTER UPDATE ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."handle_ticket_assignment_notification"();



CREATE OR REPLACE TRIGGER "trg_notify_client_comment" AFTER INSERT ON "public"."ticket_comments" FOR EACH ROW EXECUTE FUNCTION "public"."handle_ticket_comment_notification"();



CREATE OR REPLACE TRIGGER "trg_notify_critical" AFTER UPDATE ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."handle_ticket_critical_notification"();



CREATE OR REPLACE TRIGGER "trg_payment_integrations_updated_at" BEFORE UPDATE ON "public"."payment_integrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_payment_integrations_updated_at"();



CREATE OR REPLACE TRIGGER "trg_restore_original_on_void" AFTER UPDATE ON "public"."invoices" FOR EACH ROW WHEN ((("new"."status" = 'void'::"public"."invoice_status") AND ("old"."status" IS DISTINCT FROM 'void'::"public"."invoice_status"))) EXECUTE FUNCTION "public"."restore_original_invoice_on_void"();



CREATE OR REPLACE TRIGGER "trg_service_units_updated_at" BEFORE UPDATE ON "public"."service_units" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_set_invoice_month" BEFORE INSERT OR UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."set_invoice_month"();



CREATE OR REPLACE TRIGGER "trg_set_quote_month" BEFORE INSERT OR UPDATE ON "public"."quotes" FOR EACH ROW EXECUTE FUNCTION "public"."set_quote_month"();



CREATE OR REPLACE TRIGGER "trg_set_ticket_month" BEFORE INSERT OR UPDATE ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."set_ticket_month"();



CREATE OR REPLACE TRIGGER "trg_set_ticket_number" BEFORE INSERT ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."set_ticket_number"();



CREATE OR REPLACE TRIGGER "trg_set_updated_at_ticket_products" BEFORE UPDATE ON "public"."ticket_products" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at_ticket_products"();



CREATE OR REPLACE TRIGGER "trg_sla_response" AFTER INSERT ON "public"."ticket_comments" FOR EACH ROW EXECUTE FUNCTION "public"."handle_ticket_first_response"();



CREATE OR REPLACE TRIGGER "trg_ticket_audit" AFTER INSERT OR UPDATE ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."handle_ticket_audit_log"();



CREATE OR REPLACE TRIGGER "trg_ticket_comments_maintain_integrity" BEFORE INSERT OR UPDATE ON "public"."ticket_comments" FOR EACH ROW EXECUTE FUNCTION "public"."fn_ticket_comments_maintain_integrity"();



CREATE OR REPLACE TRIGGER "trg_ticket_stages_min_per_category_del" AFTER DELETE ON "public"."ticket_stages" FOR EACH ROW EXECUTE FUNCTION "public"."ensure_min_one_stage_per_category"();



CREATE OR REPLACE TRIGGER "trg_ticket_stages_min_per_category_upd" AFTER UPDATE OF "workflow_category", "company_id", "deleted_at" ON "public"."ticket_stages" FOR EACH ROW WHEN ((("old"."workflow_category" IS DISTINCT FROM "new"."workflow_category") OR ("new"."deleted_at" IS NOT NULL) OR ("old"."company_id" IS DISTINCT FROM "new"."company_id"))) EXECUTE FUNCTION "public"."ensure_min_one_stage_per_category"();



CREATE OR REPLACE TRIGGER "trg_verifactu_settings_updated_at" BEFORE UPDATE ON "public"."verifactu_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trigger_anonymize_old_quotes" AFTER UPDATE ON "public"."quotes" FOR EACH ROW WHEN ((("new"."retention_until" < CURRENT_DATE) AND (NOT "new"."is_anonymized"))) EXECUTE FUNCTION "public"."anonymize_quote_data"();



CREATE OR REPLACE TRIGGER "trigger_auto_cancel_on_delete" BEFORE UPDATE ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."handle_ticket_soft_delete"();



CREATE OR REPLACE TRIGGER "trigger_auto_move_on_task_change" AFTER INSERT OR DELETE OR UPDATE OF "is_completed" ON "public"."project_tasks" FOR EACH ROW EXECUTE FUNCTION "public"."handle_project_auto_move"();



CREATE OR REPLACE TRIGGER "trigger_calculate_quote_item_totals" BEFORE INSERT OR UPDATE ON "public"."quote_items" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_quote_item_totals"();



CREATE OR REPLACE TRIGGER "trigger_comment_notifications" AFTER INSERT ON "public"."ticket_comments" FOR EACH ROW EXECUTE FUNCTION "public"."handle_comment_notifications"();



CREATE OR REPLACE TRIGGER "trigger_invoice_verifactu" AFTER INSERT OR UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "verifactu"."handle_invoice_verifactu"();



CREATE OR REPLACE TRIGGER "trigger_link_pending_professional" AFTER INSERT ON "public"."company_members" FOR EACH ROW EXECUTE FUNCTION "public"."link_pending_professional"();



CREATE OR REPLACE TRIGGER "trigger_maintain_opened_status" BEFORE INSERT OR UPDATE OF "stage_id", "deleted_at" ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."maintain_ticket_opened_status"();



CREATE OR REPLACE TRIGGER "trigger_quote_items_updated_at" BEFORE UPDATE ON "public"."quote_items" FOR EACH ROW EXECUTE FUNCTION "public"."update_quotes_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_quote_templates_updated_at" BEFORE UPDATE ON "public"."quote_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_quotes_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_quotes_updated_at" BEFORE UPDATE ON "public"."quotes" FOR EACH ROW EXECUTE FUNCTION "public"."update_quotes_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_recalculate_quote_totals_delete" AFTER DELETE ON "public"."quote_items" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_quote_totals"();



CREATE OR REPLACE TRIGGER "trigger_recalculate_quote_totals_insert" AFTER INSERT ON "public"."quote_items" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_quote_totals"();



CREATE OR REPLACE TRIGGER "trigger_recalculate_quote_totals_update" AFTER UPDATE ON "public"."quote_items" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_quote_totals"();



CREATE OR REPLACE TRIGGER "trigger_sync_ticket_tags_from_services" AFTER INSERT ON "public"."ticket_services" FOR EACH ROW EXECUTE FUNCTION "public"."sync_ticket_tags_from_services"();



CREATE OR REPLACE TRIGGER "trigger_ticket_comment_automation" AFTER INSERT ON "public"."ticket_comments" FOR EACH ROW EXECUTE FUNCTION "public"."handle_ticket_comment_automation"();



CREATE OR REPLACE TRIGGER "trigger_ticket_notifications" AFTER INSERT OR UPDATE ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."handle_ticket_notifications"();



CREATE OR REPLACE TRIGGER "trigger_update_client_stats" AFTER UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."update_client_stats_on_change"();



CREATE OR REPLACE TRIGGER "trigger_update_service_variants_updated_at" BEFORE UPDATE ON "public"."service_variants" FOR EACH ROW EXECUTE FUNCTION "public"."update_service_variants_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_verifactu_settings_updated_at" BEFORE UPDATE ON "public"."verifactu_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_verifactu_settings_updated_at"();



CREATE OR REPLACE TRIGGER "update_addresses_updated_at" BEFORE UPDATE ON "public"."addresses" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_companies_updated_at" BEFORE UPDATE ON "public"."companies" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_employee_commissions_config_updated_at" BEFORE UPDATE ON "public"."employee_commissions_config" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_employees_updated_at" BEFORE UPDATE ON "public"."employees" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_invoice_series_updated_at" BEFORE UPDATE ON "public"."invoice_series" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_invoice_templates_updated_at" BEFORE UPDATE ON "public"."invoice_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_invoices_updated_at" BEFORE UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_leads_updated_at" BEFORE UPDATE ON "public"."leads" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_mail_accounts_modtime" BEFORE UPDATE ON "public"."mail_accounts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_mail_folders_modtime" BEFORE UPDATE ON "public"."mail_folders" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_mail_messages_modtime" BEFORE UPDATE ON "public"."mail_messages" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_mail_threads_modtime" BEFORE UPDATE ON "public"."mail_threads" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_marketing_metrics_updated_at" BEFORE UPDATE ON "public"."marketing_metrics" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_services_updated_at" BEFORE UPDATE ON "public"."services" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_tickets_updated_at" BEFORE UPDATE ON "public"."tickets" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "users_updated_at" BEFORE UPDATE ON "public"."users" FOR EACH ROW EXECUTE FUNCTION "public"."handle_updated_at"();



ALTER TABLE ONLY "public"."addresses"
    ADD CONSTRAINT "addresses_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."addresses"
    ADD CONSTRAINT "addresses_locality_id_fkey" FOREIGN KEY ("locality_id") REFERENCES "public"."localities"("id");



ALTER TABLE ONLY "public"."addresses"
    ADD CONSTRAINT "addresses_usuario_id_fkey" FOREIGN KEY ("usuario_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ai_usage_logs"
    ADD CONSTRAINT "ai_usage_logs_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ai_usage_logs"
    ADD CONSTRAINT "ai_usage_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."attachments"
    ADD CONSTRAINT "attachments_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_actor_id_fkey" FOREIGN KEY ("actor_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."availability_exceptions"
    ADD CONSTRAINT "availability_exceptions_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."availability_exceptions"
    ADD CONSTRAINT "availability_exceptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."availability_schedules"
    ADD CONSTRAINT "availability_schedules_booking_type_id_fkey" FOREIGN KEY ("booking_type_id") REFERENCES "public"."booking_types"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."availability_schedules"
    ADD CONSTRAINT "availability_schedules_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."booking_history"
    ADD CONSTRAINT "booking_history_booking_id_fkey" FOREIGN KEY ("booking_id") REFERENCES "public"."bookings"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."booking_history"
    ADD CONSTRAINT "booking_history_changed_by_user_id_fkey" FOREIGN KEY ("changed_by_user_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."booking_history"
    ADD CONSTRAINT "booking_history_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."booking_types"
    ADD CONSTRAINT "booking_types_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."booking_types"
    ADD CONSTRAINT "booking_types_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."bookings"
    ADD CONSTRAINT "bookings_booking_type_id_fkey" FOREIGN KEY ("booking_type_id") REFERENCES "public"."booking_types"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."bookings"
    ADD CONSTRAINT "bookings_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."bookings"
    ADD CONSTRAINT "bookings_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."bookings"
    ADD CONSTRAINT "bookings_coupon_id_fkey" FOREIGN KEY ("coupon_id") REFERENCES "public"."coupons"("id");



ALTER TABLE ONLY "public"."bookings"
    ADD CONSTRAINT "bookings_professional_id_fkey" FOREIGN KEY ("professional_id") REFERENCES "public"."professionals"("id");



ALTER TABLE ONLY "public"."bookings"
    ADD CONSTRAINT "bookings_quote_id_fkey" FOREIGN KEY ("quote_id") REFERENCES "public"."quotes"("id");



ALTER TABLE ONLY "public"."bookings"
    ADD CONSTRAINT "bookings_resource_id_fkey" FOREIGN KEY ("resource_id") REFERENCES "public"."resources"("id");



ALTER TABLE ONLY "public"."bookings"
    ADD CONSTRAINT "bookings_room_id_fkey" FOREIGN KEY ("room_id") REFERENCES "public"."rooms"("id");



ALTER TABLE ONLY "public"."bookings"
    ADD CONSTRAINT "bookings_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id");



ALTER TABLE ONLY "public"."client_assignments"
    ADD CONSTRAINT "client_assignments_assigned_by_fkey" FOREIGN KEY ("assigned_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."client_assignments"
    ADD CONSTRAINT "client_assignments_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_assignments"
    ADD CONSTRAINT "client_assignments_company_member_id_fkey" FOREIGN KEY ("company_member_id") REFERENCES "public"."company_members"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_clinical_notes"
    ADD CONSTRAINT "client_clinical_notes_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_clinical_notes"
    ADD CONSTRAINT "client_clinical_notes_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."client_contacts"
    ADD CONSTRAINT "client_contacts_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_documents"
    ADD CONSTRAINT "client_documents_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_documents"
    ADD CONSTRAINT "client_documents_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_documents"
    ADD CONSTRAINT "client_documents_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."client_notes"
    ADD CONSTRAINT "client_notes_author_id_fkey" FOREIGN KEY ("author_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."client_notes"
    ADD CONSTRAINT "client_notes_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_notes"
    ADD CONSTRAINT "client_notes_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."client_portal_users"
    ADD CONSTRAINT "client_portal_users_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_portal_users"
    ADD CONSTRAINT "client_portal_users_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_portal_users"
    ADD CONSTRAINT "client_portal_users_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."client_variant_assignments"
    ADD CONSTRAINT "client_variant_assignments_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_variant_assignments"
    ADD CONSTRAINT "client_variant_assignments_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."client_variant_assignments"
    ADD CONSTRAINT "client_variant_assignments_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_variant_assignments"
    ADD CONSTRAINT "client_variant_assignments_variant_id_fkey" FOREIGN KEY ("variant_id") REFERENCES "public"."service_variants"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_assigned_to_fkey" FOREIGN KEY ("assigned_to") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_auth_user_id_fkey" FOREIGN KEY ("auth_user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_direccion_id_fkey" FOREIGN KEY ("direccion_id") REFERENCES "public"."addresses"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."clients_tags"
    ADD CONSTRAINT "clients_tags_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."clients_tags"
    ADD CONSTRAINT "clients_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."global_tags"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."company_invitations"
    ADD CONSTRAINT "company_invitations_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."company_invitations"
    ADD CONSTRAINT "company_invitations_invited_by_user_id_fkey" FOREIGN KEY ("invited_by_user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."company_members"
    ADD CONSTRAINT "company_members_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."company_members"
    ADD CONSTRAINT "company_members_role_id_fkey" FOREIGN KEY ("role_id") REFERENCES "public"."app_roles"("id");



ALTER TABLE ONLY "public"."company_members"
    ADD CONSTRAINT "company_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."company_modules"
    ADD CONSTRAINT "company_modules_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."company_settings"
    ADD CONSTRAINT "company_settings_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."company_settings"
    ADD CONSTRAINT "company_settings_ticket_stage_on_client_reply_fkey" FOREIGN KEY ("ticket_stage_on_client_reply") REFERENCES "public"."ticket_stages"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."company_settings"
    ADD CONSTRAINT "company_settings_ticket_stage_on_delete_fkey" FOREIGN KEY ("ticket_stage_on_delete") REFERENCES "public"."ticket_stages"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."company_settings"
    ADD CONSTRAINT "company_settings_ticket_stage_on_staff_reply_fkey" FOREIGN KEY ("ticket_stage_on_staff_reply") REFERENCES "public"."ticket_stages"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."company_stage_order"
    ADD CONSTRAINT "company_stage_order_stage_id_fkey" FOREIGN KEY ("stage_id") REFERENCES "public"."ticket_stages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."company_ticket_sequences"
    ADD CONSTRAINT "company_ticket_sequences_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."content_posts"
    ADD CONSTRAINT "content_posts_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."contract_templates"
    ADD CONSTRAINT "contract_templates_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "contracts_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "contracts_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "contracts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."coupons"
    ADD CONSTRAINT "coupons_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."device_components"
    ADD CONSTRAINT "device_components_device_id_fkey" FOREIGN KEY ("device_id") REFERENCES "public"."devices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."device_media"
    ADD CONSTRAINT "device_media_device_id_fkey" FOREIGN KEY ("device_id") REFERENCES "public"."devices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."device_media"
    ADD CONSTRAINT "device_media_taken_by_fkey" FOREIGN KEY ("taken_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."device_media"
    ADD CONSTRAINT "device_media_ticket_device_id_fkey" FOREIGN KEY ("ticket_device_id") REFERENCES "public"."ticket_devices"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."device_status_history"
    ADD CONSTRAINT "device_status_history_changed_by_fkey" FOREIGN KEY ("changed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."device_status_history"
    ADD CONSTRAINT "device_status_history_device_id_fkey" FOREIGN KEY ("device_id") REFERENCES "public"."devices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."devices"
    ADD CONSTRAINT "devices_client_company_fkey" FOREIGN KEY ("client_id", "company_id") REFERENCES "public"."clients"("id", "company_id");



ALTER TABLE ONLY "public"."devices"
    ADD CONSTRAINT "devices_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."devices"
    ADD CONSTRAINT "devices_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."devices"
    ADD CONSTRAINT "devices_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."domains"
    ADD CONSTRAINT "domains_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."employee_commissions_config"
    ADD CONSTRAINT "employee_commissions_config_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."employee_commissions_config"
    ADD CONSTRAINT "employee_commissions_config_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "public"."employees"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."employee_commissions_config"
    ADD CONSTRAINT "employee_commissions_config_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."employee_documents"
    ADD CONSTRAINT "employee_documents_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."employee_documents"
    ADD CONSTRAINT "employee_documents_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "public"."employees"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."employee_productivity_logs"
    ADD CONSTRAINT "employee_productivity_logs_booking_id_fkey" FOREIGN KEY ("booking_id") REFERENCES "public"."bookings"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."employee_productivity_logs"
    ADD CONSTRAINT "employee_productivity_logs_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."employee_productivity_logs"
    ADD CONSTRAINT "employee_productivity_logs_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "public"."employees"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."employees"
    ADD CONSTRAINT "employees_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."employees"
    ADD CONSTRAINT "employees_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."gdpr_access_requests"
    ADD CONSTRAINT "gdpr_access_requests_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."gdpr_access_requests"
    ADD CONSTRAINT "gdpr_access_requests_requested_by_fkey" FOREIGN KEY ("requested_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."gdpr_audit_log"
    ADD CONSTRAINT "gdpr_audit_log_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."gdpr_audit_log"
    ADD CONSTRAINT "gdpr_audit_log_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."gdpr_breach_incidents"
    ADD CONSTRAINT "gdpr_breach_incidents_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."gdpr_breach_incidents"
    ADD CONSTRAINT "gdpr_breach_incidents_reported_by_fkey" FOREIGN KEY ("reported_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."gdpr_consent_records"
    ADD CONSTRAINT "gdpr_consent_records_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."gdpr_consent_records"
    ADD CONSTRAINT "gdpr_consent_records_processed_by_fkey" FOREIGN KEY ("processed_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."gdpr_consent_requests"
    ADD CONSTRAINT "gdpr_consent_requests_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."gdpr_consent_requests"
    ADD CONSTRAINT "gdpr_consent_requests_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."gdpr_processing_activities"
    ADD CONSTRAINT "gdpr_processing_activities_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."google_calendar_configs"
    ADD CONSTRAINT "google_calendar_configs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."hidden_stages"
    ADD CONSTRAINT "hidden_stages_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."hidden_stages"
    ADD CONSTRAINT "hidden_stages_hidden_by_fkey" FOREIGN KEY ("hidden_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."hidden_stages"
    ADD CONSTRAINT "hidden_stages_stage_id_fkey" FOREIGN KEY ("stage_id") REFERENCES "public"."ticket_stages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."hidden_units"
    ADD CONSTRAINT "hidden_units_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."hidden_units"
    ADD CONSTRAINT "hidden_units_hidden_by_fkey" FOREIGN KEY ("hidden_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."hidden_units"
    ADD CONSTRAINT "hidden_units_unit_id_fkey" FOREIGN KEY ("unit_id") REFERENCES "public"."service_units"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."integrations"
    ADD CONSTRAINT "integrations_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."integrations"
    ADD CONSTRAINT "integrations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."invoice_items"
    ADD CONSTRAINT "invoice_items_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."invoice_payments"
    ADD CONSTRAINT "invoice_payments_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."invoice_payments"
    ADD CONSTRAINT "invoice_payments_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."invoice_series"
    ADD CONSTRAINT "invoice_series_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."invoice_series"
    ADD CONSTRAINT "invoice_series_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."invoice_templates"
    ADD CONSTRAINT "invoice_templates_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."invoice_templates"
    ADD CONSTRAINT "invoice_templates_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_lead_id_fkey" FOREIGN KEY ("lead_id") REFERENCES "public"."leads"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_rectifies_invoice_id_fkey" FOREIGN KEY ("rectifies_invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_series_id_fkey" FOREIGN KEY ("series_id") REFERENCES "public"."invoice_series"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_source_quote_id_fkey" FOREIGN KEY ("source_quote_id") REFERENCES "public"."quotes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."item_tags"
    ADD CONSTRAINT "item_tags_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."item_tags"
    ADD CONSTRAINT "item_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."global_tags"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."job_notes"
    ADD CONSTRAINT "job_notes_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."job_notes"
    ADD CONSTRAINT "job_notes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."lead_interactions"
    ADD CONSTRAINT "lead_interactions_lead_id_fkey" FOREIGN KEY ("lead_id") REFERENCES "public"."leads"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."lead_interactions"
    ADD CONSTRAINT "lead_interactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."lead_sources"
    ADD CONSTRAINT "lead_sources_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."mail_accounts"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_assigned_to_fkey" FOREIGN KEY ("assigned_to") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_lead_source_id_fkey" FOREIGN KEY ("lead_source_id") REFERENCES "public"."lead_sources"("id");



ALTER TABLE ONLY "public"."loyalty_points"
    ADD CONSTRAINT "loyalty_points_booking_id_fkey" FOREIGN KEY ("booking_id") REFERENCES "public"."bookings"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."loyalty_points"
    ADD CONSTRAINT "loyalty_points_client_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."loyalty_points"
    ADD CONSTRAINT "loyalty_points_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mail_accounts"
    ADD CONSTRAINT "mail_accounts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mail_attachments"
    ADD CONSTRAINT "mail_attachments_message_id_fkey" FOREIGN KEY ("message_id") REFERENCES "public"."mail_messages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mail_contacts"
    ADD CONSTRAINT "mail_contacts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mail_folders"
    ADD CONSTRAINT "mail_folders_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."mail_accounts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mail_folders"
    ADD CONSTRAINT "mail_folders_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."mail_folders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mail_messages"
    ADD CONSTRAINT "mail_messages_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."mail_accounts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mail_messages"
    ADD CONSTRAINT "mail_messages_folder_id_fkey" FOREIGN KEY ("folder_id") REFERENCES "public"."mail_folders"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."mail_messages"
    ADD CONSTRAINT "mail_messages_thread_id_fkey" FOREIGN KEY ("thread_id") REFERENCES "public"."mail_threads"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."mail_threads"
    ADD CONSTRAINT "mail_threads_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."mail_accounts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."marketing_campaigns"
    ADD CONSTRAINT "marketing_campaigns_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."marketing_campaigns"
    ADD CONSTRAINT "marketing_campaigns_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."marketing_logs"
    ADD CONSTRAINT "marketing_logs_campaign_id_fkey" FOREIGN KEY ("campaign_id") REFERENCES "public"."marketing_campaigns"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."marketing_logs"
    ADD CONSTRAINT "marketing_logs_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."marketing_metrics"
    ADD CONSTRAINT "marketing_metrics_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notification_logs"
    ADD CONSTRAINT "notification_logs_booking_id_fkey" FOREIGN KEY ("booking_id") REFERENCES "public"."bookings"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."notification_logs"
    ADD CONSTRAINT "notification_logs_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notification_logs"
    ADD CONSTRAINT "notification_logs_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."notification_templates"("id");



ALTER TABLE ONLY "public"."notification_templates"
    ADD CONSTRAINT "notification_templates_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_client_recipient_id_fkey" FOREIGN KEY ("client_recipient_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_recipient_id_fkey" FOREIGN KEY ("recipient_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_integrations"
    ADD CONSTRAINT "payment_integrations_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_users"
    ADD CONSTRAINT "pending_users_auth_user_id_fkey" FOREIGN KEY ("auth_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_users"
    ADD CONSTRAINT "pending_users_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."product_brands"
    ADD CONSTRAINT "product_brands_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_catalog"
    ADD CONSTRAINT "product_catalog_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."product_categories"
    ADD CONSTRAINT "product_categories_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_categories"
    ADD CONSTRAINT "product_categories_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."product_categories"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."product_models"
    ADD CONSTRAINT "product_models_brand_id_fkey" FOREIGN KEY ("brand_id") REFERENCES "public"."product_brands"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_models"
    ADD CONSTRAINT "product_models_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_brand_id_fkey" FOREIGN KEY ("brand_id") REFERENCES "public"."product_brands"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_catalog_product_id_fkey" FOREIGN KEY ("catalog_product_id") REFERENCES "public"."product_catalog"("id");



ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."product_categories"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."professional_documents"
    ADD CONSTRAINT "professional_documents_professional_id_fkey" FOREIGN KEY ("professional_id") REFERENCES "public"."professionals"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."professional_schedules"
    ADD CONSTRAINT "professional_schedules_professional_id_fkey" FOREIGN KEY ("professional_id") REFERENCES "public"."professionals"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."professional_services"
    ADD CONSTRAINT "professional_services_professional_id_fkey" FOREIGN KEY ("professional_id") REFERENCES "public"."professionals"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."professional_services"
    ADD CONSTRAINT "professional_services_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."professional_titles"
    ADD CONSTRAINT "professional_titles_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."professionals"
    ADD CONSTRAINT "professionals_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."professionals"
    ADD CONSTRAINT "professionals_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_activity"
    ADD CONSTRAINT "project_activity_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."project_activity"
    ADD CONSTRAINT "project_activity_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_activity"
    ADD CONSTRAINT "project_activity_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_activity"
    ADD CONSTRAINT "project_activity_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."project_comments"
    ADD CONSTRAINT "project_comments_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_comments"
    ADD CONSTRAINT "project_comments_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_comments"
    ADD CONSTRAINT "project_comments_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_files"
    ADD CONSTRAINT "project_files_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."project_files"
    ADD CONSTRAINT "project_files_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."project_files"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_files"
    ADD CONSTRAINT "project_files_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_notification_preferences"
    ADD CONSTRAINT "project_notification_preferences_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_notification_preferences"
    ADD CONSTRAINT "project_notification_preferences_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_notification_preferences"
    ADD CONSTRAINT "project_notification_preferences_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_permissions"
    ADD CONSTRAINT "project_permissions_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_reads"
    ADD CONSTRAINT "project_reads_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_reads"
    ADD CONSTRAINT "project_reads_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_reads"
    ADD CONSTRAINT "project_reads_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_stages"
    ADD CONSTRAINT "project_stages_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_tasks"
    ADD CONSTRAINT "project_tasks_assigned_to_fkey" FOREIGN KEY ("assigned_to") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."project_tasks"
    ADD CONSTRAINT "project_tasks_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_stage_id_fkey" FOREIGN KEY ("stage_id") REFERENCES "public"."project_stages"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."quote_items"
    ADD CONSTRAINT "quote_items_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."quote_items"
    ADD CONSTRAINT "quote_items_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."quote_items"
    ADD CONSTRAINT "quote_items_quote_id_fkey" FOREIGN KEY ("quote_id") REFERENCES "public"."quotes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."quote_items"
    ADD CONSTRAINT "quote_items_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."quote_items"
    ADD CONSTRAINT "quote_items_variant_id_fkey" FOREIGN KEY ("variant_id") REFERENCES "public"."service_variants"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."quote_templates"
    ADD CONSTRAINT "quote_templates_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."quote_templates"
    ADD CONSTRAINT "quote_templates_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_booking_id_fkey" FOREIGN KEY ("booking_id") REFERENCES "public"."bookings"("id");



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_rectifies_invoice_id_fkey" FOREIGN KEY ("rectifies_invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_ticket_id_fkey" FOREIGN KEY ("ticket_id") REFERENCES "public"."tickets"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."resources"
    ADD CONSTRAINT "resources_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."role_permissions"
    ADD CONSTRAINT "role_permissions_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."role_permissions"
    ADD CONSTRAINT "role_permissions_role_id_fkey" FOREIGN KEY ("role_id") REFERENCES "public"."app_roles"("id");



ALTER TABLE ONLY "public"."rooms"
    ADD CONSTRAINT "rooms_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_booking_id_fkey" FOREIGN KEY ("booking_id") REFERENCES "public"."bookings"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."service_categories"
    ADD CONSTRAINT "service_categories_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."service_units"
    ADD CONSTRAINT "service_units_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."service_variants"
    ADD CONSTRAINT "service_variants_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."services"
    ADD CONSTRAINT "services_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."services_tags"
    ADD CONSTRAINT "services_tags_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."services_tags"
    ADD CONSTRAINT "services_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."global_tags"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."social_metrics"
    ADD CONSTRAINT "social_metrics_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stock_movements"
    ADD CONSTRAINT "stock_movements_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."stock_movements"
    ADD CONSTRAINT "stock_movements_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id");



ALTER TABLE ONLY "public"."stock_movements"
    ADD CONSTRAINT "stock_movements_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."supplier_products"
    ADD CONSTRAINT "supplier_products_catalog_product_id_fkey" FOREIGN KEY ("catalog_product_id") REFERENCES "public"."product_catalog"("id");



ALTER TABLE ONLY "public"."supplier_products"
    ADD CONSTRAINT "supplier_products_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."supplier_products"
    ADD CONSTRAINT "supplier_products_supplier_id_fkey" FOREIGN KEY ("supplier_id") REFERENCES "public"."suppliers"("id");



ALTER TABLE ONLY "public"."suppliers"
    ADD CONSTRAINT "suppliers_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."tag_scopes"
    ADD CONSTRAINT "tag_scopes_module_key_fkey" FOREIGN KEY ("module_key") REFERENCES "public"."modules"("key") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."ticket_comment_attachments"
    ADD CONSTRAINT "ticket_comment_attachments_attachment_id_fkey" FOREIGN KEY ("attachment_id") REFERENCES "public"."attachments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_comment_attachments"
    ADD CONSTRAINT "ticket_comment_attachments_comment_id_fkey" FOREIGN KEY ("comment_id") REFERENCES "public"."ticket_comments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_comment_versions"
    ADD CONSTRAINT "ticket_comment_versions_changed_by_fkey" FOREIGN KEY ("changed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ticket_comment_versions"
    ADD CONSTRAINT "ticket_comment_versions_comment_id_fkey" FOREIGN KEY ("comment_id") REFERENCES "public"."ticket_comments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_comments"
    ADD CONSTRAINT "ticket_comments_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."ticket_comments"
    ADD CONSTRAINT "ticket_comments_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."ticket_comments"("id");



ALTER TABLE ONLY "public"."ticket_comments"
    ADD CONSTRAINT "ticket_comments_ticket_id_fkey" FOREIGN KEY ("ticket_id") REFERENCES "public"."tickets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_comments"
    ADD CONSTRAINT "ticket_comments_user_id_fkey_public" FOREIGN KEY ("user_id") REFERENCES "public"."users"("auth_user_id") ON DELETE CASCADE;



COMMENT ON CONSTRAINT "ticket_comments_user_id_fkey_public" ON "public"."ticket_comments" IS 'Allows PostgREST to embed public.users via user_id -> users.auth_user_id (unique), while preserving auth.users FK semantics.';



ALTER TABLE ONLY "public"."ticket_devices"
    ADD CONSTRAINT "ticket_devices_device_id_fkey" FOREIGN KEY ("device_id") REFERENCES "public"."devices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_devices"
    ADD CONSTRAINT "ticket_devices_ticket_id_fkey" FOREIGN KEY ("ticket_id") REFERENCES "public"."tickets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_macros"
    ADD CONSTRAINT "ticket_macros_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_macros"
    ADD CONSTRAINT "ticket_macros_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."ticket_products"
    ADD CONSTRAINT "ticket_products_catalog_product_id_fkey" FOREIGN KEY ("catalog_product_id") REFERENCES "public"."product_catalog"("id");



ALTER TABLE ONLY "public"."ticket_products"
    ADD CONSTRAINT "ticket_products_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_products"
    ADD CONSTRAINT "ticket_products_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."ticket_products"
    ADD CONSTRAINT "ticket_products_ticket_id_fkey" FOREIGN KEY ("ticket_id") REFERENCES "public"."tickets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_services"
    ADD CONSTRAINT "ticket_services_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."ticket_services"
    ADD CONSTRAINT "ticket_services_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_services"
    ADD CONSTRAINT "ticket_services_ticket_id_fkey" FOREIGN KEY ("ticket_id") REFERENCES "public"."tickets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_services"
    ADD CONSTRAINT "ticket_services_variant_id_fkey" FOREIGN KEY ("variant_id") REFERENCES "public"."service_variants"("id");



ALTER TABLE ONLY "public"."ticket_stages"
    ADD CONSTRAINT "ticket_stages_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."ticket_timeline"
    ADD CONSTRAINT "ticket_timeline_actor_id_fkey" FOREIGN KEY ("actor_id") REFERENCES "public"."users"("auth_user_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."ticket_timeline"
    ADD CONSTRAINT "ticket_timeline_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ticket_timeline"
    ADD CONSTRAINT "ticket_timeline_ticket_id_fkey" FOREIGN KEY ("ticket_id") REFERENCES "public"."tickets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tickets"
    ADD CONSTRAINT "tickets_assigned_to_fkey" FOREIGN KEY ("assigned_to") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."tickets"
    ADD CONSTRAINT "tickets_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."tickets"
    ADD CONSTRAINT "tickets_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."tickets"
    ADD CONSTRAINT "tickets_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."tickets"
    ADD CONSTRAINT "tickets_stage_id_fkey" FOREIGN KEY ("stage_id") REFERENCES "public"."ticket_stages"("id");



ALTER TABLE ONLY "public"."tickets_tags"
    ADD CONSTRAINT "tickets_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."global_tags"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tickets_tags"
    ADD CONSTRAINT "tickets_tags_ticket_id_fkey" FOREIGN KEY ("ticket_id") REFERENCES "public"."tickets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_preferences"
    ADD CONSTRAINT "user_preferences_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_app_role_id_fkey" FOREIGN KEY ("app_role_id") REFERENCES "public"."app_roles"("id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_auth_user_id_fkey" FOREIGN KEY ("auth_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."verifactu_cert_history"
    ADD CONSTRAINT "verifactu_cert_history_company_fk" FOREIGN KEY ("company_id") REFERENCES "public"."verifactu_settings"("company_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."verifactu_cert_history"
    ADD CONSTRAINT "verifactu_cert_history_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."verifactu_settings"("company_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."verifactu_events"
    ADD CONSTRAINT "verifactu_events_companyid_fkey" FOREIGN KEY ("companyid") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."verifactu_events"
    ADD CONSTRAINT "verifactu_events_invoiceid_fkey" FOREIGN KEY ("invoiceid") REFERENCES "public"."invoices"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."verifactu_settings"
    ADD CONSTRAINT "verifactu_settings_companyid_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."waitlist"
    ADD CONSTRAINT "waitlist_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."waitlist"
    ADD CONSTRAINT "waitlist_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."waitlist"
    ADD CONSTRAINT "waitlist_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."services"("id") ON DELETE CASCADE;



CREATE POLICY "Admins can manage all domains" ON "public"."domains" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['admin'::"text", 'owner'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "Admins can manage assignments" ON "public"."client_variant_assignments" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['admin'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "Admins can manage bookings" ON "public"."bookings" USING ("public"."current_user_is_admin"("company_id")) WITH CHECK ("public"."current_user_is_admin"("company_id"));



CREATE POLICY "Admins can manage company settings" ON "public"."company_settings" USING ((EXISTS ( SELECT 1
   FROM (("public"."users" "u"
     JOIN "public"."company_members" "cm" ON ((("cm"."user_id" = "u"."id") AND ("cm"."company_id" = "company_settings"."company_id"))))
     LEFT JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM (("public"."users" "u"
     JOIN "public"."company_members" "cm" ON ((("cm"."user_id" = "u"."id") AND ("cm"."company_id" = "company_settings"."company_id"))))
     LEFT JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "Admins can manage hidden_units" ON "public"."hidden_units" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['admin'::"text", 'owner'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "Admins can manage own company rooms" ON "public"."rooms" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "rooms"."company_id") AND ("ar"."name" = ANY (ARRAY['admin'::"text", 'owner'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "Admins can manage professional_services" ON "public"."professional_services" USING (("professional_id" IN ( SELECT "professionals"."id"
   FROM "public"."professionals"
  WHERE "public"."current_user_is_admin"("professionals"."company_id")))) WITH CHECK (("professional_id" IN ( SELECT "professionals"."id"
   FROM "public"."professionals"
  WHERE "public"."current_user_is_admin"("professionals"."company_id"))));



CREATE POLICY "Admins can manage professional_services_all" ON "public"."professional_services" USING (("professional_id" IN ( SELECT "professionals"."id"
   FROM "public"."professionals"
  WHERE "public"."current_user_is_admin"("professionals"."company_id")))) WITH CHECK (("professional_id" IN ( SELECT "professionals"."id"
   FROM "public"."professionals"
  WHERE "public"."current_user_is_admin"("professionals"."company_id"))));



CREATE POLICY "Admins can manage professionals" ON "public"."professionals" USING ("public"."current_user_is_admin"("company_id")) WITH CHECK ("public"."current_user_is_admin"("company_id"));



CREATE POLICY "Admins can manage scheduled_notifications" ON "public"."scheduled_notifications" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['admin'::"text", 'owner'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "Admins can manage services" ON "public"."services" USING ("public"."current_user_is_admin"("company_id")) WITH CHECK ("public"."current_user_is_admin"("company_id"));



CREATE POLICY "Admins can manage titles" ON "public"."professional_titles" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members"
  WHERE (("company_members"."user_id" = "auth"."uid"()) AND ("company_members"."company_id" = "professional_titles"."company_id") AND ("company_members"."role_id" IN ( SELECT "app_roles"."id"
           FROM "public"."app_roles"
          WHERE ("app_roles"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text"])))))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."company_members"
  WHERE (("company_members"."user_id" = "auth"."uid"()) AND ("company_members"."company_id" = "professional_titles"."company_id") AND ("company_members"."role_id" IN ( SELECT "app_roles"."id"
           FROM "public"."app_roles"
          WHERE ("app_roles"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text"]))))))));



CREATE POLICY "Allow delete ticket_products by company membership" ON "public"."ticket_products" FOR DELETE USING ("public"."current_user_is_admin"("company_id"));



CREATE POLICY "Allow insert ticket_products by company membership" ON "public"."ticket_products" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "ticket_products"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Allow select ticket_products by company membership" ON "public"."ticket_products" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "ticket_products"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Allow update ticket_products by company membership" ON "public"."ticket_products" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "ticket_products"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Authenticated users can delete files" ON "public"."project_files" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can insert catalog items" ON "public"."product_catalog" FOR INSERT TO "authenticated" WITH CHECK ((("company_id" IS NULL) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Authenticated users can insert files" ON "public"."project_files" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Authenticated users can select files" ON "public"."project_files" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can select hidden_units" ON "public"."hidden_units" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can view all profiles" ON "public"."users" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can view assignments" ON "public"."client_variant_assignments" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authors can update own comments" ON "public"."project_comments" FOR UPDATE USING (("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"())))) WITH CHECK (("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Booking history viewable by company members" ON "public"."booking_history" FOR SELECT USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Clients can add comments on their projects" ON "public"."project_comments" FOR INSERT WITH CHECK (((EXISTS ( SELECT 1
   FROM "public"."projects" "p"
  WHERE (("p"."id" = "project_comments"."project_id") AND ("p"."client_id" IN ( SELECT "clients"."id"
           FROM "public"."clients"
          WHERE ("clients"."auth_user_id" = "auth"."uid"())))))) AND ("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Clients can insert bookings" ON "public"."bookings" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "clients"."company_id"
   FROM "public"."clients"
  WHERE (("clients"."auth_user_id" = "auth"."uid"()) AND ("clients"."is_active" = true)))));



CREATE POLICY "Clients can insert comments" ON "public"."ticket_comments" FOR INSERT WITH CHECK ((("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"()))) AND ("ticket_id" IN ( SELECT "tickets"."id"
   FROM "public"."tickets"
  WHERE ("tickets"."client_id" IN ( SELECT "clients"."id"
           FROM "public"."clients"
          WHERE ("clients"."auth_user_id" = "auth"."uid"())))))));



CREATE POLICY "Clients can join waitlist" ON "public"."waitlist" FOR INSERT WITH CHECK (("auth"."uid"() = "client_id"));



CREATE POLICY "Clients can update own comments" ON "public"."ticket_comments" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."clients"
  WHERE (("clients"."id" = "ticket_comments"."client_id") AND ("clients"."auth_user_id" = "auth"."uid"()))))) WITH CHECK (("is_internal" = false));



CREATE POLICY "Clients can update their own contracts (sign)" ON "public"."contracts" FOR UPDATE USING (("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Clients can view comments on their projects" ON "public"."project_comments" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."projects" "p"
  WHERE (("p"."id" = "project_comments"."project_id") AND ("p"."client_id" IN ( SELECT "clients"."id"
           FROM "public"."clients"
          WHERE ("clients"."auth_user_id" = "auth"."uid"())))))));



CREATE POLICY "Clients can view own invoice items" ON "public"."invoice_items" FOR SELECT TO "authenticated" USING (("invoice_id" IN ( SELECT "i"."id"
   FROM "public"."invoices" "i"
  WHERE ("i"."client_id" IN ( SELECT "c"."id"
           FROM "public"."clients" "c"
          WHERE ("c"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Clients can view own invoices" ON "public"."invoices" FOR SELECT TO "authenticated" USING (("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Clients can view own quote items" ON "public"."quote_items" FOR SELECT TO "authenticated" USING (("quote_id" IN ( SELECT "q"."id"
   FROM "public"."quotes" "q"
  WHERE ("q"."client_id" IN ( SELECT "c"."id"
           FROM "public"."clients" "c"
          WHERE ("c"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Clients can view own quotes" ON "public"."quotes" FOR SELECT TO "authenticated" USING (("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Clients can view own waitlist" ON "public"."waitlist" FOR SELECT USING (("auth"."uid"() = "client_id"));



CREATE POLICY "Clients can view public services" ON "public"."services" FOR SELECT TO "authenticated" USING (("is_public" = true));



CREATE POLICY "Clients can view services they have contracted" ON "public"."services" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM (("public"."quote_items" "qi"
     JOIN "public"."quotes" "q" ON (("q"."id" = "qi"."quote_id")))
     JOIN "public"."clients" "c" ON (("c"."id" = "q"."client_id")))
  WHERE (("qi"."service_id" = "services"."id") AND ("c"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Clients can view their notifications" ON "public"."notifications" FOR SELECT USING (("client_recipient_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Clients can view their own bookings" ON "public"."bookings" FOR SELECT USING ((("customer_email" = ("auth"."jwt"() ->> 'email'::"text")) OR ("company_id" IN ( SELECT "clients"."company_id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Clients can view their own consent records" ON "public"."gdpr_consent_records" FOR SELECT TO "authenticated" USING ((("subject_email" = ("auth"."jwt"() ->> 'email'::"text")) OR ("auth"."uid"() = "processed_by")));



CREATE POLICY "Clients can view their own contracts" ON "public"."contracts" FOR SELECT USING (("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Clients can view their own variant assignments" ON "public"."client_variant_assignments" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."clients" "c"
  WHERE (("c"."id" = "client_variant_assignments"."client_id") AND ("c"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Clients can view their projects" ON "public"."projects" FOR SELECT USING (("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Clients see assigned or public variants" ON "public"."service_variants" FOR SELECT USING ("public"."fn_is_variant_visible"("id"));



CREATE POLICY "Comments delete by author" ON "public"."ticket_comments" FOR DELETE USING ((("user_id" = ( SELECT "auth"."uid"() AS "uid")) AND (EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."auth_user_id" = ( SELECT "auth"."uid"() AS "uid")) AND ("u"."company_id" = "ticket_comments"."company_id") AND ("u"."active" = true))))));



CREATE POLICY "Comments delete by company admins" ON "public"."ticket_comments" FOR DELETE USING ("public"."current_user_is_admin"("company_id"));



CREATE POLICY "Comments insert by company members" ON "public"."ticket_comments" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "ticket_comments"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Comments select by company members" ON "public"."ticket_comments" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "ticket_comments"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Comments selectable by company members" ON "public"."ticket_comments" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."auth_user_id" = ( SELECT "auth"."uid"() AS "uid")) AND ("u"."company_id" = "ticket_comments"."company_id") AND ("u"."active" = true)))));



CREATE POLICY "Comments update by author" ON "public"."ticket_comments" FOR UPDATE USING ((("user_id" = ( SELECT "auth"."uid"() AS "uid")) AND (EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."auth_user_id" = ( SELECT "auth"."uid"() AS "uid")) AND ("u"."company_id" = "ticket_comments"."company_id") AND ("u"."active" = true)))))) WITH CHECK ((("user_id" = ( SELECT "auth"."uid"() AS "uid")) AND ("company_id" = ( SELECT "t"."company_id"
   FROM "public"."tickets" "t"
  WHERE ("t"."id" = "ticket_comments"."ticket_id"))) AND (EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."auth_user_id" = ( SELECT "auth"."uid"() AS "uid")) AND ("u"."company_id" = "ticket_comments"."company_id") AND ("u"."active" = true))))));



CREATE POLICY "Company admins can delete members" ON "public"."company_members" FOR DELETE USING ("public"."current_user_is_admin"("company_id"));



CREATE POLICY "Company admins can update members" ON "public"."company_members" FOR UPDATE USING ("public"."current_user_is_admin"("company_id"));



CREATE POLICY "Company admins can view members" ON "public"."company_members" FOR SELECT USING ("public"."current_user_is_admin"("company_id"));



CREATE POLICY "Company members can add comments" ON "public"."project_comments" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."projects" "p"
  WHERE (("p"."id" = "project_comments"."project_id") AND ("p"."company_id" IN ( SELECT "cm"."company_id"
           FROM "public"."company_members" "cm"
          WHERE ("cm"."user_id" IN ( SELECT "users"."id"
                   FROM "public"."users"
                  WHERE ("users"."auth_user_id" = "auth"."uid"())))))))));



CREATE POLICY "Company members can delete templates" ON "public"."contract_templates" FOR DELETE USING (("auth"."uid"() IN ( SELECT "company_members"."user_id"
   FROM "public"."company_members"
  WHERE ("company_members"."company_id" = "contract_templates"."company_id"))));



CREATE POLICY "Company members can insert templates" ON "public"."contract_templates" FOR INSERT WITH CHECK (("auth"."uid"() IN ( SELECT "company_members"."user_id"
   FROM "public"."company_members"
  WHERE ("company_members"."company_id" = "contract_templates"."company_id"))));



CREATE POLICY "Company members can manage waitlist" ON "public"."waitlist" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members"
  WHERE (("company_members"."company_id" = "waitlist"."company_id") AND ("company_members"."user_id" = "auth"."uid"())))));



CREATE POLICY "Company members can update templates" ON "public"."contract_templates" FOR UPDATE USING (("auth"."uid"() IN ( SELECT "company_members"."user_id"
   FROM "public"."company_members"
  WHERE ("company_members"."company_id" = "contract_templates"."company_id"))));



CREATE POLICY "Company members can update their own company" ON "public"."companies" FOR UPDATE TO "authenticated" USING ("public"."is_company_admin"("id")) WITH CHECK ("public"."is_company_admin"("id"));



CREATE POLICY "Company members can view booking types" ON "public"."booking_types" FOR SELECT USING (("company_id" = ANY ("public"."get_my_company_ids"())));



CREATE POLICY "Company members can view booking_types" ON "public"."booking_types" FOR SELECT USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Company members can view bookings" ON "public"."bookings" FOR SELECT USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Company members can view comments" ON "public"."project_comments" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."projects" "p"
  WHERE (("p"."id" = "project_comments"."project_id") AND ("p"."company_id" IN ( SELECT "cm"."company_id"
           FROM "public"."company_members" "cm"
          WHERE ("cm"."user_id" IN ( SELECT "users"."id"
                   FROM "public"."users"
                  WHERE ("users"."auth_user_id" = "auth"."uid"())))))))));



CREATE POLICY "Company members can view invitations" ON "public"."company_invitations" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."company_id" = "company_invitations"."company_id") AND ("cm"."user_id" = "auth"."uid"())))) OR ("lower"("email") = "lower"(("auth"."jwt"() ->> 'email'::"text")))));



CREATE POLICY "Company members can view professional_services" ON "public"."professional_services" FOR SELECT USING (("professional_id" IN ( SELECT "professionals"."id"
   FROM "public"."professionals"
  WHERE ("professionals"."company_id" IN ( SELECT "cm"."company_id"
           FROM ("public"."company_members" "cm"
             JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
          WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))))));



CREATE POLICY "Company members can view professionals" ON "public"."professionals" FOR SELECT USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Company members can view resources" ON "public"."resources" FOR SELECT USING (("company_id" = ANY ("public"."get_my_company_ids"())));



CREATE POLICY "Company members can view services" ON "public"."services" FOR SELECT USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Company members can view templates" ON "public"."contract_templates" FOR SELECT USING (("auth"."uid"() IN ( SELECT "company_members"."user_id"
   FROM "public"."company_members"
  WHERE ("company_members"."company_id" = "contract_templates"."company_id"))));



CREATE POLICY "Company members can view titles" ON "public"."professional_titles" FOR SELECT TO "authenticated" USING (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" = "auth"."uid"()))));



CREATE POLICY "Company members can view waitlist" ON "public"."waitlist" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."company_members"
  WHERE (("company_members"."company_id" = "waitlist"."company_id") AND ("company_members"."user_id" = "auth"."uid"())))));



CREATE POLICY "Company users can insert contracts" ON "public"."contracts" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Company users can manage client variant assignments" ON "public"."client_variant_assignments" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."clients" "c"
     JOIN "public"."users" "u" ON (("u"."company_id" = "c"."company_id")))
  WHERE (("c"."id" = "client_variant_assignments"."client_id") AND ("u"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Company users can manage their variants" ON "public"."service_variants" USING ((EXISTS ( SELECT 1
   FROM ("public"."services" "s"
     JOIN "public"."users" "u" ON (("u"."company_id" = "s"."company_id")))
  WHERE (("s"."id" = "service_variants"."service_id") AND ("u"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Company users can view client variant assignments" ON "public"."client_variant_assignments" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."clients" "c"
     JOIN "public"."users" "u" ON (("u"."company_id" = "c"."company_id")))
  WHERE (("c"."id" = "client_variant_assignments"."client_id") AND ("u"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Company users can view their variants" ON "public"."service_variants" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."services" "s"
     JOIN "public"."users" "u" ON (("u"."company_id" = "s"."company_id")))
  WHERE (("s"."id" = "service_variants"."service_id") AND ("u"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Edit own documents" ON "public"."professional_documents" USING ((("professional_id" IN ( SELECT "professionals"."id"
   FROM "public"."professionals"
  WHERE ("professionals"."user_id" = "auth"."uid"()))) OR (EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])))))));



CREATE POLICY "Edit own schedules" ON "public"."professional_schedules" USING ((("professional_id" IN ( SELECT "professionals"."id"
   FROM "public"."professionals"
  WHERE ("professionals"."user_id" = "auth"."uid"()))) OR (EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])))))));



CREATE POLICY "Employees can view own commission configs" ON "public"."employee_commissions_config" FOR SELECT USING (("employee_id" IN ( SELECT "employees"."id"
   FROM "public"."employees"
  WHERE ("employees"."user_id" = "auth"."uid"()))));



CREATE POLICY "Employees can view own productivity logs" ON "public"."employee_productivity_logs" FOR SELECT USING (("employee_id" IN ( SELECT "employees"."id"
   FROM "public"."employees"
  WHERE ("employees"."user_id" = "auth"."uid"()))));



CREATE POLICY "Employees view marketing metrics" ON "public"."marketing_metrics" FOR SELECT USING (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" = "auth"."uid"()))));



CREATE POLICY "Employees view social metrics" ON "public"."social_metrics" FOR SELECT USING (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" = "auth"."uid"()))));



CREATE POLICY "Enable all access for company members" ON "public"."client_contacts" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."clients"
  WHERE (("clients"."id" = "client_contacts"."client_id") AND ("clients"."company_id" IN ( SELECT "company_members"."company_id"
           FROM "public"."company_members"
          WHERE ("company_members"."user_id" = "auth"."uid"())))))));



CREATE POLICY "Enable all access for company members" ON "public"."coupons" USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Enable all for company members" ON "public"."marketing_logs" USING (("campaign_id" IN ( SELECT "marketing_campaigns"."id"
   FROM "public"."marketing_campaigns"
  WHERE ("marketing_campaigns"."company_id" IN ( SELECT "cm"."company_id"
           FROM ("public"."company_members" "cm"
             JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
          WHERE ("u"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Enable delete access for company members" ON "public"."client_documents" FOR DELETE USING (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" = "public"."get_my_public_id"()))));



CREATE POLICY "Enable delete access for company users" ON "public"."content_posts" FOR DELETE USING (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" IN ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Enable insert access for company members" ON "public"."client_documents" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" = "public"."get_my_public_id"()))));



CREATE POLICY "Enable insert access for company members" ON "public"."loyalty_points" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "loyalty_points"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Enable insert access for company users" ON "public"."content_posts" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" IN ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Enable insert for authenticated users within company" ON "public"."client_contacts" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."clients"
  WHERE (("clients"."id" = "client_contacts"."client_id") AND ("clients"."company_id" IN ( SELECT "company_members"."company_id"
           FROM "public"."company_members"
          WHERE ("company_members"."user_id" = "auth"."uid"())))))));



CREATE POLICY "Enable insert for company members" ON "public"."product_models" FOR INSERT WITH CHECK ((("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



CREATE POLICY "Enable read access for authenticated users" ON "public"."coupons" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Enable read access for clients" ON "public"."loyalty_points" FOR SELECT USING (("auth"."uid"() IN ( SELECT "clients"."auth_user_id"
   FROM "public"."clients"
  WHERE ("clients"."id" = "loyalty_points"."customer_id"))));



CREATE POLICY "Enable read access for company members" ON "public"."client_documents" FOR SELECT USING (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" = "public"."get_my_public_id"()))));



CREATE POLICY "Enable read access for company members" ON "public"."devices" FOR SELECT TO "authenticated" USING ("public"."is_company_member"("company_id"));



CREATE POLICY "Enable read access for company members" ON "public"."lead_sources" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE (("cm"."company_id" = "lead_sources"."company_id") AND ("u"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Enable read access for company members" ON "public"."loyalty_points" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "loyalty_points"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Enable read access for company members" ON "public"."notification_logs" FOR SELECT USING (("auth"."uid"() IN ( SELECT "company_members"."user_id"
   FROM "public"."company_members"
  WHERE ("company_members"."company_id" = "notification_logs"."company_id"))));



CREATE POLICY "Enable read access for company members" ON "public"."notification_templates" FOR SELECT USING (("auth"."uid"() IN ( SELECT "company_members"."user_id"
   FROM "public"."company_members"
  WHERE ("company_members"."company_id" = "notification_templates"."company_id"))));



CREATE POLICY "Enable read access for company members" ON "public"."ticket_comments" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."tickets" "t"
  WHERE (("t"."id" = "ticket_comments"."ticket_id") AND "public"."is_company_member"("t"."company_id")))));



CREATE POLICY "Enable read access for company members" ON "public"."ticket_devices" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."tickets" "t"
  WHERE (("t"."id" = "ticket_devices"."ticket_id") AND "public"."is_company_member"("t"."company_id")))));



CREATE POLICY "Enable read access for company members" ON "public"."ticket_services" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."tickets" "t"
  WHERE (("t"."id" = "ticket_services"."ticket_id") AND ("public"."is_company_member"("t"."company_id") OR ("auth"."uid"() = ( SELECT "users"."auth_user_id"
           FROM "public"."users"
          WHERE ("users"."id" = "t"."created_by"))))))));



CREATE POLICY "Enable read access for company users" ON "public"."content_posts" FOR SELECT USING (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" IN ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Enable read for company members" ON "public"."product_models" FOR SELECT USING ((("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



CREATE POLICY "Enable update access for company users" ON "public"."content_posts" FOR UPDATE USING (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" IN ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Enable update for company members" ON "public"."product_models" FOR UPDATE USING ((("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



CREATE POLICY "Interactions insertable by company members" ON "public"."lead_interactions" FOR INSERT WITH CHECK (("lead_id" IN ( SELECT "leads"."id"
   FROM "public"."leads"
  WHERE ("leads"."company_id" IN ( SELECT "company_members"."company_id"
           FROM "public"."company_members"
          WHERE ("company_members"."user_id" = "auth"."uid"()))))));



CREATE POLICY "Interactions viewable by company members" ON "public"."lead_interactions" FOR SELECT USING (("lead_id" IN ( SELECT "leads"."id"
   FROM "public"."leads"
  WHERE ("leads"."company_id" IN ( SELECT "company_members"."company_id"
           FROM "public"."company_members"
          WHERE ("company_members"."user_id" = "auth"."uid"()))))));



CREATE POLICY "Leads are editable by company members" ON "public"."leads" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE (("cm"."company_id" = "leads"."company_id") AND ("u"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Leads are inserted by company members or service role" ON "public"."leads" FOR INSERT WITH CHECK (((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE (("cm"."company_id" = "leads"."company_id") AND ("u"."auth_user_id" = "auth"."uid"())))) OR ("auth"."role"() = 'service_role'::"text")));



CREATE POLICY "Leads are viewable by company members" ON "public"."leads" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE (("cm"."company_id" = "leads"."company_id") AND ("u"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Manage assignments" ON "public"."client_assignments" USING ((EXISTS ( SELECT 1
   FROM (("public"."company_members" "requester"
     JOIN "public"."app_roles" "ar" ON (("requester"."role_id" = "ar"."id")))
     JOIN "public"."company_members" "target_member" ON (("target_member"."id" = "client_assignments"."company_member_id")))
  WHERE (("requester"."user_id" = "auth"."uid"()) AND ("requester"."company_id" = "target_member"."company_id") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) AND ("requester"."status" = 'active'::"text")))));



CREATE POLICY "Members can view company permissions" ON "public"."role_permissions" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."company_id" = "role_permissions"."company_id") AND ("cm"."user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Members can view their companies" ON "public"."companies" FOR SELECT USING ("public"."is_company_member"("id"));



CREATE POLICY "Professionals can manage own exceptions" ON "public"."availability_exceptions" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Public can read exceptions" ON "public"."availability_exceptions" FOR SELECT USING (true);



CREATE POLICY "Public can read invitation by token" ON "public"."company_invitations" FOR SELECT TO "authenticated", "anon" USING (true);



CREATE POLICY "Roles are viewable by authenticated users" ON "public"."app_roles" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Service role can insert invitations" ON "public"."company_invitations" FOR INSERT TO "service_role" WITH CHECK (true);



CREATE POLICY "Service role can update invitations" ON "public"."company_invitations" FOR UPDATE TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Staff can moderate (update) any comment in company" ON "public"."ticket_comments" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."users"
  WHERE (("users"."auth_user_id" = "auth"."uid"()) AND ("users"."company_id" = "ticket_comments"."company_id") AND ("users"."active" = true)))));



CREATE POLICY "Staff can update own comments" ON "public"."ticket_comments" FOR UPDATE USING ((("user_id" = "auth"."uid"()) OR (("user_id" IS NULL) AND (EXISTS ( SELECT 1
   FROM "public"."users"
  WHERE (("users"."auth_user_id" = "auth"."uid"()) AND ("users"."company_id" = "ticket_comments"."company_id"))))))) WITH CHECK ((("user_id" = "auth"."uid"()) OR (("user_id" IS NULL) AND (EXISTS ( SELECT 1
   FROM "public"."users"
  WHERE (("users"."auth_user_id" = "auth"."uid"()) AND ("users"."company_id" = "ticket_comments"."company_id")))))));



CREATE POLICY "Staff can view comment versions" ON "public"."ticket_comment_versions" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."ticket_comments" "tc"
     JOIN "public"."users" "u" ON (("u"."company_id" = "tc"."company_id")))
  WHERE (("tc"."id" = "ticket_comment_versions"."comment_id") AND ("u"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Super Admins can manage company_modules" ON "public"."company_modules" TO "authenticated" USING ("public"."is_super_admin"("auth"."uid"())) WITH CHECK ("public"."is_super_admin"("auth"."uid"()));



CREATE POLICY "Super Admins can view ALL audit logs" ON "public"."audit_logs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = 'super_admin'::"text")))));



CREATE POLICY "Superadmins can view all companies" ON "public"."companies" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."users"
  WHERE (("users"."auth_user_id" = "auth"."uid"()) AND ("users"."app_role_id" = '193d8af6-e24e-47ff-944a-bb8176a412ab'::"uuid")))));



CREATE POLICY "Users can accept their own invitation" ON "public"."company_invitations" FOR UPDATE TO "authenticated" USING ((("lower"("email") = "lower"((("current_setting"('request.jwt.claims'::"text", true))::"jsonb" ->> 'email'::"text"))) AND ("status" = 'pending'::"text"))) WITH CHECK (("status" = ANY (ARRAY['accepted'::"text", 'rejected'::"text"])));



CREATE POLICY "Users can access products for their company" ON "public"."products" USING ((("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))))) WITH CHECK ((("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



CREATE POLICY "Users can create brands for their company" ON "public"."product_brands" FOR INSERT WITH CHECK ((("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



CREATE POLICY "Users can create categories for their company" ON "public"."product_categories" FOR INSERT WITH CHECK ((("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



CREATE POLICY "Users can create mail accounts" ON "public"."mail_accounts" FOR INSERT WITH CHECK (("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can create stock movements for their company" ON "public"."stock_movements" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can delete company stages" ON "public"."ticket_stages" FOR DELETE USING (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



CREATE POLICY "Users can delete their company catalog items" ON "public"."product_catalog" FOR DELETE TO "authenticated" USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can hide generic stages for their company" ON "public"."hidden_stages" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



COMMENT ON POLICY "Users can hide generic stages for their company" ON "public"."hidden_stages" IS 'Permite a usuarios insertar registros de estados ocultos. La validación de que el stage sea genérico se hace en la Edge Function hide-stage.';



CREATE POLICY "Users can insert comments for their company" ON "public"."ticket_comments" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can insert company stages" ON "public"."ticket_stages" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



CREATE POLICY "Users can insert their own AI logs" ON "public"."ai_usage_logs" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR ("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"())))));



CREATE POLICY "Users can insert their own notification preferences" ON "public"."project_notification_preferences" FOR INSERT WITH CHECK ((("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))) OR ("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Users can insert their own preferences" ON "public"."user_preferences" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert versions" ON "public"."ticket_comment_versions" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."ticket_comments" "tc"
  WHERE ("tc"."id" = "ticket_comment_versions"."comment_id"))));



CREATE POLICY "Users can manage contacts of their clients" ON "public"."client_contacts" USING (("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."company_id" = ( SELECT "users"."company_id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Users can manage own integrations" ON "public"."integrations" USING (("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can manage their company supplier products" ON "public"."supplier_products" USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"())))) WITH CHECK (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can manage their company suppliers" ON "public"."suppliers" USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"())))) WITH CHECK (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can manage their own calendar config" ON "public"."google_calendar_configs" TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can manage their own mail accounts" ON "public"."mail_accounts" USING (("auth"."uid"() IN ( SELECT "users"."auth_user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "mail_accounts"."user_id"))));



CREATE POLICY "Users can manage their own mail contacts" ON "public"."mail_contacts" USING (("auth"."uid"() IN ( SELECT "users"."auth_user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "mail_contacts"."user_id"))));



CREATE POLICY "Users can manage their own mail folders" ON "public"."mail_folders" USING (("account_id" IN ( SELECT "mail_accounts"."id"
   FROM "public"."mail_accounts"
  WHERE ("mail_accounts"."user_id" IN ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Users can manage their own mail messages" ON "public"."mail_messages" USING (("account_id" IN ( SELECT "mail_accounts"."id"
   FROM "public"."mail_accounts"
  WHERE ("mail_accounts"."user_id" IN ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Users can manage their own mail threads" ON "public"."mail_threads" USING (("account_id" IN ( SELECT "mail_accounts"."id"
   FROM "public"."mail_accounts"
  WHERE ("mail_accounts"."user_id" IN ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Users can manage their own notification preferences" ON "public"."project_notification_preferences" USING ((("auth"."uid"() = "user_id") OR ("auth"."uid"() = ( SELECT "clients"."auth_user_id"
   FROM "public"."clients"
  WHERE ("clients"."id" = "project_notification_preferences"."client_id")))));



CREATE POLICY "Users can manage their own read status" ON "public"."project_reads" USING ((("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))) OR ("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"()))))) WITH CHECK ((("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))) OR ("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Users can unhide generic stages for their company" ON "public"."hidden_stages" FOR DELETE USING (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



COMMENT ON POLICY "Users can unhide generic stages for their company" ON "public"."hidden_stages" IS 'Permite a usuarios eliminar registros de estados ocultos. La Edge Function hide-stage maneja la lógica de negocio.';



CREATE POLICY "Users can update company stages" ON "public"."ticket_stages" FOR UPDATE USING (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"())))) WITH CHECK (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



CREATE POLICY "Users can update notifications" ON "public"."notifications" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() IN ( SELECT "users"."auth_user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "notifications"."recipient_id"))) OR (("recipient_id" IS NULL) AND ("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE (("company_members"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("company_members"."status" = 'active'::"text")))) AND "public"."auth_has_permission"('notifications.view'::"text", "company_id"))));



CREATE POLICY "Users can update own profile" ON "public"."users" FOR UPDATE USING (("auth_user_id" = "auth"."uid"()));



CREATE POLICY "Users can update their company brands" ON "public"."product_brands" FOR UPDATE USING ((("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



CREATE POLICY "Users can update their company catalog items" ON "public"."product_catalog" FOR UPDATE TO "authenticated" USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can update their company categories" ON "public"."product_categories" FOR UPDATE USING ((("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



CREATE POLICY "Users can update their own notification preferences" ON "public"."project_notification_preferences" FOR UPDATE USING ((("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))) OR ("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Users can update their own preferences" ON "public"."user_preferences" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view accessible brands" ON "public"."product_brands" FOR SELECT USING ((("company_id" IS NULL) OR ("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



CREATE POLICY "Users can view accessible categories" ON "public"."product_categories" FOR SELECT USING ((("company_id" IS NULL) OR ("company_id" = "public"."get_user_company_id"()) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



CREATE POLICY "Users can view attachments of their messages" ON "public"."mail_attachments" FOR SELECT USING (("message_id" IN ( SELECT "mail_messages"."id"
   FROM "public"."mail_messages"
  WHERE ("mail_messages"."account_id" IN ( SELECT "mail_accounts"."id"
           FROM "public"."mail_accounts"
          WHERE ("mail_accounts"."user_id" IN ( SELECT "users"."id"
                   FROM "public"."users"
                  WHERE ("users"."auth_user_id" = "auth"."uid"()))))))));



CREATE POLICY "Users can view catalog items" ON "public"."product_catalog" FOR SELECT TO "authenticated" USING ((("company_id" IS NULL) OR ("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Users can view comments for their company" ON "public"."ticket_comments" FOR SELECT USING (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can view company domains" ON "public"."domains" FOR SELECT USING (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" = "auth"."uid"()))));



CREATE POLICY "Users can view company settings" ON "public"."company_settings" FOR SELECT USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "Users can view contacts of their clients" ON "public"."client_contacts" FOR SELECT USING (("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."company_id" = ( SELECT "users"."company_id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Users can view contracts for their company" ON "public"."contracts" FOR SELECT USING (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can view generic or company stages" ON "public"."ticket_stages" FOR SELECT USING ((("company_id" IS NULL) OR ("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"())))));



CREATE POLICY "Users can view integrations of their company" ON "public"."integrations" FOR SELECT USING (("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))))));



CREATE POLICY "Users can view invitations sent to their email" ON "public"."company_invitations" FOR SELECT TO "authenticated" USING (("lower"("email") = "lower"(("auth"."jwt"() ->> 'email'::"text"))));



CREATE POLICY "Users can view logs for their company" ON "public"."ai_usage_logs" FOR SELECT TO "authenticated" USING (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



CREATE POLICY "Users can view notifications" ON "public"."notifications" FOR SELECT TO "authenticated" USING ((("auth"."uid"() IN ( SELECT "users"."auth_user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "notifications"."recipient_id"))) OR (("recipient_id" IS NULL) AND ("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE (("company_members"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("company_members"."status" = 'active'::"text")))) AND "public"."auth_has_permission"('notifications.view'::"text", "company_id"))));



CREATE POLICY "Users can view own company rooms" ON "public"."rooms" FOR SELECT TO "authenticated" USING (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can view own memberships" ON "public"."company_members" FOR SELECT USING (("user_id" = "public"."get_my_public_id"()));



CREATE POLICY "Users can view own pending registrations" ON "public"."pending_users" FOR SELECT USING ((( SELECT "auth"."uid"() AS "uid") = "auth_user_id"));



CREATE POLICY "Users can view their company hidden stages" ON "public"."hidden_stages" FOR SELECT USING (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



CREATE POLICY "Users can view their company stock movements" ON "public"."stock_movements" FOR SELECT USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "Users can view their own company modules" ON "public"."company_modules" FOR SELECT TO "authenticated" USING ((("company_id" = ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))) OR "public"."is_super_admin"("auth"."uid"())));



CREATE POLICY "Users can view their own notification preferences" ON "public"."project_notification_preferences" FOR SELECT USING ((("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))) OR ("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."auth_user_id" = "auth"."uid"())))));



CREATE POLICY "Users can view their own preferences" ON "public"."user_preferences" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "View assignments" ON "public"."client_assignments" FOR SELECT USING ((("company_member_id" IN ( SELECT "company_members"."id"
   FROM "public"."company_members"
  WHERE ("company_members"."user_id" = "auth"."uid"()))) OR (EXISTS ( SELECT 1
   FROM (("public"."company_members" "requester"
     JOIN "public"."app_roles" "ar" ON (("requester"."role_id" = "ar"."id")))
     JOIN "public"."company_members" "target_member" ON (("target_member"."id" = "client_assignments"."company_member_id")))
  WHERE (("requester"."user_id" = "auth"."uid"()) AND ("requester"."company_id" = "target_member"."company_id") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])))))));



CREATE POLICY "View own documents" ON "public"."professional_documents" FOR SELECT USING ((("professional_id" IN ( SELECT "professionals"."id"
   FROM "public"."professionals"
  WHERE ("professionals"."user_id" = "auth"."uid"()))) OR (EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])))))));



CREATE POLICY "View own schedules" ON "public"."professional_schedules" FOR SELECT USING ((("professional_id" IN ( SELECT "professionals"."id"
   FROM "public"."professionals"
  WHERE ("professionals"."user_id" = "auth"."uid"()))) OR (EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])))))));



CREATE POLICY "View project permissions" ON "public"."project_permissions" FOR SELECT USING (("project_id" IN ( SELECT "projects"."id"
   FROM "public"."projects")));



ALTER TABLE "public"."addresses" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "addresses_delete_company_only" ON "public"."addresses" FOR DELETE USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "addresses_insert_company_only" ON "public"."addresses" FOR INSERT WITH CHECK (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "addresses_select_company_only" ON "public"."addresses" FOR SELECT USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "addresses_update_company_only" ON "public"."addresses" FOR UPDATE USING (("company_id" = "public"."get_user_company_id"())) WITH CHECK (("company_id" = "public"."get_user_company_id"()));



ALTER TABLE "public"."ai_usage_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."app_roles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."app_settings" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "app_settings_insert" ON "public"."app_settings" FOR INSERT WITH CHECK (("auth"."uid"() IS NOT NULL));



CREATE POLICY "app_settings_read_authenticated" ON "public"."app_settings" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "app_settings_update" ON "public"."app_settings" FOR UPDATE USING (("auth"."uid"() IS NOT NULL)) WITH CHECK (("auth"."uid"() IS NOT NULL));



CREATE POLICY "app_settings_write" ON "public"."app_settings" USING ((("auth"."role"() = 'service_role'::"text") OR (EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['admin'::"text", 'owner'::"text", 'super_admin'::"text"]))))))) WITH CHECK ((("auth"."role"() = 'service_role'::"text") OR (EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['admin'::"text", 'owner'::"text", 'super_admin'::"text"])))))));



ALTER TABLE "public"."attachments" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "attachments_company_access" ON "public"."attachments" USING ((("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = ( SELECT "auth"."uid"() AS "uid")))) AND ("deleted_at" IS NULL)));



ALTER TABLE "public"."audit_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."availability_exceptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."availability_schedules" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "availability_schedules_admin_policy" ON "public"."availability_schedules" USING (("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE (("users"."company_id" = ANY ("public"."get_my_company_ids"())) AND "public"."current_user_is_admin"("users"."company_id"))))) WITH CHECK (("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE (("users"."company_id" = ANY ("public"."get_my_company_ids"())) AND "public"."current_user_is_admin"("users"."company_id")))));



CREATE POLICY "availability_schedules_owner_isolation" ON "public"."availability_schedules" USING (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."booking_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."booking_types" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bookings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_assignments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_clinical_notes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_contacts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_documents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_notes" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "client_notes_insert_policy" ON "public"."client_notes" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "client_notes"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "client_notes_modify_policy" ON "public"."client_notes" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "client_notes"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "client_notes_select_policy" ON "public"."client_notes" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "client_notes"."company_id") AND ("cm"."status" = 'active'::"text")))));



ALTER TABLE "public"."client_portal_users" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_variant_assignments" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "client_view_timeline" ON "public"."ticket_timeline" FOR SELECT TO "authenticated" USING ((("is_public" = true) AND (EXISTS ( SELECT 1
   FROM ("public"."tickets" "t"
     JOIN "public"."clients" "c" ON (("t"."client_id" = "c"."id")))
  WHERE (("t"."id" = "ticket_timeline"."ticket_id") AND ("c"."auth_user_id" = "auth"."uid"()))))));



ALTER TABLE "public"."clients" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "clients_can_update_own_quotes_status" ON "public"."quotes" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."clients" "c"
  WHERE (("c"."id" = "quotes"."client_id") AND ("c"."auth_user_id" = "auth"."uid"()) AND ("c"."is_active" = true))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."clients" "c"
  WHERE (("c"."id" = "quotes"."client_id") AND ("c"."auth_user_id" = "auth"."uid"()) AND ("c"."is_active" = true)))));



COMMENT ON POLICY "clients_can_update_own_quotes_status" ON "public"."quotes" IS 'Permite a clientes del portal aceptar/rechazar sus presupuestos';



CREATE POLICY "clients_can_view_own_invoice_items" ON "public"."invoice_items" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."invoices" "i"
     JOIN "public"."clients" "c" ON (("c"."id" = "i"."client_id")))
  WHERE (("i"."id" = "invoice_items"."invoice_id") AND ("c"."auth_user_id" = "auth"."uid"()) AND ("c"."is_active" = true)))));



CREATE POLICY "clients_can_view_own_invoices" ON "public"."invoices" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."clients" "c"
  WHERE (("c"."id" = "invoices"."client_id") AND ("c"."auth_user_id" = "auth"."uid"()) AND ("c"."is_active" = true)))));



COMMENT ON POLICY "clients_can_view_own_invoices" ON "public"."invoices" IS 'Permite a clientes del portal ver solo sus propias facturas';



CREATE POLICY "clients_can_view_own_quote_items" ON "public"."quote_items" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."quotes" "q"
     JOIN "public"."clients" "c" ON (("c"."id" = "q"."client_id")))
  WHERE (("q"."id" = "quote_items"."quote_id") AND ("c"."auth_user_id" = "auth"."uid"()) AND ("c"."is_active" = true)))));



CREATE POLICY "clients_can_view_own_quotes" ON "public"."quotes" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."clients" "c"
  WHERE (("c"."id" = "quotes"."client_id") AND ("c"."auth_user_id" = "auth"."uid"()) AND ("c"."is_active" = true)))));



COMMENT ON POLICY "clients_can_view_own_quotes" ON "public"."quotes" IS 'Permite a clientes del portal ver solo sus propios presupuestos';



CREATE POLICY "clients_can_view_own_ticket_comments" ON "public"."ticket_comments" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM ("public"."tickets" "t"
     JOIN "public"."clients" "c" ON (("c"."id" = "t"."client_id")))
  WHERE (("t"."id" = "ticket_comments"."ticket_id") AND ("c"."auth_user_id" = "auth"."uid"()) AND ("c"."is_active" = true)))) AND ("is_internal" = false)));



CREATE POLICY "clients_can_view_own_tickets" ON "public"."tickets" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."clients" "c"
  WHERE (("c"."id" = "tickets"."client_id") AND ("c"."auth_user_id" = "auth"."uid"()) AND ("c"."is_active" = true)))));



COMMENT ON POLICY "clients_can_view_own_tickets" ON "public"."tickets" IS 'Permite a clientes del portal ver solo sus propios tickets';



CREATE POLICY "clients_can_view_ticket_stages" ON "public"."ticket_stages" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."clients" "c"
  WHERE (("c"."auth_user_id" = "auth"."uid"()) AND ("c"."company_id" = "ticket_stages"."company_id") AND ("c"."is_active" = true)))));



CREATE POLICY "clients_delete_policy" ON "public"."clients" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."user_id" = "auth"."uid"()) AND ("cm"."company_id" = "clients"."company_id") AND ("cm"."status" = 'active'::"text") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "clients_insert_policy" ON "public"."clients" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "clients"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "clients_select_own_record" ON "public"."clients" FOR SELECT USING (("auth_user_id" = "auth"."uid"()));



CREATE POLICY "clients_select_policy" ON "public"."clients" FOR SELECT USING ((("auth_user_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."user_id" = "auth"."uid"()) AND ("cm"."company_id" = "clients"."company_id") AND ("cm"."status" = 'active'::"text") AND (("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) OR (EXISTS ( SELECT 1
           FROM "public"."client_assignments" "ca"
          WHERE (("ca"."client_id" = "clients"."id") AND ("ca"."company_member_id" = "cm"."id"))))))))));



ALTER TABLE "public"."clients_tags" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "clients_tags_policy" ON "public"."clients_tags" USING (("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"))) WITH CHECK (("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients")));



CREATE POLICY "clients_update_own_record" ON "public"."clients" FOR UPDATE USING (("auth_user_id" = "auth"."uid"())) WITH CHECK (("auth_user_id" = "auth"."uid"()));



CREATE POLICY "clients_update_policy" ON "public"."clients" FOR UPDATE USING ((("auth_user_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."user_id" = "auth"."uid"()) AND ("cm"."company_id" = "clients"."company_id") AND ("cm"."status" = 'active'::"text") AND (("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) OR (EXISTS ( SELECT 1
           FROM "public"."client_assignments" "ca"
          WHERE (("ca"."client_id" = "clients"."id") AND ("ca"."company_member_id" = "cm"."id"))))))))));



CREATE POLICY "clients_view_company_payment_integrations" ON "public"."payment_integrations" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."clients" "c"
  WHERE (("c"."auth_user_id" = "auth"."uid"()) AND ("c"."company_id" = "payment_integrations"."company_id") AND ("c"."is_active" = true)))));



CREATE POLICY "clinical_notes_delete_policy" ON "public"."client_clinical_notes" FOR DELETE USING ((("created_by" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM (("public"."clients" "c"
     JOIN "public"."company_members" "cm" ON (("c"."company_id" = "cm"."company_id")))
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("c"."id" = "client_clinical_notes"."client_id") AND ("cm"."user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text"])))))));



CREATE POLICY "clinical_notes_insert_policy" ON "public"."client_clinical_notes" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."clients" "c"
     JOIN "public"."company_members" "cm" ON (("c"."company_id" = "cm"."company_id")))
  WHERE (("c"."id" = "client_clinical_notes"."client_id") AND ("cm"."user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "clinical_notes_select_policy" ON "public"."client_clinical_notes" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."clients" "c"
     JOIN "public"."company_members" "cm" ON (("c"."company_id" = "cm"."company_id")))
  WHERE (("c"."id" = "client_clinical_notes"."client_id") AND ("cm"."user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "clinical_notes_update_policy" ON "public"."client_clinical_notes" FOR UPDATE USING ((("created_by" = "auth"."uid"()) AND (EXISTS ( SELECT 1
   FROM ("public"."clients" "c"
     JOIN "public"."company_members" "cm" ON (("c"."company_id" = "cm"."company_id")))
  WHERE (("c"."id" = "client_clinical_notes"."client_id") AND ("cm"."user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))));



ALTER TABLE "public"."companies" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "companies_client_access" ON "public"."companies" FOR SELECT USING ("public"."client_can_access_company"("id"));



ALTER TABLE "public"."company_invitations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."company_members" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."company_modules" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."company_settings" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "company_settings_write" ON "public"."company_settings" TO "authenticated" USING ("public"."is_company_admin"("company_id")) WITH CHECK ("public"."is_company_admin"("company_id"));



ALTER TABLE "public"."company_stage_order" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."company_ticket_sequences" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."content_posts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contract_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contracts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."coupons" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "cpu_delete" ON "public"."client_portal_users" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "client_portal_users"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "cpu_insert" ON "public"."client_portal_users" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "client_portal_users"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "cpu_select" ON "public"."client_portal_users" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "client_portal_users"."company_id") AND ("cm"."status" = 'active'::"text")))) OR ("lower"("email") = "lower"((("current_setting"('request.jwt.claims'::"text", true))::"jsonb" ->> 'email'::"text")))));



CREATE POLICY "cpu_update" ON "public"."client_portal_users" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "client_portal_users"."company_id") AND ("cm"."status" = 'active'::"text"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "client_portal_users"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "delete_own_file" ON "public"."project_files" FOR DELETE USING (("created_by" = "auth"."uid"()));



ALTER TABLE "public"."device_components" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "device_components_via_device" ON "public"."device_components" USING ((EXISTS ( SELECT 1
   FROM "public"."devices" "d"
  WHERE (("d"."id" = "device_components"."device_id") AND ("d"."company_id" = "public"."get_user_company_id"())))));



ALTER TABLE "public"."device_media" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "device_media_via_device" ON "public"."device_media" USING ((EXISTS ( SELECT 1
   FROM "public"."devices" "d"
  WHERE (("d"."id" = "device_media"."device_id") AND ("d"."company_id" = "public"."get_user_company_id"())))));



ALTER TABLE "public"."device_status_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "device_status_history_via_device" ON "public"."device_status_history" USING ((EXISTS ( SELECT 1
   FROM "public"."devices" "d"
  WHERE (("d"."id" = "device_status_history"."device_id") AND ("d"."company_id" = "public"."get_user_company_id"())))));



ALTER TABLE "public"."devices" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "devices_company_only" ON "public"."devices" USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "devices_gdpr_company_access" ON "public"."devices" FOR SELECT USING ((("company_id" IN ( SELECT "u"."company_id"
   FROM "public"."users" "u"
  WHERE ("u"."auth_user_id" = ( SELECT "auth"."uid"() AS "uid")))) AND (NOT ("client_id" IN ( SELECT "clients"."id"
   FROM "public"."clients"
  WHERE ("clients"."anonymized_at" IS NOT NULL))))));



ALTER TABLE "public"."domains" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."employee_commissions_config" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "employee_docs_own_read" ON "public"."employee_documents" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."employees" "e"
  WHERE (("e"."id" = "employee_documents"."employee_id") AND ("e"."user_id" = "auth"."uid"())))));



ALTER TABLE "public"."employee_documents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."employee_productivity_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."employees" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "employees_select_policy_licensed" ON "public"."employees" FOR SELECT TO "authenticated" USING ((("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE (("company_members"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("company_members"."status" = 'active'::"text")))) AND "public"."company_has_module"("company_id", 'hr'::"text")));



CREATE POLICY "gcr_company_policy" ON "public"."gdpr_consent_requests" FOR SELECT USING (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = ( SELECT "auth"."uid"() AS "uid")))));



ALTER TABLE "public"."gdpr_access_requests" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "gdpr_access_requests_company" ON "public"."gdpr_access_requests" USING (("company_id" IN ( SELECT "users"."company_id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = ( SELECT "auth"."uid"() AS "uid")))));



CREATE POLICY "gdpr_access_requests_company_only" ON "public"."gdpr_access_requests" USING (("company_id" = "public"."get_user_company_id"()));



ALTER TABLE "public"."gdpr_audit_log" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "gdpr_audit_log_admin_access" ON "public"."gdpr_audit_log" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND (("u"."is_dpo" = true) OR ("ar"."name" = ANY (ARRAY['admin'::"text", 'super_admin'::"text", 'owner'::"text"])))))));



ALTER TABLE "public"."gdpr_breach_incidents" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "gdpr_breach_incidents_dpo_admin" ON "public"."gdpr_breach_incidents" USING ((EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."auth_user_id" = ( SELECT "auth"."uid"() AS "uid")) AND (("u"."is_dpo" = true) OR ("u"."data_access_level" = ANY (ARRAY['admin'::"text", 'elevated'::"text"])))))));



ALTER TABLE "public"."gdpr_consent_records" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "gdpr_consent_records_employee_all" ON "public"."gdpr_consent_records" TO "authenticated" USING (("company_id" = "public"."get_employee_company_id"())) WITH CHECK (("company_id" = "public"."get_employee_company_id"()));



CREATE POLICY "gdpr_consent_records_employee_select" ON "public"."gdpr_consent_records" FOR SELECT TO "authenticated" USING (("company_id" = "public"."get_employee_company_id"()));



CREATE POLICY "gdpr_consent_records_insert_client" ON "public"."gdpr_consent_records" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "processed_by") AND ("subject_email" = ("auth"."jwt"() ->> 'email'::"text"))));



ALTER TABLE "public"."gdpr_consent_requests" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "gdpr_consent_requests_company_only" ON "public"."gdpr_consent_requests" USING (((EXISTS ( SELECT 1
   FROM "public"."clients" "c"
  WHERE (("c"."id" = "gdpr_consent_requests"."client_id") AND ("c"."company_id" = "public"."get_user_company_id"())))) OR ("company_id" = "public"."get_user_company_id"())));



ALTER TABLE "public"."gdpr_processing_activities" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "gdpr_processing_activities_admin_only" ON "public"."gdpr_processing_activities" USING ((EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."auth_user_id" = ( SELECT "auth"."uid"() AS "uid")) AND (("u"."is_dpo" = true) OR ("u"."data_access_level" = ANY (ARRAY['admin'::"text", 'elevated'::"text"])))))));



ALTER TABLE "public"."global_tags" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "global_tags_delete_policy" ON "public"."global_tags" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "global_tags"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "global_tags_insert_policy" ON "public"."global_tags" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "global_tags"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "global_tags_select_policy" ON "public"."global_tags" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "global_tags"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "global_tags_update_policy" ON "public"."global_tags" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "global_tags"."company_id") AND ("cm"."status" = 'active'::"text"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."company_id" = "global_tags"."company_id") AND ("cm"."status" = 'active'::"text")))));



ALTER TABLE "public"."google_calendar_configs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."hidden_stages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."hidden_units" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "insert_own_file" ON "public"."project_files" FOR INSERT WITH CHECK (("created_by" = "auth"."uid"()));



ALTER TABLE "public"."integrations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."invoice_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "invoice_items_delete_company" ON "public"."invoice_items" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."invoices"
  WHERE (("invoices"."id" = "invoice_items"."invoice_id") AND ("invoices"."company_id" = "public"."get_user_company_id"())))));



CREATE POLICY "invoice_items_insert_company" ON "public"."invoice_items" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."invoices"
  WHERE (("invoices"."id" = "invoice_items"."invoice_id") AND ("invoices"."company_id" = "public"."get_user_company_id"())))));



CREATE POLICY "invoice_items_select_company" ON "public"."invoice_items" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."invoices"
  WHERE (("invoices"."id" = "invoice_items"."invoice_id") AND ("invoices"."company_id" = "public"."get_user_company_id"())))));



CREATE POLICY "invoice_items_update_company" ON "public"."invoice_items" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."invoices"
  WHERE (("invoices"."id" = "invoice_items"."invoice_id") AND ("invoices"."company_id" = "public"."get_user_company_id"())))));



ALTER TABLE "public"."invoice_meta" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."invoice_payments" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "invoice_payments_delete_company" ON "public"."invoice_payments" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."invoices"
  WHERE (("invoices"."id" = "invoice_payments"."invoice_id") AND ("invoices"."company_id" = "public"."get_user_company_id"())))));



CREATE POLICY "invoice_payments_insert_company" ON "public"."invoice_payments" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."invoices"
  WHERE (("invoices"."id" = "invoice_payments"."invoice_id") AND ("invoices"."company_id" = "public"."get_user_company_id"())))));



CREATE POLICY "invoice_payments_select_company" ON "public"."invoice_payments" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."invoices"
  WHERE (("invoices"."id" = "invoice_payments"."invoice_id") AND ("invoices"."company_id" = "public"."get_user_company_id"())))));



CREATE POLICY "invoice_payments_update_company" ON "public"."invoice_payments" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."invoices"
  WHERE (("invoices"."id" = "invoice_payments"."invoice_id") AND ("invoices"."company_id" = "public"."get_user_company_id"())))));



ALTER TABLE "public"."invoice_series" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "invoice_series_delete_company" ON "public"."invoice_series" FOR DELETE USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "invoice_series_insert_company" ON "public"."invoice_series" FOR INSERT WITH CHECK (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "invoice_series_select_company" ON "public"."invoice_series" FOR SELECT USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "invoice_series_update_company" ON "public"."invoice_series" FOR UPDATE USING (("company_id" = "public"."get_user_company_id"())) WITH CHECK (("company_id" = "public"."get_user_company_id"()));



ALTER TABLE "public"."invoice_templates" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "invoice_templates_delete_company" ON "public"."invoice_templates" FOR DELETE USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "invoice_templates_insert_company" ON "public"."invoice_templates" FOR INSERT WITH CHECK (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "invoice_templates_select_company" ON "public"."invoice_templates" FOR SELECT USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "invoice_templates_update_company" ON "public"."invoice_templates" FOR UPDATE USING (("company_id" = "public"."get_user_company_id"())) WITH CHECK (("company_id" = "public"."get_user_company_id"()));



ALTER TABLE "public"."invoices" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "invoices_insert_policy" ON "public"."invoices" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("cm"."company_id" = "invoices"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "invoices_select_policy" ON "public"."invoices" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."id" = "invoices"."created_by") AND ("u"."auth_user_id" = "auth"."uid"())))) OR (EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."user_id" = "auth"."uid"()) AND ("cm"."company_id" = "invoices"."company_id") AND ("cm"."status" = 'active'::"text") AND (("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) OR (EXISTS ( SELECT 1
           FROM "public"."client_assignments" "ca"
          WHERE (("ca"."client_id" = "invoices"."client_id") AND ("ca"."company_member_id" = "cm"."id"))))))))));



CREATE POLICY "invoices_update_policy" ON "public"."invoices" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("cm"."company_id" = "invoices"."company_id") AND ("cm"."status" = 'active'::"text"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("cm"."company_id" = "invoices"."company_id") AND ("cm"."status" = 'active'::"text")))));



ALTER TABLE "public"."item_tags" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "item_tags_delete_policy" ON "public"."item_tags" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."global_tags" "gt"
     JOIN "public"."company_members" "cm" ON (("gt"."company_id" = "cm"."company_id")))
  WHERE (("gt"."id" = "item_tags"."tag_id") AND ("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "item_tags_insert_policy" ON "public"."item_tags" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."global_tags" "gt"
     JOIN "public"."company_members" "cm" ON (("gt"."company_id" = "cm"."company_id")))
  WHERE (("gt"."id" = "item_tags"."tag_id") AND ("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "item_tags_select_policy" ON "public"."item_tags" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."global_tags" "gt"
     JOIN "public"."company_members" "cm" ON (("gt"."company_id" = "cm"."company_id")))
  WHERE (("gt"."id" = "item_tags"."tag_id") AND ("cm"."user_id" = "public"."get_my_public_id"()) AND ("cm"."status" = 'active'::"text")))));



ALTER TABLE "public"."job_notes" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "job_notes_company_only" ON "public"."job_notes" USING (("company_id" = "public"."get_user_company_id"()));



ALTER TABLE "public"."lead_interactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."lead_sources" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."leads" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."localities" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "localities_read_all" ON "public"."localities" FOR SELECT USING (true);



CREATE POLICY "localities_update_authenticated" ON "public"."localities" FOR UPDATE USING ((( SELECT "auth"."role"() AS "role") = 'authenticated'::"text"));



CREATE POLICY "localities_write_authenticated" ON "public"."localities" FOR INSERT WITH CHECK ((( SELECT "auth"."role"() AS "role") = 'authenticated'::"text"));



ALTER TABLE "public"."loyalty_points" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mail_accounts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mail_attachments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mail_contacts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mail_folders" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mail_messages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mail_threads" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."marketing_campaigns" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "marketing_campaigns_licensed" ON "public"."marketing_campaigns" TO "authenticated" USING ((("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE (("company_members"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("company_members"."status" = 'active'::"text")))) AND "public"."company_has_module"("company_id", 'marketing'::"text"))) WITH CHECK ((("company_id" IN ( SELECT "company_members"."company_id"
   FROM "public"."company_members"
  WHERE (("company_members"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("company_members"."status" = 'active'::"text")))) AND "public"."company_has_module"("company_id", 'marketing'::"text")));



ALTER TABLE "public"."marketing_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."marketing_metrics" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."modules" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."modules_catalog" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "modules_catalog_read_authenticated" ON "public"."modules_catalog" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "modules_read_authenticated" ON "public"."modules" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."notification_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."notification_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."notifications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_integrations" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "payment_integrations_delete" ON "public"."payment_integrations" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "payment_integrations_insert" ON "public"."payment_integrations" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "payment_integrations_select" ON "public"."payment_integrations" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "payment_integrations_update" ON "public"."payment_integrations" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"]))))));



ALTER TABLE "public"."payment_transactions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "payment_transactions_select" ON "public"."payment_transactions" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "payment_transactions"."company_id") AND ("u"."active" = true)))));



ALTER TABLE "public"."pending_users" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "pending_users_access" ON "public"."pending_users" USING ((("company_id" IS NULL) OR (("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text") OR (("company_id" IS NOT NULL) AND (("auth"."jwt"() ->> 'company_id'::"text") IS NOT NULL) AND ("company_id" = (("auth"."jwt"() ->> 'company_id'::"text"))::"uuid")))) WITH CHECK ((("company_id" IS NULL) OR (("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text") OR (("company_id" IS NOT NULL) AND (("auth"."jwt"() ->> 'company_id'::"text") IS NOT NULL) AND ("company_id" = (("auth"."jwt"() ->> 'company_id'::"text"))::"uuid"))));



ALTER TABLE "public"."product_brands" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."product_catalog" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."product_categories" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."product_models" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."products" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."professional_documents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."professional_schedules" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."professional_services" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."professional_titles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."professionals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_activity" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "project_activity_insert_members" ON "public"."project_activity" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "project_activity_select_clients" ON "public"."project_activity" FOR SELECT USING (("project_id" IN ( SELECT "p"."id"
   FROM ("public"."projects" "p"
     JOIN "public"."clients" "c" ON (("p"."client_id" = "c"."id")))
  WHERE ("c"."auth_user_id" = "auth"."uid"()))));



CREATE POLICY "project_activity_select_members" ON "public"."project_activity" FOR SELECT USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



ALTER TABLE "public"."project_comments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_files" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_notification_preferences" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_permissions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_reads" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."project_stages" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "project_stages_access_policy" ON "public"."project_stages" USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"())))) WITH CHECK (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



ALTER TABLE "public"."project_tasks" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "project_tasks_access_policy" ON "public"."project_tasks" USING (("project_id" IN ( SELECT "p"."id"
   FROM "public"."projects" "p"
  WHERE ("p"."company_id" IN ( SELECT "cm"."company_id"
           FROM ("public"."company_members" "cm"
             JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
          WHERE ("u"."auth_user_id" = "auth"."uid"())))))) WITH CHECK (("project_id" IN ( SELECT "p"."id"
   FROM "public"."projects" "p"
  WHERE ("p"."company_id" IN ( SELECT "cm"."company_id"
           FROM ("public"."company_members" "cm"
             JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
          WHERE ("u"."auth_user_id" = "auth"."uid"()))))));



ALTER TABLE "public"."projects" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "projects_access_policy" ON "public"."projects" USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"())))) WITH CHECK (("company_id" IN ( SELECT "cm"."company_id"
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("u"."id" = "cm"."user_id")))
  WHERE ("u"."auth_user_id" = "auth"."uid"()))));



ALTER TABLE "public"."quote_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "quote_items_delete_policy" ON "public"."quote_items" FOR DELETE USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "quote_items_insert_policy" ON "public"."quote_items" FOR INSERT WITH CHECK (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "quote_items_select_policy" ON "public"."quote_items" FOR SELECT USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "quote_items_update_policy" ON "public"."quote_items" FOR UPDATE USING (("company_id" = "public"."get_user_company_id"())) WITH CHECK (("company_id" = "public"."get_user_company_id"()));



ALTER TABLE "public"."quote_templates" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "quote_templates_delete_policy" ON "public"."quote_templates" FOR DELETE USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "quote_templates_insert_policy" ON "public"."quote_templates" FOR INSERT WITH CHECK (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "quote_templates_select_policy" ON "public"."quote_templates" FOR SELECT USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "quote_templates_update_policy" ON "public"."quote_templates" FOR UPDATE USING (("company_id" = "public"."get_user_company_id"())) WITH CHECK (("company_id" = "public"."get_user_company_id"()));



ALTER TABLE "public"."quotes" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "quotes_delete_policy" ON "public"."quotes" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("cm"."company_id" = "quotes"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "quotes_insert_policy" ON "public"."quotes" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("cm"."company_id" = "quotes"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "quotes_select_policy" ON "public"."quotes" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."id" = "quotes"."created_by") AND ("u"."auth_user_id" = "auth"."uid"())))) OR (EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."user_id" = "auth"."uid"()) AND ("cm"."company_id" = "quotes"."company_id") AND ("cm"."status" = 'active'::"text") AND (("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) OR (EXISTS ( SELECT 1
           FROM "public"."client_assignments" "ca"
          WHERE (("ca"."client_id" = "quotes"."client_id") AND ("ca"."company_member_id" = "cm"."id"))))))))));



CREATE POLICY "quotes_update_policy" ON "public"."quotes" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("cm"."company_id" = "quotes"."company_id") AND ("cm"."status" = 'active'::"text"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "users"."id"
           FROM "public"."users"
          WHERE ("users"."auth_user_id" = "auth"."uid"()))) AND ("cm"."company_id" = "quotes"."company_id") AND ("cm"."status" = 'active'::"text")))));



ALTER TABLE "public"."resources" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."role_permissions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "role_permissions_delete_policy" ON "public"."role_permissions" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."company_id" = "role_permissions"."company_id") AND ("cm"."user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text"]))))));



CREATE POLICY "role_permissions_insert_policy" ON "public"."role_permissions" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."company_id" = "cm"."company_id") AND ("cm"."user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text"]))))));



CREATE POLICY "role_permissions_update_policy" ON "public"."role_permissions" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."app_roles" "ar" ON (("cm"."role_id" = "ar"."id")))
  WHERE (("cm"."company_id" = "role_permissions"."company_id") AND ("cm"."user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text"]))))));



ALTER TABLE "public"."rooms" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."scheduled_jobs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "scheduled_jobs_read" ON "public"."scheduled_jobs" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = ANY (ARRAY['admin'::"text", 'owner'::"text", 'super_admin'::"text"]))))));



CREATE POLICY "scheduled_jobs_service_all" ON "public"."scheduled_jobs" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "scheduled_jobs_write" ON "public"."scheduled_jobs" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



ALTER TABLE "public"."scheduled_notifications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."service_categories" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "service_categories_delete" ON "public"."service_categories" FOR DELETE USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "u"."id"
           FROM "public"."users" "u"
          WHERE ("u"."auth_user_id" = "auth"."uid"())
         LIMIT 1)) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "service_categories_insert" ON "public"."service_categories" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "cm"."company_id"
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "u"."id"
           FROM "public"."users" "u"
          WHERE ("u"."auth_user_id" = "auth"."uid"())
         LIMIT 1)) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "service_categories_select" ON "public"."service_categories" FOR SELECT USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "u"."id"
           FROM "public"."users" "u"
          WHERE ("u"."auth_user_id" = "auth"."uid"())
         LIMIT 1)) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "service_categories_update" ON "public"."service_categories" FOR UPDATE USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "u"."id"
           FROM "public"."users" "u"
          WHERE ("u"."auth_user_id" = "auth"."uid"())
         LIMIT 1)) AND ("cm"."status" = 'active'::"text"))))) WITH CHECK (("company_id" IN ( SELECT "cm"."company_id"
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "u"."id"
           FROM "public"."users" "u"
          WHERE ("u"."auth_user_id" = "auth"."uid"())
         LIMIT 1)) AND ("cm"."status" = 'active'::"text")))));



ALTER TABLE "public"."service_units" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "service_units_company_or_global" ON "public"."service_units" FOR SELECT USING ((("company_id" IS NULL) OR ("company_id" = "public"."get_user_company_id"())));



CREATE POLICY "service_units_delete_company" ON "public"."service_units" FOR DELETE USING (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "service_units_insert_company" ON "public"."service_units" FOR INSERT WITH CHECK (("company_id" = "public"."get_user_company_id"()));



CREATE POLICY "service_units_update_company" ON "public"."service_units" FOR UPDATE USING (("company_id" = "public"."get_user_company_id"()));



ALTER TABLE "public"."service_variants" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."services" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "services_delete" ON "public"."services" FOR DELETE USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "u"."id"
           FROM "public"."users" "u"
          WHERE ("u"."auth_user_id" = "auth"."uid"())
         LIMIT 1)) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "services_insert" ON "public"."services" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "cm"."company_id"
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "u"."id"
           FROM "public"."users" "u"
          WHERE ("u"."auth_user_id" = "auth"."uid"())
         LIMIT 1)) AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "services_select" ON "public"."services" FOR SELECT USING ((("company_id" = ANY ("public"."get_my_company_ids"())) OR ("is_public" = true)));



ALTER TABLE "public"."services_tags" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "services_tags_company_isolation" ON "public"."services_tags" USING (("service_id" IN ( SELECT "s"."id"
   FROM "public"."services" "s"
  WHERE ("s"."company_id" IN ( SELECT "company_members"."company_id"
           FROM "public"."company_members"
          WHERE ("company_members"."user_id" = "auth"."uid"()))))));



CREATE POLICY "services_update" ON "public"."services" FOR UPDATE USING (("company_id" IN ( SELECT "cm"."company_id"
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "u"."id"
           FROM "public"."users" "u"
          WHERE ("u"."auth_user_id" = "auth"."uid"())
         LIMIT 1)) AND ("cm"."status" = 'active'::"text"))))) WITH CHECK (("company_id" IN ( SELECT "cm"."company_id"
   FROM "public"."company_members" "cm"
  WHERE (("cm"."user_id" = ( SELECT "u"."id"
           FROM "public"."users" "u"
          WHERE ("u"."auth_user_id" = "auth"."uid"())
         LIMIT 1)) AND ("cm"."status" = 'active'::"text")))));



ALTER TABLE "public"."social_metrics" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "staff_can_view_company_tickets" ON "public"."tickets" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "tickets"."company_id") AND ("cm"."status" = 'active'::"text")))));



CREATE POLICY "staff_manage_macros" ON "public"."ticket_macros" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "ticket_macros"."company_id") AND ("u"."active" = true)))));



CREATE POLICY "staff_manage_tickets_tags" ON "public"."tickets_tags" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."tickets" "t"
     JOIN "public"."users" "u" ON (("u"."company_id" = "t"."company_id")))
  WHERE (("t"."id" = "tickets_tags"."ticket_id") AND ("u"."auth_user_id" = "auth"."uid"()) AND ("u"."active" = true)))));



CREATE POLICY "staff_view_all_company_comments" ON "public"."ticket_comments" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "ticket_comments"."company_id") AND ("u"."active" = true)))));



CREATE POLICY "staff_view_timeline" ON "public"."ticket_timeline" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."users" "u"
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "ticket_timeline"."company_id") AND ("u"."active" = true)))));



ALTER TABLE "public"."stock_movements" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."supplier_products" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."suppliers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tag_scopes" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "tag_scopes_read_authenticated" ON "public"."tag_scopes" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."ticket_comment_attachments" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ticket_comment_attachments_via_ticket" ON "public"."ticket_comment_attachments" USING ((EXISTS ( SELECT 1
   FROM ("public"."ticket_comments" "tc"
     JOIN "public"."tickets" "t" ON (("t"."id" = "tc"."ticket_id")))
  WHERE (("tc"."id" = "ticket_comment_attachments"."comment_id") AND ("t"."company_id" = "public"."get_user_company_id"())))));



ALTER TABLE "public"."ticket_comment_versions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ticket_comments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ticket_devices" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ticket_devices_company_access" ON "public"."ticket_devices" USING ((EXISTS ( SELECT 1
   FROM (("public"."tickets" "t"
     JOIN "public"."company_members" "cm" ON (("t"."company_id" = "cm"."company_id")))
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("t"."id" = "ticket_devices"."ticket_id") AND ("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM (("public"."tickets" "t"
     JOIN "public"."company_members" "cm" ON (("t"."company_id" = "cm"."company_id")))
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("t"."id" = "ticket_devices"."ticket_id") AND ("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))));



ALTER TABLE "public"."ticket_macros" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ticket_products" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ticket_services" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ticket_services_company_access" ON "public"."ticket_services" USING ((EXISTS ( SELECT 1
   FROM (("public"."tickets" "t"
     JOIN "public"."company_members" "cm" ON (("t"."company_id" = "cm"."company_id")))
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("t"."id" = "ticket_services"."ticket_id") AND ("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM (("public"."tickets" "t"
     JOIN "public"."company_members" "cm" ON (("t"."company_id" = "cm"."company_id")))
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("t"."id" = "ticket_services"."ticket_id") AND ("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."status" = 'active'::"text")))));



ALTER TABLE "public"."ticket_stages" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ticket_stages_company_only" ON "public"."ticket_stages" USING (("company_id" = "public"."get_user_company_id"()));



ALTER TABLE "public"."ticket_timeline" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tickets" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "tickets_delete_company_only" ON "public"."tickets" FOR DELETE USING ("public"."current_user_is_admin"("company_id"));



CREATE POLICY "tickets_insert_company_only" ON "public"."tickets" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."company_members" "cm"
     JOIN "public"."users" "u" ON (("cm"."user_id" = "u"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("cm"."company_id" = "tickets"."company_id") AND ("cm"."status" = 'active'::"text")))));



ALTER TABLE "public"."tickets_tags" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "tickets_update_company_only" ON "public"."tickets" FOR UPDATE USING ("public"."current_user_is_admin"("company_id"));



ALTER TABLE "public"."user_modules" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_modules_admin_write" ON "public"."user_modules" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = 'super_admin'::"text")))));



CREATE POLICY "user_modules_own_read" ON "public"."user_modules" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "users"."id"
   FROM "public"."users"
  WHERE ("users"."auth_user_id" = "auth"."uid"()))));



ALTER TABLE "public"."user_preferences" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."verifactu_cert_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "verifactu_cert_history_select_policy" ON "public"."verifactu_cert_history" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "verifactu_cert_history"."company_id") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) AND ("u"."deleted_at" IS NULL)))));



ALTER TABLE "public"."verifactu_events" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "verifactu_events_read_by_company" ON "public"."verifactu_events" FOR SELECT TO "authenticated" USING (("companyid" = "public"."get_user_company_id"()));



CREATE POLICY "verifactu_events_service_all" ON "public"."verifactu_events" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



ALTER TABLE "public"."verifactu_function_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."verifactu_invoice_meta" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "verifactu_logs_admin_access" ON "public"."verifactu_function_log" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("ar"."name" = 'super_admin'::"text")))));



ALTER TABLE "public"."verifactu_settings" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "verifactu_settings_delete_policy" ON "public"."verifactu_settings" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "verifactu_settings"."company_id") AND ("ar"."name" = 'owner'::"text") AND ("u"."deleted_at" IS NULL)))));



CREATE POLICY "verifactu_settings_insert_policy" ON "public"."verifactu_settings" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "verifactu_settings"."company_id") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) AND ("u"."deleted_at" IS NULL)))));



CREATE POLICY "verifactu_settings_select_policy" ON "public"."verifactu_settings" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "verifactu_settings"."company_id") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) AND ("u"."deleted_at" IS NULL)))));



CREATE POLICY "verifactu_settings_update_policy" ON "public"."verifactu_settings" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "verifactu_settings"."company_id") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) AND ("u"."deleted_at" IS NULL))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."users" "u"
     LEFT JOIN "public"."app_roles" "ar" ON (("u"."app_role_id" = "ar"."id")))
  WHERE (("u"."auth_user_id" = "auth"."uid"()) AND ("u"."company_id" = "verifactu_settings"."company_id") AND ("ar"."name" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'super_admin'::"text"])) AND ("u"."deleted_at" IS NULL)))));



ALTER TABLE "public"."waitlist" ENABLE ROW LEVEL SECURITY;


GRANT ALL ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";



GRANT ALL ON FUNCTION "public"."accept_company_invitation"("p_invitation_token" "text", "p_auth_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."accept_company_invitation"("p_invitation_token" "text", "p_auth_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."accept_company_invitation"("p_invitation_token" "text", "p_auth_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."accept_company_invitation_admin"("p_invitation_token" "text", "p_auth_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."accept_company_invitation_admin"("p_invitation_token" "text", "p_auth_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."accept_company_invitation_admin"("p_invitation_token" "text", "p_auth_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."accept_company_invitation_by_email"("p_email" "text", "p_auth_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."accept_company_invitation_by_email"("p_email" "text", "p_auth_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."accept_company_invitation_by_email"("p_email" "text", "p_auth_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."activate_invited_user"("auth_user_id" "uuid", "user_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."activate_invited_user"("auth_user_id" "uuid", "user_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."activate_invited_user"("auth_user_id" "uuid", "user_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."activate_recurring_service_on_payment"() TO "anon";
GRANT ALL ON FUNCTION "public"."activate_recurring_service_on_payment"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."activate_recurring_service_on_payment"() TO "service_role";



GRANT ALL ON FUNCTION "public"."add_client_note"("p_client_id" "uuid", "p_company_id" "uuid", "p_content" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_client_note"("p_client_id" "uuid", "p_company_id" "uuid", "p_content" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_client_note"("p_client_id" "uuid", "p_company_id" "uuid", "p_content" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_list_companies"() TO "anon";
GRANT ALL ON FUNCTION "public"."admin_list_companies"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_list_companies"() TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_list_company_modules"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_list_company_modules"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_list_company_modules"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_list_owners"() TO "anon";
GRANT ALL ON FUNCTION "public"."admin_list_owners"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_list_owners"() TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_list_user_modules"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_list_user_modules"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_list_user_modules"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_set_company_module"("p_target_company_id" "uuid", "p_module_key" "text", "p_status" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_set_company_module"("p_target_company_id" "uuid", "p_module_key" "text", "p_status" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_set_company_module"("p_target_company_id" "uuid", "p_module_key" "text", "p_status" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_set_user_module"("p_target_user_id" "uuid", "p_module_key" "text", "p_status" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_set_user_module"("p_target_user_id" "uuid", "p_module_key" "text", "p_status" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_set_user_module"("p_target_user_id" "uuid", "p_module_key" "text", "p_status" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_toggle_company_module"("p_company_id" "uuid", "p_module_key" "text", "p_status" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_toggle_company_module"("p_company_id" "uuid", "p_module_key" "text", "p_status" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_toggle_company_module"("p_company_id" "uuid", "p_module_key" "text", "p_status" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid", "p_reason" "text", "p_requesting_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid", "p_reason" "text", "p_requesting_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."anonymize_client_data"("p_client_id" "uuid", "p_reason" "text", "p_requesting_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."anonymize_invoice_data"() TO "anon";
GRANT ALL ON FUNCTION "public"."anonymize_invoice_data"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."anonymize_invoice_data"() TO "service_role";



GRANT ALL ON FUNCTION "public"."anonymize_quote_data"() TO "anon";
GRANT ALL ON FUNCTION "public"."anonymize_quote_data"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."anonymize_quote_data"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auth_has_permission"("p_permission" "text", "p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."auth_has_permission"("p_permission" "text", "p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."auth_has_permission"("p_permission" "text", "p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."auth_user_email"() TO "anon";
GRANT ALL ON FUNCTION "public"."auth_user_email"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auth_user_email"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_move_project_to_review"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_move_project_to_review"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_move_project_to_review"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_annual_price"("p_monthly_price" numeric, "p_discount_percentage" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_annual_price"("p_monthly_price" numeric, "p_discount_percentage" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_annual_price"("p_monthly_price" numeric, "p_discount_percentage" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_invoice_totals"("p_invoice_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_invoice_totals"("p_invoice_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_invoice_totals"("p_invoice_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_invoice_totals_payment_trigger"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_invoice_totals_payment_trigger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_invoice_totals_payment_trigger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_invoice_totals_trigger"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_invoice_totals_trigger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_invoice_totals_trigger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_quote_item_totals"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_quote_item_totals"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_quote_item_totals"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_quote_totals"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_quote_totals"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_quote_totals"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cancel_contracted_service"("p_quote_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."cancel_contracted_service"("p_quote_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cancel_contracted_service"("p_quote_id" "uuid", "p_reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."cancel_invoice"("p_invoice_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."cancel_invoice"("p_invoice_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cancel_invoice"("p_invoice_id" "uuid", "p_reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_company_exists"("p_company_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."check_company_exists"("p_company_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_company_exists"("p_company_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_gdpr_compliance"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_gdpr_compliance"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_gdpr_compliance"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_stage_coverage_after_hide"("p_company_id" "uuid", "p_stage_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."check_stage_coverage_after_hide"("p_company_id" "uuid", "p_stage_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_stage_coverage_after_hide"("p_company_id" "uuid", "p_stage_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."clean_expired_pending_users"() TO "anon";
GRANT ALL ON FUNCTION "public"."clean_expired_pending_users"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."clean_expired_pending_users"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_current_duplicates"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_current_duplicates"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_current_duplicates"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_duplicate_companies"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_duplicate_companies"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_duplicate_companies"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_expired_gdpr_data"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_expired_gdpr_data"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_expired_gdpr_data"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_pending_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_pending_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_pending_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."client_can_access_company"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."client_can_access_company"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."client_can_access_company"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."client_cancel_booking"("p_booking_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."client_cancel_booking"("p_booking_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."client_cancel_booking"("p_booking_id" "uuid", "p_reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."client_create_booking"("p_company_id" "uuid", "p_service_id" "uuid", "p_start_time" timestamp with time zone, "p_end_time" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."client_create_booking"("p_company_id" "uuid", "p_service_id" "uuid", "p_start_time" timestamp with time zone, "p_end_time" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."client_create_booking"("p_company_id" "uuid", "p_service_id" "uuid", "p_start_time" timestamp with time zone, "p_end_time" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."client_get_preferences"() TO "anon";
GRANT ALL ON FUNCTION "public"."client_get_preferences"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."client_get_preferences"() TO "service_role";



GRANT ALL ON TABLE "public"."quotes" TO "anon";
GRANT ALL ON TABLE "public"."quotes" TO "authenticated";
GRANT ALL ON TABLE "public"."quotes" TO "service_role";



GRANT ALL ON FUNCTION "public"."client_get_visible_quotes"() TO "anon";
GRANT ALL ON FUNCTION "public"."client_get_visible_quotes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."client_get_visible_quotes"() TO "service_role";



GRANT ALL ON TABLE "public"."tickets" TO "anon";
GRANT ALL ON TABLE "public"."tickets" TO "authenticated";
GRANT ALL ON TABLE "public"."tickets" TO "service_role";



GRANT ALL ON FUNCTION "public"."client_get_visible_tickets"() TO "anon";
GRANT ALL ON FUNCTION "public"."client_get_visible_tickets"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."client_get_visible_tickets"() TO "service_role";



GRANT ALL ON FUNCTION "public"."client_reschedule_booking"("p_booking_id" "uuid", "p_new_start_time" timestamp with time zone, "p_new_end_time" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."client_reschedule_booking"("p_booking_id" "uuid", "p_new_start_time" timestamp with time zone, "p_new_end_time" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."client_reschedule_booking"("p_booking_id" "uuid", "p_new_start_time" timestamp with time zone, "p_new_end_time" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."client_update_preferences"("p_email_notifications" boolean, "p_sms_notifications" boolean, "p_marketing_accepted" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."client_update_preferences"("p_email_notifications" boolean, "p_sms_notifications" boolean, "p_marketing_accepted" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."client_update_preferences"("p_email_notifications" boolean, "p_sms_notifications" boolean, "p_marketing_accepted" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."client_update_profile"("p_full_name" "text", "p_phone" "text", "p_avatar_url" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."client_update_profile"("p_full_name" "text", "p_phone" "text", "p_avatar_url" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."client_update_profile"("p_full_name" "text", "p_phone" "text", "p_avatar_url" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."column_exists"("table_name" "text", "column_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."column_exists"("table_name" "text", "column_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."column_exists"("table_name" "text", "column_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."company_has_module"("p_company_id" "uuid", "p_module_key" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."company_has_module"("p_company_id" "uuid", "p_module_key" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."company_has_module"("p_company_id" "uuid", "p_module_key" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."confirm_user_registration"("p_auth_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."confirm_user_registration"("p_auth_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."confirm_user_registration"("p_auth_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."confirm_user_registration"("p_auth_user_id" "uuid", "p_confirmation_token" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."confirm_user_registration"("p_auth_user_id" "uuid", "p_confirmation_token" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."confirm_user_registration"("p_auth_user_id" "uuid", "p_confirmation_token" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."contract_service_rpc"("p_service_id" "uuid", "p_variant_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."contract_service_rpc"("p_service_id" "uuid", "p_variant_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."contract_service_rpc"("p_service_id" "uuid", "p_variant_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."convert_quote_to_invoice"("p_quote_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."convert_quote_to_invoice"("p_quote_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."convert_quote_to_invoice"("p_quote_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."convert_quote_to_invoice"("p_quote_id" "uuid", "p_invoice_series_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."convert_quote_to_invoice"("p_quote_id" "uuid", "p_invoice_series_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."convert_quote_to_invoice"("p_quote_id" "uuid", "p_invoice_series_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."count_customers_by_user"("target_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."count_customers_by_user"("target_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."count_customers_by_user"("target_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_address_dev"("target_user_id" "uuid", "p_direccion" character varying, "p_numero" character varying, "p_piso" character varying, "p_puerta" character varying, "p_codigo_postal" character varying, "p_locality_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_address_dev"("target_user_id" "uuid", "p_direccion" character varying, "p_numero" character varying, "p_piso" character varying, "p_puerta" character varying, "p_codigo_postal" character varying, "p_locality_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_address_dev"("target_user_id" "uuid", "p_direccion" character varying, "p_numero" character varying, "p_piso" character varying, "p_puerta" character varying, "p_codigo_postal" character varying, "p_locality_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_address_rpc"("p_direccion" "text", "p_locality_id" "uuid", "p_numero" "text", "p_piso" "text", "p_puerta" "text", "p_bloque" "text", "p_escalera" "text", "p_cod_postal" "text", "p_provincia" "text", "p_pais" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_address_rpc"("p_direccion" "text", "p_locality_id" "uuid", "p_numero" "text", "p_piso" "text", "p_puerta" "text", "p_bloque" "text", "p_escalera" "text", "p_cod_postal" "text", "p_provincia" "text", "p_pais" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_address_rpc"("p_direccion" "text", "p_locality_id" "uuid", "p_numero" "text", "p_piso" "text", "p_puerta" "text", "p_bloque" "text", "p_escalera" "text", "p_cod_postal" "text", "p_provincia" "text", "p_pais" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_attachment"("p_company_id" "uuid", "p_job_id" "uuid", "p_file_name" "text", "p_file_size" integer, "p_mime_type" "text", "p_subfolder" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_attachment"("p_company_id" "uuid", "p_job_id" "uuid", "p_file_name" "text", "p_file_size" integer, "p_mime_type" "text", "p_subfolder" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_attachment"("p_company_id" "uuid", "p_job_id" "uuid", "p_file_name" "text", "p_file_size" integer, "p_mime_type" "text", "p_subfolder" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_clinical_note"("p_client_id" "uuid", "p_content" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_clinical_note"("p_client_id" "uuid", "p_content" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_clinical_note"("p_client_id" "uuid", "p_content" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_company_with_owner"("p_name" "text", "p_slug" "text", "p_nif" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_company_with_owner"("p_name" "text", "p_slug" "text", "p_nif" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_company_with_owner"("p_name" "text", "p_slug" "text", "p_nif" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" "text", "p_apellidos" "text", "p_email" "text", "p_telefono" "text", "p_dni" "text", "p_fecha_nacimiento" "date", "p_profesion" "text", "p_empresa" "text", "p_avatar_url" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" "text", "p_apellidos" "text", "p_email" "text", "p_telefono" "text", "p_dni" "text", "p_fecha_nacimiento" "date", "p_profesion" "text", "p_empresa" "text", "p_avatar_url" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" "text", "p_apellidos" "text", "p_email" "text", "p_telefono" "text", "p_dni" "text", "p_fecha_nacimiento" "date", "p_profesion" "text", "p_empresa" "text", "p_avatar_url" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying, "p_fecha_nacimiento" "date", "p_profesion" character varying, "p_empresa" character varying, "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying, "p_fecha_nacimiento" "date", "p_profesion" character varying, "p_empresa" character varying, "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_customer_dev"("target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying, "p_fecha_nacimiento" "date", "p_profesion" character varying, "p_empresa" character varying, "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_default_project_stages"("company_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_default_project_stages"("company_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_default_project_stages"("company_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_device_rpc"("p_company_id" "uuid", "p_client_id" "uuid", "p_brand" "text", "p_model" "text", "p_device_type" "text", "p_reported_issue" "text", "p_serial_number" "text", "p_password" "text", "p_imei" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_device_rpc"("p_company_id" "uuid", "p_client_id" "uuid", "p_brand" "text", "p_model" "text", "p_device_type" "text", "p_reported_issue" "text", "p_serial_number" "text", "p_password" "text", "p_imei" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_device_rpc"("p_company_id" "uuid", "p_client_id" "uuid", "p_brand" "text", "p_model" "text", "p_device_type" "text", "p_reported_issue" "text", "p_serial_number" "text", "p_password" "text", "p_imei" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_device_rpc"("p_company_id" "uuid", "p_client_id" "uuid", "p_brand" "text", "p_model" "text", "p_device_type" "text", "p_reported_issue" "text", "p_priority" "text", "p_received_at" timestamp with time zone, "p_serial_number" "text", "p_imei" "text", "p_color" "text", "p_condition_on_arrival" "text", "p_operating_system" "text", "p_storage_capacity" "text", "p_estimated_cost" numeric, "p_final_cost" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."create_device_rpc"("p_company_id" "uuid", "p_client_id" "uuid", "p_brand" "text", "p_model" "text", "p_device_type" "text", "p_reported_issue" "text", "p_priority" "text", "p_received_at" timestamp with time zone, "p_serial_number" "text", "p_imei" "text", "p_color" "text", "p_condition_on_arrival" "text", "p_operating_system" "text", "p_storage_capacity" "text", "p_estimated_cost" numeric, "p_final_cost" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_device_rpc"("p_company_id" "uuid", "p_client_id" "uuid", "p_brand" "text", "p_model" "text", "p_device_type" "text", "p_reported_issue" "text", "p_priority" "text", "p_received_at" timestamp with time zone, "p_serial_number" "text", "p_imei" "text", "p_color" "text", "p_condition_on_arrival" "text", "p_operating_system" "text", "p_storage_capacity" "text", "p_estimated_cost" numeric, "p_final_cost" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_gdpr_access_request"("p_subject_email" "text", "p_request_type" "text", "p_subject_name" "text", "p_request_details" "jsonb", "p_requesting_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_gdpr_access_request"("p_subject_email" "text", "p_request_type" "text", "p_subject_name" "text", "p_request_details" "jsonb", "p_requesting_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_gdpr_access_request"("p_subject_email" "text", "p_request_type" "text", "p_subject_name" "text", "p_request_details" "jsonb", "p_requesting_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_locality_rpc"("p_name" "text", "p_postal_code" "text", "p_province" "text", "p_country" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_locality_rpc"("p_name" "text", "p_postal_code" "text", "p_province" "text", "p_country" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_locality_rpc"("p_name" "text", "p_postal_code" "text", "p_province" "text", "p_country" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_notification"("p_company_id" "uuid", "p_recipient_id" "uuid", "p_type" "text", "p_title" "text", "p_content" "text", "p_reference_id" "uuid", "p_metadata" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."create_notification"("p_company_id" "uuid", "p_recipient_id" "uuid", "p_type" "text", "p_title" "text", "p_content" "text", "p_reference_id" "uuid", "p_metadata" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_notification"("p_company_id" "uuid", "p_recipient_id" "uuid", "p_type" "text", "p_title" "text", "p_content" "text", "p_reference_id" "uuid", "p_metadata" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_notification"("p_company_id" "uuid", "p_recipient_id" "uuid", "p_type" "text", "p_reference_id" "uuid", "p_title" "text", "p_content" "text", "p_metadata" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."create_notification"("p_company_id" "uuid", "p_recipient_id" "uuid", "p_type" "text", "p_reference_id" "uuid", "p_title" "text", "p_content" "text", "p_metadata" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_notification"("p_company_id" "uuid", "p_recipient_id" "uuid", "p_type" "text", "p_reference_id" "uuid", "p_title" "text", "p_content" "text", "p_metadata" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_rectification_quote"("p_invoice_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_rectification_quote"("p_invoice_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_rectification_quote"("p_invoice_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_rectification_quote"("p_invoice_id" "uuid", "p_rectification_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_rectification_quote"("p_invoice_id" "uuid", "p_rectification_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_rectification_quote"("p_invoice_id" "uuid", "p_rectification_reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_service_variant_rpc"("p_service_id" "uuid", "p_variant_name" "text", "p_pricing" "jsonb", "p_features" "jsonb", "p_display_config" "jsonb", "p_is_active" boolean, "p_sort_order" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."create_service_variant_rpc"("p_service_id" "uuid", "p_variant_name" "text", "p_pricing" "jsonb", "p_features" "jsonb", "p_display_config" "jsonb", "p_is_active" boolean, "p_sort_order" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_service_variant_rpc"("p_service_id" "uuid", "p_variant_name" "text", "p_pricing" "jsonb", "p_features" "jsonb", "p_display_config" "jsonb", "p_is_active" boolean, "p_sort_order" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_ticket"("p_company_id" "uuid", "p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_due_date" timestamp with time zone, "p_stage_id" "uuid", "p_assigned_to" "uuid", "p_initial_comment" "text", "p_initial_attachment_url" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_products" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."create_ticket"("p_company_id" "uuid", "p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_due_date" timestamp with time zone, "p_stage_id" "uuid", "p_assigned_to" "uuid", "p_initial_comment" "text", "p_initial_attachment_url" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_products" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_ticket"("p_company_id" "uuid", "p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_due_date" timestamp with time zone, "p_stage_id" "uuid", "p_assigned_to" "uuid", "p_initial_comment" "text", "p_initial_attachment_url" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_products" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_ticket_rpc"("p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_stage_id" "uuid", "p_ticket_type" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_custom_fields" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."create_ticket_rpc"("p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_stage_id" "uuid", "p_ticket_type" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_custom_fields" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_ticket_rpc"("p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_stage_id" "uuid", "p_ticket_type" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_custom_fields" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_ticket_rpc"("p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_stage_id" "uuid", "p_ticket_type" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_custom_fields" "jsonb", "p_due_date" timestamp with time zone, "p_estimated_hours" numeric, "p_total_amount" numeric, "p_ticket_address" "text", "p_ticket_contact_name" "text", "p_ticket_contact_email" "text", "p_ticket_contact_phone" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_ticket_rpc"("p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_stage_id" "uuid", "p_ticket_type" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_custom_fields" "jsonb", "p_due_date" timestamp with time zone, "p_estimated_hours" numeric, "p_total_amount" numeric, "p_ticket_address" "text", "p_ticket_contact_name" "text", "p_ticket_contact_email" "text", "p_ticket_contact_phone" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_ticket_rpc"("p_client_id" "uuid", "p_title" "text", "p_description" "text", "p_priority" "text", "p_stage_id" "uuid", "p_ticket_type" "text", "p_device_id" "uuid", "p_services" "jsonb", "p_custom_fields" "jsonb", "p_due_date" timestamp with time zone, "p_estimated_hours" numeric, "p_total_amount" numeric, "p_ticket_address" "text", "p_ticket_contact_name" "text", "p_ticket_contact_email" "text", "p_ticket_contact_phone" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."current_company_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."current_company_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."current_company_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."current_user_is_admin"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."current_user_is_admin"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."current_user_is_admin"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."debug_admin_access"() TO "anon";
GRANT ALL ON FUNCTION "public"."debug_admin_access"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."debug_admin_access"() TO "service_role";



GRANT ALL ON FUNCTION "public"."debug_auth_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."debug_auth_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."debug_auth_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."debug_client_modules"("p_auth_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."debug_client_modules"("p_auth_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."debug_client_modules"("p_auth_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_customer_dev"("client_id" "uuid", "target_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."delete_customer_dev"("client_id" "uuid", "target_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_customer_dev"("client_id" "uuid", "target_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_stage_safe_rpc"("p_stage_id" "uuid", "p_reassign_to" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."delete_stage_safe_rpc"("p_stage_id" "uuid", "p_reassign_to" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_stage_safe_rpc"("p_stage_id" "uuid", "p_reassign_to" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."enqueue_verifactu_dispatch"("pinvoiceid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."enqueue_verifactu_dispatch"("pinvoiceid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."enqueue_verifactu_dispatch"("pinvoiceid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."enqueue_verifactu_dispatch"("pinvoice_id" "uuid", "pcompany_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."enqueue_verifactu_dispatch"("pinvoice_id" "uuid", "pcompany_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."enqueue_verifactu_dispatch"("pinvoice_id" "uuid", "pcompany_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."ensure_all_companies"() TO "anon";
GRANT ALL ON FUNCTION "public"."ensure_all_companies"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."ensure_all_companies"() TO "service_role";



GRANT ALL ON FUNCTION "public"."ensure_min_one_stage_per_category"() TO "anon";
GRANT ALL ON FUNCTION "public"."ensure_min_one_stage_per_category"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."ensure_min_one_stage_per_category"() TO "service_role";



GRANT ALL ON FUNCTION "public"."export_client_gdpr_data"("p_client_id" "uuid", "p_requesting_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."export_client_gdpr_data"("p_client_id" "uuid", "p_requesting_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."export_client_gdpr_data"("p_client_id" "uuid", "p_requesting_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_analytics_occupancy_heatmap"("p_company_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."f_analytics_occupancy_heatmap"("p_company_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_analytics_occupancy_heatmap"("p_company_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."f_analytics_revenue_forecast"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."f_analytics_revenue_forecast"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_analytics_revenue_forecast"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_analytics_top_performers"("p_company_id" "uuid", "p_month_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_analytics_top_performers"("p_company_id" "uuid", "p_month_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_analytics_top_performers"("p_company_id" "uuid", "p_month_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_analytics_top_services"("p_start" "date", "p_end" "date", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."f_analytics_top_services"("p_start" "date", "p_end" "date", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_analytics_top_services"("p_start" "date", "p_end" "date", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."f_booking_analytics_monthly"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_booking_analytics_monthly"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_booking_analytics_monthly"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_invoice_collection_status"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_invoice_collection_status"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_invoice_collection_status"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_invoice_kpis_monthly"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_invoice_kpis_monthly"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_invoice_kpis_monthly"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_invoice_kpis_monthly_debug"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_invoice_kpis_monthly_debug"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_invoice_kpis_monthly_debug"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_invoice_kpis_monthly_temp"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_invoice_kpis_monthly_temp"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_invoice_kpis_monthly_temp"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON TABLE "public"."mail_messages" TO "anon";
GRANT ALL ON TABLE "public"."mail_messages" TO "authenticated";
GRANT ALL ON TABLE "public"."mail_messages" TO "service_role";



GRANT ALL ON FUNCTION "public"."f_mail_get_thread_messages"("p_thread_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."f_mail_get_thread_messages"("p_thread_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_mail_get_thread_messages"("p_thread_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_mail_get_thread_messages"("p_thread_id" "uuid", "p_account_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."f_mail_get_thread_messages"("p_thread_id" "uuid", "p_account_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_mail_get_thread_messages"("p_thread_id" "uuid", "p_account_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_name" "text", "p_limit" integer, "p_offset" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_name" "text", "p_limit" integer, "p_offset" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_name" "text", "p_limit" integer, "p_offset" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_role" "text", "p_limit" integer, "p_offset" integer, "p_search" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_role" "text", "p_limit" integer, "p_offset" integer, "p_search" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_role" "text", "p_limit" integer, "p_offset" integer, "p_search" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_id" "uuid", "p_limit" integer, "p_offset" integer, "p_search" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_id" "uuid", "p_limit" integer, "p_offset" integer, "p_search" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_mail_get_threads"("p_account_id" "uuid", "p_folder_id" "uuid", "p_limit" integer, "p_offset" integer, "p_search" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_marketing_get_audience"("p_company_id" "uuid", "p_criteria" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."f_marketing_get_audience"("p_company_id" "uuid", "p_criteria" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_marketing_get_audience"("p_company_id" "uuid", "p_criteria" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_marketing_get_automation_audience"("p_company_id" "uuid", "p_trigger_type" "public"."campaign_trigger_type", "p_config" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."f_marketing_get_automation_audience"("p_company_id" "uuid", "p_trigger_type" "public"."campaign_trigger_type", "p_config" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_marketing_get_automation_audience"("p_company_id" "uuid", "p_trigger_type" "public"."campaign_trigger_type", "p_config" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_quote_cube"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_quote_cube"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_quote_cube"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_quote_kpis_monthly"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_quote_kpis_monthly"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_quote_kpis_monthly"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_quote_kpis_monthly_enhanced"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_quote_kpis_monthly_enhanced"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_quote_kpis_monthly_enhanced"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_quote_pipeline_current"() TO "anon";
GRANT ALL ON FUNCTION "public"."f_quote_pipeline_current"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_quote_pipeline_current"() TO "service_role";



GRANT ALL ON FUNCTION "public"."f_quote_projected_revenue"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_quote_projected_revenue"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_quote_projected_revenue"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_quote_recurring_monthly"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_quote_recurring_monthly"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_quote_recurring_monthly"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."f_quote_top_items_monthly"("p_start" "date", "p_end" "date", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."f_quote_top_items_monthly"("p_start" "date", "p_end" "date", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_quote_top_items_monthly"("p_start" "date", "p_end" "date", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."f_refresh_analytics_views"() TO "anon";
GRANT ALL ON FUNCTION "public"."f_refresh_analytics_views"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_refresh_analytics_views"() TO "service_role";



GRANT ALL ON FUNCTION "public"."f_ticket_current_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."f_ticket_current_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_ticket_current_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."f_ticket_kpis_monthly"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."f_ticket_kpis_monthly"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."f_ticket_kpis_monthly"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."finalize_invoice"("p_invoice_id" "uuid", "p_series" "text", "p_device_id" "text", "p_software_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."finalize_invoice"("p_invoice_id" "uuid", "p_series" "text", "p_device_id" "text", "p_software_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."finalize_invoice"("p_invoice_id" "uuid", "p_series" "text", "p_device_id" "text", "p_software_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."fix_bet_drop_link"() TO "anon";
GRANT ALL ON FUNCTION "public"."fix_bet_drop_link"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fix_bet_drop_link"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_invoice_immutable_after_issue"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_invoice_immutable_after_issue"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_invoice_immutable_after_issue"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_is_variant_visible"("p_variant_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."fn_is_variant_visible"("p_variant_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_is_variant_visible"("p_variant_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_ticket_comments_maintain_integrity"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_ticket_comments_maintain_integrity"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_ticket_comments_maintain_integrity"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_touch_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_touch_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_touch_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_verifactu_settings_enforce_modes"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_verifactu_settings_enforce_modes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_verifactu_settings_enforce_modes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."gdpr_accept_consent"("p_token" "text", "p_preferences" "jsonb", "p_evidence" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."gdpr_accept_consent"("p_token" "text", "p_preferences" "jsonb", "p_evidence" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gdpr_accept_consent"("p_token" "text", "p_preferences" "jsonb", "p_evidence" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."gdpr_anonymize_client"("client_id" "uuid", "requesting_user_id" "uuid", "anonymization_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."gdpr_anonymize_client"("client_id" "uuid", "requesting_user_id" "uuid", "anonymization_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gdpr_anonymize_client"("client_id" "uuid", "requesting_user_id" "uuid", "anonymization_reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."gdpr_audit_clients_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."gdpr_audit_clients_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."gdpr_audit_clients_changes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."gdpr_audit_clients_trigger"() TO "anon";
GRANT ALL ON FUNCTION "public"."gdpr_audit_clients_trigger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."gdpr_audit_clients_trigger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."gdpr_audit_trigger"() TO "anon";
GRANT ALL ON FUNCTION "public"."gdpr_audit_trigger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."gdpr_audit_trigger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."gdpr_create_consent_request"("p_client_id" "uuid", "p_subject_email" "text", "p_consent_types" "text"[], "p_purpose" "text", "p_expires" interval) TO "anon";
GRANT ALL ON FUNCTION "public"."gdpr_create_consent_request"("p_client_id" "uuid", "p_subject_email" "text", "p_consent_types" "text"[], "p_purpose" "text", "p_expires" interval) TO "authenticated";
GRANT ALL ON FUNCTION "public"."gdpr_create_consent_request"("p_client_id" "uuid", "p_subject_email" "text", "p_consent_types" "text"[], "p_purpose" "text", "p_expires" interval) TO "service_role";



GRANT ALL ON FUNCTION "public"."gdpr_decline_consent"("p_token" "text", "p_evidence" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."gdpr_decline_consent"("p_token" "text", "p_evidence" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gdpr_decline_consent"("p_token" "text", "p_evidence" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."gdpr_export_client_data"("client_email" "text", "requesting_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."gdpr_export_client_data"("client_email" "text", "requesting_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gdpr_export_client_data"("client_email" "text", "requesting_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."gdpr_get_consent_request"("p_token" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."gdpr_get_consent_request"("p_token" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gdpr_get_consent_request"("p_token" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."gdpr_log_access"("user_id" "uuid", "company_id" "uuid", "action_type" "text", "table_name" "text", "record_id" "uuid", "subject_email" "text", "purpose" "text", "old_values" "jsonb", "new_values" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."gdpr_log_access"("user_id" "uuid", "company_id" "uuid", "action_type" "text", "table_name" "text", "record_id" "uuid", "subject_email" "text", "purpose" "text", "old_values" "jsonb", "new_values" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gdpr_log_access"("user_id" "uuid", "company_id" "uuid", "action_type" "text", "table_name" "text", "record_id" "uuid", "subject_email" "text", "purpose" "text", "old_values" "jsonb", "new_values" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_file_path"("company_uuid" "uuid", "file_name" "text", "subfolder" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_file_path"("company_uuid" "uuid", "file_name" "text", "subfolder" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_file_path"("company_uuid" "uuid", "file_name" "text", "subfolder" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_verifactu_hash"("p_invoice_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_verifactu_hash"("p_invoice_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_verifactu_hash"("p_invoice_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_addresses_dev"("target_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_addresses_dev"("target_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_addresses_dev"("target_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_all_companies_stats"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_all_companies_stats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_all_companies_stats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_all_users_with_customers"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_all_users_with_customers"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_all_users_with_customers"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_availability_data"("p_company_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."get_availability_data"("p_company_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_availability_data"("p_company_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_booking_config"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_booking_config"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_booking_config"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_client_clinical_notes"("p_client_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_client_clinical_notes"("p_client_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_client_clinical_notes"("p_client_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_client_consent_request"("p_token" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_client_consent_request"("p_token" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_client_consent_request"("p_token" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_client_consent_status"("p_client_id" "uuid", "p_requesting_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_client_consent_status"("p_client_id" "uuid", "p_requesting_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_client_consent_status"("p_client_id" "uuid", "p_requesting_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_client_invoices_rpc"("p_invoice_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_client_invoices_rpc"("p_invoice_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_client_invoices_rpc"("p_invoice_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_client_notes"("p_client_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_client_notes"("p_client_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_client_notes"("p_client_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_client_quotes_rpc"("p_quote_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_client_quotes_rpc"("p_quote_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_client_quotes_rpc"("p_quote_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_company_config_stages"("p_expected_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_company_config_stages"("p_expected_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_company_config_stages"("p_expected_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_company_config_units"("p_expected_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_company_config_units"("p_expected_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_company_config_units"("p_expected_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_company_id_from_jwt"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_company_id_from_jwt"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_company_id_from_jwt"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_company_invitation_token"("p_invitation_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_company_invitation_token"("p_invitation_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_company_invitation_token"("p_invitation_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_company_schedule"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_company_schedule"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_company_schedule"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_company_services_with_variants"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_company_services_with_variants"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_company_services_with_variants"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_config_stages"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_config_stages"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_config_stages"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_config_units"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_config_units"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_config_units"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_customer_stats"("user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_customer_stats"("user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_customer_stats"("user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_customer_stats_dev"("target_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_customer_stats_dev"("target_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_customer_stats_dev"("target_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_customers_dev"("target_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_customers_dev"("target_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_customers_dev"("target_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_daily_revenue"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_daily_revenue"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_daily_revenue"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_devices_stats"("company_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_devices_stats"("company_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_devices_stats"("company_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_devices_with_client_info"("company_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_devices_with_client_info"("company_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_devices_with_client_info"("company_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_effective_modules"("p_input_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_effective_modules"("p_input_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_effective_modules"("p_input_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_effective_role_id"("p_company_id" "uuid", "p_auth_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_effective_role_id"("p_company_id" "uuid", "p_auth_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_effective_role_id"("p_company_id" "uuid", "p_auth_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_employee_company_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_employee_company_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_employee_company_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_job_attachments"("p_job_id" "uuid", "p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_job_attachments"("p_job_id" "uuid", "p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_job_attachments"("p_job_id" "uuid", "p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_my_company_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_my_company_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_my_company_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_my_company_ids"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_my_company_ids"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_my_company_ids"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_my_public_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_my_public_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_my_public_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_next_invoice_number"("p_series_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_next_invoice_number"("p_series_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_next_invoice_number"("p_series_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_next_quote_number"("p_company_id" "uuid", "p_year" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_next_quote_number"("p_company_id" "uuid", "p_year" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_next_quote_number"("p_company_id" "uuid", "p_year" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_next_ticket_number"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_next_ticket_number"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_next_ticket_number"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_or_create_brand"("p_brand_name" "text", "p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_or_create_brand"("p_brand_name" "text", "p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_or_create_brand"("p_brand_name" "text", "p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_or_create_category"("p_category_name" "text", "p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_or_create_category"("p_category_name" "text", "p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_or_create_category"("p_category_name" "text", "p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_provider_tokens"("provider_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_provider_tokens"("provider_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_provider_tokens"("provider_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_revenue_by_professional"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_revenue_by_professional"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_revenue_by_professional"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_revenue_by_service"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_revenue_by_service"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_revenue_by_service"("start_date" timestamp with time zone, "end_date" timestamp with time zone, "p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_service_with_variants"("p_service_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_service_with_variants"("p_service_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_service_with_variants"("p_service_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_sessions_with_booking_counts"("p_start_date" "date", "p_end_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_sessions_with_booking_counts"("p_start_date" "date", "p_end_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_sessions_with_booking_counts"("p_start_date" "date", "p_end_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_ticket_stats"("target_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_ticket_stats"("target_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_ticket_stats"("target_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_top_products"("limit_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_top_products"("limit_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_top_products"("limit_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_top_tags"("limit_count" integer, "search_scope" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_top_tags"("limit_count" integer, "search_scope" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_top_tags"("limit_count" integer, "search_scope" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_top_used_products"("target_company_id" "uuid", "limit_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_top_used_products"("target_company_id" "uuid", "limit_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_top_used_products"("target_company_id" "uuid", "limit_count" integer) TO "service_role";



GRANT ALL ON TABLE "public"."services" TO "anon";
GRANT ALL ON TABLE "public"."services" TO "authenticated";
GRANT ALL ON TABLE "public"."services" TO "service_role";



GRANT ALL ON FUNCTION "public"."get_top_used_services"("target_company_id" "uuid", "limit_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_top_used_services"("target_company_id" "uuid", "limit_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_top_used_services"("target_company_id" "uuid", "limit_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_company_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_company_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_company_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_permissions"("user_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_permissions"("user_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_permissions"("user_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_permissions"("p_user_id" "uuid", "p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_permissions"("p_user_id" "uuid", "p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_permissions"("p_user_id" "uuid", "p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_role"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_role"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_role"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_verifactu_cert_status"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_verifactu_cert_status"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_verifactu_cert_status"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_verifactu_settings_for_company"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_verifactu_settings_for_company"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_verifactu_settings_for_company"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_auth_audit"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_auth_audit"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_auth_audit"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_comment_notifications"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_comment_notifications"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_comment_notifications"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_company_registration"("p_auth_user_id" "uuid", "p_email" "text", "p_full_name" "text", "p_company_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."handle_company_registration"("p_auth_user_id" "uuid", "p_email" "text", "p_full_name" "text", "p_company_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_company_registration"("p_auth_user_id" "uuid", "p_email" "text", "p_full_name" "text", "p_company_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_gdpr_consent_notification"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_gdpr_consent_notification"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_gdpr_consent_notification"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_global_audit"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_global_audit"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_global_audit"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_auth_user_link"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_auth_user_link"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_auth_user_link"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_client_link"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_client_link"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_client_link"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_project_comment"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_project_comment"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_project_comment"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user_link"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_link"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_link"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user_registration"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_registration"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_registration"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_project_auto_move"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_project_auto_move"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_project_auto_move"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_ticket_assignment_notification"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_ticket_assignment_notification"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_ticket_assignment_notification"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_ticket_audit_log"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_ticket_audit_log"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_ticket_audit_log"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_ticket_auto_assignment"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_ticket_auto_assignment"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_ticket_auto_assignment"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_ticket_comment_automation"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_ticket_comment_automation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_ticket_comment_automation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_ticket_comment_notification"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_ticket_comment_notification"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_ticket_comment_notification"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_ticket_critical_notification"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_ticket_critical_notification"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_ticket_critical_notification"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_ticket_first_response"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_ticket_first_response"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_ticket_first_response"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_ticket_notifications"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_ticket_notifications"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_ticket_notifications"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_ticket_soft_delete"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_ticket_soft_delete"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_ticket_soft_delete"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_ticket_state_transition"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_ticket_state_transition"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_ticket_state_transition"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_verifactu_voiding"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_verifactu_voiding"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_verifactu_voiding"() TO "service_role";



GRANT ALL ON FUNCTION "public"."has_company_permission"("p_company_id" "uuid", "p_roles" "text"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."has_company_permission"("p_company_id" "uuid", "p_roles" "text"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."has_company_permission"("p_company_id" "uuid", "p_roles" "text"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."initialize_mail_account_folders"("p_account_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."initialize_mail_account_folders"("p_account_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."initialize_mail_account_folders"("p_account_id" "uuid") TO "service_role";



GRANT ALL ON TABLE "public"."addresses" TO "anon";
GRANT ALL ON TABLE "public"."addresses" TO "authenticated";
GRANT ALL ON TABLE "public"."addresses" TO "service_role";



GRANT ALL ON FUNCTION "public"."insert_or_get_address"("p_direccion" "text", "p_locality_id" "uuid", "p_numero" "text", "p_usuario_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."insert_or_get_address"("p_direccion" "text", "p_locality_id" "uuid", "p_numero" "text", "p_usuario_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."insert_or_get_address"("p_direccion" "text", "p_locality_id" "uuid", "p_numero" "text", "p_usuario_id" "uuid") TO "service_role";



GRANT ALL ON TABLE "public"."localities" TO "anon";
GRANT ALL ON TABLE "public"."localities" TO "authenticated";
GRANT ALL ON TABLE "public"."localities" TO "service_role";



GRANT ALL ON FUNCTION "public"."insert_or_get_locality"("p_name" "text", "p_province" "text", "p_country" "text", "p_postal_code" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."insert_or_get_locality"("p_name" "text", "p_province" "text", "p_country" "text", "p_postal_code" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."insert_or_get_locality"("p_name" "text", "p_province" "text", "p_country" "text", "p_postal_code" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."invite_user_to_company"("user_email" "text", "user_name" "text", "user_role" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."invite_user_to_company"("user_email" "text", "user_name" "text", "user_role" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."invite_user_to_company"("user_email" "text", "user_name" "text", "user_role" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."invite_user_to_company"("p_email" "text", "p_company_id" "uuid", "p_role" "text", "p_message" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."invite_user_to_company"("p_email" "text", "p_company_id" "uuid", "p_role" "text", "p_message" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."invite_user_to_company"("p_email" "text", "p_company_id" "uuid", "p_role" "text", "p_message" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."invite_user_to_company"("p_company_id" "uuid", "p_email" "text", "p_role" "text", "p_message" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."invite_user_to_company"("p_company_id" "uuid", "p_email" "text", "p_role" "text", "p_message" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."invite_user_to_company"("p_company_id" "uuid", "p_email" "text", "p_role" "text", "p_message" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."invite_user_to_company_debug"("user_email" "text", "user_name" "text", "user_role" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."invite_user_to_company_debug"("user_email" "text", "user_name" "text", "user_role" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."invite_user_to_company_debug"("user_email" "text", "user_name" "text", "user_role" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."invoices_immutability_guard"() TO "anon";
GRANT ALL ON FUNCTION "public"."invoices_immutability_guard"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."invoices_immutability_guard"() TO "service_role";



GRANT ALL ON FUNCTION "public"."invoke_process_recurring_quotes"() TO "anon";
GRANT ALL ON FUNCTION "public"."invoke_process_recurring_quotes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."invoke_process_recurring_quotes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_company_admin"("target_company" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_company_admin"("target_company" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_company_admin"("target_company" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_company_member"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_company_member"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_company_member"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_dev_user"("user_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."is_dev_user"("user_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_dev_user"("user_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_stage_hidden_for_company"("p_stage_id" "uuid", "p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_stage_hidden_for_company"("p_stage_id" "uuid", "p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_stage_hidden_for_company"("p_stage_id" "uuid", "p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_super_admin"("user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_super_admin"("user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_super_admin"("user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."issue_invoice_verifactu"("pinvoiceid" "uuid", "pdeviceid" "text", "psoftwareid" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."issue_invoice_verifactu"("pinvoiceid" "uuid", "pdeviceid" "text", "psoftwareid" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."issue_invoice_verifactu"("pinvoiceid" "uuid", "pdeviceid" "text", "psoftwareid" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."issue_invoice_verifactu"("pinvoiceid" "uuid", "pdeviceid" "text", "psoftwareid" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."join_company_as_member"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."join_company_as_member"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."join_company_as_member"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."link_pending_professional"() TO "anon";
GRANT ALL ON FUNCTION "public"."link_pending_professional"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."link_pending_professional"() TO "service_role";



GRANT ALL ON FUNCTION "public"."link_ticket_device"("p_ticket_id" "uuid", "p_device_id" "uuid", "p_relation_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."link_ticket_device"("p_ticket_id" "uuid", "p_device_id" "uuid", "p_relation_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."link_ticket_device"("p_ticket_id" "uuid", "p_device_id" "uuid", "p_relation_type" "text") TO "service_role";



GRANT ALL ON TABLE "public"."devices" TO "anon";
GRANT ALL ON TABLE "public"."devices" TO "authenticated";
GRANT ALL ON TABLE "public"."devices" TO "service_role";



GRANT ALL ON FUNCTION "public"."list_company_devices"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."list_company_devices"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."list_company_devices"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."list_company_devices_rpc"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."list_company_devices_rpc"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."list_company_devices_rpc"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."log_audit_event"("p_company_id" "uuid", "p_action" "text", "p_entity_type" "text", "p_entity_id" "uuid", "p_metadata" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."log_audit_event"("p_company_id" "uuid", "p_action" "text", "p_entity_type" "text", "p_entity_id" "uuid", "p_metadata" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_audit_event"("p_company_id" "uuid", "p_action" "text", "p_entity_type" "text", "p_entity_id" "uuid", "p_metadata" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."log_booking_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_booking_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_booking_changes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_device_status_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_device_status_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_device_status_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_gdpr_audit"("p_action_type" "text", "p_table_name" "text", "p_record_id" "uuid", "p_subject_email" "text", "p_purpose" "text", "p_old_values" "jsonb", "p_new_values" "jsonb", "p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."log_gdpr_audit"("p_action_type" "text", "p_table_name" "text", "p_record_id" "uuid", "p_subject_email" "text", "p_purpose" "text", "p_old_values" "jsonb", "p_new_values" "jsonb", "p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_gdpr_audit"("p_action_type" "text", "p_table_name" "text", "p_record_id" "uuid", "p_subject_email" "text", "p_purpose" "text", "p_old_values" "jsonb", "p_new_values" "jsonb", "p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."maintain_ticket_opened_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."maintain_ticket_opened_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."maintain_ticket_opened_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_client_accessed"("p_client_id" "uuid", "p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_client_accessed"("p_client_id" "uuid", "p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_client_accessed"("p_client_id" "uuid", "p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_expired_quotes"() TO "anon";
GRANT ALL ON FUNCTION "public"."mark_expired_quotes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_expired_quotes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_invoice_local_payment_rpc"("p_invoice_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_invoice_local_payment_rpc"("p_invoice_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_invoice_local_payment_rpc"("p_invoice_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_project_as_read"("p_project_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_project_as_read"("p_project_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_project_as_read"("p_project_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."match_product_catalog"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."match_product_catalog"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."match_product_catalog"("query_embedding" "public"."vector", "match_threshold" double precision, "match_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."migrate_clients_by_tenant"() TO "anon";
GRANT ALL ON FUNCTION "public"."migrate_clients_by_tenant"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."migrate_clients_by_tenant"() TO "service_role";



GRANT ALL ON FUNCTION "public"."migrate_legacy_clients"() TO "anon";
GRANT ALL ON FUNCTION "public"."migrate_legacy_clients"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."migrate_legacy_clients"() TO "service_role";



GRANT ALL ON FUNCTION "public"."migrate_legacy_users"() TO "anon";
GRANT ALL ON FUNCTION "public"."migrate_legacy_users"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."migrate_legacy_users"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_booking_notifier"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_booking_notifier"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_booking_notifier"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_owner_on_gdpr_request"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_owner_on_gdpr_request"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_owner_on_gdpr_request"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_client_consent"("p_token" "uuid", "p_marketing_consent" boolean, "p_ip" "text", "p_user_agent" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."process_client_consent"("p_token" "uuid", "p_marketing_consent" boolean, "p_ip" "text", "p_user_agent" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_client_consent"("p_token" "uuid", "p_marketing_consent" boolean, "p_ip" "text", "p_user_agent" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."process_gdpr_deletion_request"("p_request_id" "uuid", "p_approve" boolean, "p_rejection_reason" "text", "p_processing_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."process_gdpr_deletion_request"("p_request_id" "uuid", "p_approve" boolean, "p_rejection_reason" "text", "p_processing_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_gdpr_deletion_request"("p_request_id" "uuid", "p_approve" boolean, "p_rejection_reason" "text", "p_processing_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."recompute_ticket_total"("p_ticket_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."recompute_ticket_total"("p_ticket_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."recompute_ticket_total"("p_ticket_id" "uuid") TO "service_role";



GRANT ALL ON PROCEDURE "public"."refresh_analytics_materialized_views"() TO "anon";
GRANT ALL ON PROCEDURE "public"."refresh_analytics_materialized_views"() TO "authenticated";
GRANT ALL ON PROCEDURE "public"."refresh_analytics_materialized_views"() TO "service_role";



GRANT ALL ON PROCEDURE "public"."refresh_quotes_materialized_views"() TO "anon";
GRANT ALL ON PROCEDURE "public"."refresh_quotes_materialized_views"() TO "authenticated";
GRANT ALL ON PROCEDURE "public"."refresh_quotes_materialized_views"() TO "service_role";



GRANT ALL ON FUNCTION "public"."register_new_owner_from_invite"("p_invitation_token" "text", "p_company_name" "text", "p_company_nif" "text", "p_user_name" "text", "p_user_surname" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."register_new_owner_from_invite"("p_invitation_token" "text", "p_company_name" "text", "p_company_nif" "text", "p_user_name" "text", "p_user_surname" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."register_new_owner_from_invite"("p_invitation_token" "text", "p_company_name" "text", "p_company_nif" "text", "p_user_name" "text", "p_user_surname" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."reject_client_consent"("p_token" "uuid", "p_ip" "text", "p_user_agent" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."reject_client_consent"("p_token" "uuid", "p_ip" "text", "p_user_agent" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reject_client_consent"("p_token" "uuid", "p_ip" "text", "p_user_agent" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."remove_or_deactivate_client_rpc"("p_client_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."remove_or_deactivate_client_rpc"("p_client_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."remove_or_deactivate_client_rpc"("p_client_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."reorder_stages"("stage_ids" "uuid"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."reorder_stages"("stage_ids" "uuid"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."reorder_stages"("stage_ids" "uuid"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."restore_original_invoice_on_void"() TO "anon";
GRANT ALL ON FUNCTION "public"."restore_original_invoice_on_void"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."restore_original_invoice_on_void"() TO "service_role";



GRANT ALL ON FUNCTION "public"."rls_auto_enable"() TO "anon";
GRANT ALL ON FUNCTION "public"."rls_auto_enable"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."rls_auto_enable"() TO "service_role";



GRANT ALL ON FUNCTION "public"."safe_delete_ticket_stage"("p_stage_id" "uuid", "p_company_id" "uuid", "p_reassign_to" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."safe_delete_ticket_stage"("p_stage_id" "uuid", "p_company_id" "uuid", "p_reassign_to" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."safe_delete_ticket_stage"("p_stage_id" "uuid", "p_company_id" "uuid", "p_reassign_to" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."search_customers"("search_term" "text", "user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."search_customers"("search_term" "text", "user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."search_customers"("search_term" "text", "user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."search_customers_dev"("target_user_id" "uuid", "search_term" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."search_customers_dev"("target_user_id" "uuid", "search_term" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."search_customers_dev"("target_user_id" "uuid", "search_term" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_current_company_context"("company_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."set_current_company_context"("company_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_current_company_context"("company_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_initial_ticket_stage"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_initial_ticket_stage"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_initial_ticket_stage"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_invoice_month"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_invoice_month"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_invoice_month"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_quote_month"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_quote_month"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_quote_month"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_ticket_month"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_ticket_month"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_ticket_month"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_ticket_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_ticket_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_ticket_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_updated_at_ticket_products"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_updated_at_ticket_products"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_updated_at_ticket_products"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_updated_at_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_updated_at_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_updated_at_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_client_profile"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_client_profile"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_client_profile"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_gdpr_to_client_consent"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_gdpr_to_client_consent"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_gdpr_to_client_consent"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_ticket_tags_from_services"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_ticket_tags_from_services"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_ticket_tags_from_services"() TO "service_role";



GRANT ALL ON FUNCTION "public"."toggle_stage_visibility"("p_stage_id" "uuid", "p_operation" "text", "p_reassign_to" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."toggle_stage_visibility"("p_stage_id" "uuid", "p_operation" "text", "p_reassign_to" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."toggle_stage_visibility"("p_stage_id" "uuid", "p_operation" "text", "p_reassign_to" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."toggle_unit_visibility"("p_unit_id" "uuid", "p_operation" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."toggle_unit_visibility"("p_unit_id" "uuid", "p_operation" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."toggle_unit_visibility"("p_unit_id" "uuid", "p_operation" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_audit_access_requests"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_audit_access_requests"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_audit_access_requests"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_audit_consent_records"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_audit_consent_records"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_audit_consent_records"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_init_mail_folders"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_init_mail_folders"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_init_mail_folders"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_ticket_services_upsert"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_ticket_services_upsert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_ticket_services_upsert"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_update_last_accessed"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_update_last_accessed"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_update_last_accessed"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_client_consent"("p_client_id" "uuid", "p_consent_type" "text", "p_consent_given" boolean, "p_consent_method" "text", "p_consent_evidence" "jsonb", "p_updating_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."update_client_consent"("p_client_id" "uuid", "p_consent_type" "text", "p_consent_given" boolean, "p_consent_method" "text", "p_consent_evidence" "jsonb", "p_updating_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_client_consent"("p_client_id" "uuid", "p_consent_type" "text", "p_consent_given" boolean, "p_consent_method" "text", "p_consent_evidence" "jsonb", "p_updating_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_client_stats_on_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_client_stats_on_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_client_stats_on_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_company_user"("p_user_id" "uuid", "p_role" "text", "p_active" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."update_company_user"("p_user_id" "uuid", "p_role" "text", "p_active" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_company_user"("p_user_id" "uuid", "p_role" "text", "p_active" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" "text", "p_surname" "text", "p_email" "text", "p_telefono" "text", "p_dni" "text", "p_fecha_nacimiento" "date", "p_profesion" "text", "p_empresa" "text", "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid", "p_activo" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" "text", "p_surname" "text", "p_email" "text", "p_telefono" "text", "p_dni" "text", "p_fecha_nacimiento" "date", "p_profesion" "text", "p_empresa" "text", "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid", "p_activo" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" "text", "p_surname" "text", "p_email" "text", "p_telefono" "text", "p_dni" "text", "p_fecha_nacimiento" "date", "p_profesion" "text", "p_empresa" "text", "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid", "p_activo" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying, "p_fecha_nacimiento" "date", "p_profesion" character varying, "p_empresa" character varying, "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid", "p_activo" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying, "p_fecha_nacimiento" "date", "p_profesion" character varying, "p_empresa" character varying, "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid", "p_activo" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_customer_dev"("customer_id" "uuid", "target_user_id" "uuid", "p_nombre" character varying, "p_apellidos" character varying, "p_email" character varying, "p_telefono" character varying, "p_dni" character varying, "p_fecha_nacimiento" "date", "p_profesion" character varying, "p_empresa" character varying, "p_notas" "text", "p_avatar_url" "text", "p_direccion_id" "uuid", "p_activo" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."update_device_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_device_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_device_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_payment_integrations_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_payment_integrations_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_payment_integrations_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_quotes_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_quotes_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_quotes_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_service_variant_rpc"("p_variant_id" "uuid", "p_variant_name" "text", "p_pricing" "jsonb", "p_features" "jsonb", "p_display_config" "jsonb", "p_is_active" boolean, "p_sort_order" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."update_service_variant_rpc"("p_variant_id" "uuid", "p_variant_name" "text", "p_pricing" "jsonb", "p_features" "jsonb", "p_display_config" "jsonb", "p_is_active" boolean, "p_sort_order" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_service_variant_rpc"("p_variant_id" "uuid", "p_variant_name" "text", "p_pricing" "jsonb", "p_features" "jsonb", "p_display_config" "jsonb", "p_is_active" boolean, "p_sort_order" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."update_service_variants_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_service_variants_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_service_variants_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_verifactu_settings_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_verifactu_settings_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_verifactu_settings_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."upsert_client"("payload" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."upsert_client"("payload" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."upsert_client"("payload" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."upsert_client_rpc"("p_first_name" "text", "p_last_name" "text", "p_email" "text", "p_phone" "text", "p_address" "text", "p_city" "text", "p_fiscal_id" "text", "p_client_id" "uuid", "p_metadata" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."upsert_client_rpc"("p_first_name" "text", "p_last_name" "text", "p_email" "text", "p_phone" "text", "p_address" "text", "p_city" "text", "p_fiscal_id" "text", "p_client_id" "uuid", "p_metadata" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."upsert_client_rpc"("p_first_name" "text", "p_last_name" "text", "p_email" "text", "p_phone" "text", "p_address" "text", "p_city" "text", "p_fiscal_id" "text", "p_client_id" "uuid", "p_metadata" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."upsert_user_module"("p_user_id" "uuid", "p_module_key" "text", "p_status" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."upsert_user_module"("p_user_id" "uuid", "p_module_key" "text", "p_status" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."upsert_user_module"("p_user_id" "uuid", "p_module_key" "text", "p_status" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."upsert_user_module"("p_user_id" "uuid", "p_module_key" "text", "p_status" "public"."module_status") TO "anon";
GRANT ALL ON FUNCTION "public"."upsert_user_module"("p_user_id" "uuid", "p_module_key" "text", "p_status" "public"."module_status") TO "authenticated";
GRANT ALL ON FUNCTION "public"."upsert_user_module"("p_user_id" "uuid", "p_module_key" "text", "p_status" "public"."module_status") TO "service_role";



REVOKE ALL ON FUNCTION "public"."upsert_verifactu_settings"("psoftware_code" "text", "pissuer_nif" "text", "pcert_pem" "text", "pkey_pem" "text", "pkey_passphrase" "text", "penvironment" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."upsert_verifactu_settings"("psoftware_code" "text", "pissuer_nif" "text", "pcert_pem" "text", "pkey_pem" "text", "pkey_passphrase" "text", "penvironment" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."upsert_verifactu_settings"("psoftware_code" "text", "pissuer_nif" "text", "pcert_pem" "text", "pkey_pem" "text", "pkey_passphrase" "text", "penvironment" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."upsert_verifactu_settings"("psoftware_code" "text", "pissuer_nif" "text", "pcert_pem" "text", "pkey_pem" "text", "pkey_passphrase" "text", "penvironment" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."upsert_verifactu_settings"("p_company_id" "uuid", "p_software_code" "text", "p_software_name" "text", "p_software_version" "text", "p_issuer_nif" "text", "p_environment" "text", "p_is_active" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."upsert_verifactu_settings"("p_company_id" "uuid", "p_software_code" "text", "p_software_name" "text", "p_software_version" "text", "p_issuer_nif" "text", "p_environment" "text", "p_is_active" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."upsert_verifactu_settings"("p_company_id" "uuid", "p_software_code" "text", "p_software_name" "text", "p_software_version" "text", "p_issuer_nif" "text", "p_environment" "text", "p_is_active" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_file_path"("file_path" "text", "company_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."validate_file_path"("file_path" "text", "company_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_file_path"("file_path" "text", "company_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_invoice_before_issue"("pinvoiceid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."validate_invoice_before_issue"("pinvoiceid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_invoice_before_issue"("pinvoiceid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."verifactu_log_event"("pevent_type" "text", "pinvoice_id" "uuid", "pcompany_id" "uuid", "ppayload" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."verifactu_log_event"("pevent_type" "text", "pinvoice_id" "uuid", "pcompany_id" "uuid", "ppayload" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."verifactu_log_event"("pevent_type" "text", "pinvoice_id" "uuid", "pcompany_id" "uuid", "ppayload" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."verifactu_preflight_issue"("pinvoice_id" "uuid", "pdevice_id" "text", "psoftware_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."verifactu_preflight_issue"("pinvoice_id" "uuid", "pdevice_id" "text", "psoftware_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."verifactu_preflight_issue"("pinvoice_id" "uuid", "pdevice_id" "text", "psoftware_id" "text") TO "service_role";



GRANT ALL ON PROCEDURE "public"."verifactu_process_pending_events"() TO "anon";
GRANT ALL ON PROCEDURE "public"."verifactu_process_pending_events"() TO "authenticated";
GRANT ALL ON PROCEDURE "public"."verifactu_process_pending_events"() TO "service_role";



GRANT ALL ON TABLE "public"."invoices" TO "anon";
GRANT ALL ON TABLE "public"."invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."invoices" TO "service_role";



GRANT ALL ON FUNCTION "public"."verifactu_status"("i" "public"."invoices") TO "anon";
GRANT ALL ON FUNCTION "public"."verifactu_status"("i" "public"."invoices") TO "authenticated";
GRANT ALL ON FUNCTION "public"."verifactu_status"("i" "public"."invoices") TO "service_role";



GRANT ALL ON TABLE "public"."quote_items" TO "anon";
GRANT ALL ON TABLE "public"."quote_items" TO "authenticated";
GRANT ALL ON TABLE "public"."quote_items" TO "service_role";



GRANT ALL ON TABLE "public"."ticket_stages" TO "anon";
GRANT ALL ON TABLE "public"."ticket_stages" TO "authenticated";
GRANT ALL ON TABLE "public"."ticket_stages" TO "service_role";



GRANT ALL ON TABLE "public"."app_roles" TO "anon";
GRANT ALL ON TABLE "public"."app_roles" TO "authenticated";
GRANT ALL ON TABLE "public"."app_roles" TO "service_role";



GRANT ALL ON TABLE "public"."companies" TO "anon";
GRANT ALL ON TABLE "public"."companies" TO "authenticated";
GRANT ALL ON TABLE "public"."companies" TO "service_role";



GRANT ALL ON TABLE "public"."company_invitations" TO "anon";
GRANT ALL ON TABLE "public"."company_invitations" TO "authenticated";
GRANT ALL ON TABLE "public"."company_invitations" TO "service_role";



GRANT ALL ON TABLE "public"."users" TO "anon";
GRANT ALL ON TABLE "public"."users" TO "authenticated";
GRANT ALL ON TABLE "public"."users" TO "service_role";



GRANT ALL ON TABLE "public"."admin_company_analysis" TO "anon";
GRANT ALL ON TABLE "public"."admin_company_analysis" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_company_analysis" TO "service_role";



GRANT ALL ON TABLE "public"."pending_users" TO "anon";
GRANT ALL ON TABLE "public"."pending_users" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_users" TO "service_role";



GRANT ALL ON TABLE "public"."admin_pending_users" TO "anon";
GRANT ALL ON TABLE "public"."admin_pending_users" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_pending_users" TO "service_role";



GRANT ALL ON TABLE "public"."ai_usage_logs" TO "anon";
GRANT ALL ON TABLE "public"."ai_usage_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_usage_logs" TO "service_role";



GRANT ALL ON TABLE "public"."app_settings" TO "anon";
GRANT ALL ON TABLE "public"."app_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."app_settings" TO "service_role";



GRANT ALL ON TABLE "public"."attachments" TO "anon";
GRANT ALL ON TABLE "public"."attachments" TO "authenticated";
GRANT ALL ON TABLE "public"."attachments" TO "service_role";



GRANT ALL ON TABLE "public"."audit_logs" TO "anon";
GRANT ALL ON TABLE "public"."audit_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."audit_logs" TO "service_role";



GRANT ALL ON TABLE "public"."availability_exceptions" TO "anon";
GRANT ALL ON TABLE "public"."availability_exceptions" TO "authenticated";
GRANT ALL ON TABLE "public"."availability_exceptions" TO "service_role";



GRANT ALL ON TABLE "public"."availability_schedules" TO "anon";
GRANT ALL ON TABLE "public"."availability_schedules" TO "authenticated";
GRANT ALL ON TABLE "public"."availability_schedules" TO "service_role";



GRANT ALL ON TABLE "public"."booking_history" TO "anon";
GRANT ALL ON TABLE "public"."booking_history" TO "authenticated";
GRANT ALL ON TABLE "public"."booking_history" TO "service_role";



GRANT ALL ON TABLE "public"."booking_types" TO "anon";
GRANT ALL ON TABLE "public"."booking_types" TO "authenticated";
GRANT ALL ON TABLE "public"."booking_types" TO "service_role";



GRANT ALL ON TABLE "public"."bookings" TO "anon";
GRANT ALL ON TABLE "public"."bookings" TO "authenticated";
GRANT ALL ON TABLE "public"."bookings" TO "service_role";



GRANT ALL ON TABLE "public"."client_assignments" TO "anon";
GRANT ALL ON TABLE "public"."client_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."client_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."client_clinical_notes" TO "anon";
GRANT ALL ON TABLE "public"."client_clinical_notes" TO "authenticated";
GRANT ALL ON TABLE "public"."client_clinical_notes" TO "service_role";



GRANT ALL ON TABLE "public"."client_contacts" TO "anon";
GRANT ALL ON TABLE "public"."client_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."client_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."client_documents" TO "anon";
GRANT ALL ON TABLE "public"."client_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."client_documents" TO "service_role";



GRANT ALL ON TABLE "public"."client_notes" TO "anon";
GRANT ALL ON TABLE "public"."client_notes" TO "authenticated";
GRANT ALL ON TABLE "public"."client_notes" TO "service_role";



GRANT ALL ON TABLE "public"."client_portal_users" TO "anon";
GRANT ALL ON TABLE "public"."client_portal_users" TO "authenticated";
GRANT ALL ON TABLE "public"."client_portal_users" TO "service_role";



GRANT ALL ON TABLE "public"."client_variant_assignments" TO "anon";
GRANT ALL ON TABLE "public"."client_variant_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."client_variant_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."clients" TO "anon";
GRANT ALL ON TABLE "public"."clients" TO "authenticated";
GRANT ALL ON TABLE "public"."clients" TO "service_role";



GRANT ALL ON TABLE "public"."professionals" TO "anon";
GRANT ALL ON TABLE "public"."professionals" TO "authenticated";
GRANT ALL ON TABLE "public"."professionals" TO "service_role";



GRANT ALL ON TABLE "public"."client_visible_bookings" TO "anon";
GRANT ALL ON TABLE "public"."client_visible_bookings" TO "authenticated";
GRANT ALL ON TABLE "public"."client_visible_bookings" TO "service_role";



GRANT ALL ON TABLE "public"."client_visible_quotes" TO "anon";
GRANT ALL ON TABLE "public"."client_visible_quotes" TO "authenticated";
GRANT ALL ON TABLE "public"."client_visible_quotes" TO "service_role";



GRANT ALL ON TABLE "public"."client_visible_services" TO "anon";
GRANT ALL ON TABLE "public"."client_visible_services" TO "authenticated";
GRANT ALL ON TABLE "public"."client_visible_services" TO "service_role";



GRANT ALL ON TABLE "public"."client_visible_tickets" TO "anon";
GRANT ALL ON TABLE "public"."client_visible_tickets" TO "authenticated";
GRANT ALL ON TABLE "public"."client_visible_tickets" TO "service_role";



GRANT ALL ON TABLE "public"."clients_tags" TO "anon";
GRANT ALL ON TABLE "public"."clients_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."clients_tags" TO "service_role";



GRANT ALL ON TABLE "public"."company_members" TO "anon";
GRANT ALL ON TABLE "public"."company_members" TO "authenticated";
GRANT ALL ON TABLE "public"."company_members" TO "service_role";



GRANT ALL ON TABLE "public"."company_modules" TO "anon";
GRANT ALL ON TABLE "public"."company_modules" TO "authenticated";
GRANT ALL ON TABLE "public"."company_modules" TO "service_role";



GRANT ALL ON TABLE "public"."company_settings" TO "anon";
GRANT ALL ON TABLE "public"."company_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."company_settings" TO "service_role";



GRANT ALL ON TABLE "public"."company_stage_order" TO "anon";
GRANT ALL ON TABLE "public"."company_stage_order" TO "authenticated";
GRANT ALL ON TABLE "public"."company_stage_order" TO "service_role";



GRANT ALL ON TABLE "public"."company_ticket_sequences" TO "anon";
GRANT ALL ON TABLE "public"."company_ticket_sequences" TO "authenticated";
GRANT ALL ON TABLE "public"."company_ticket_sequences" TO "service_role";



GRANT ALL ON TABLE "public"."content_posts" TO "anon";
GRANT ALL ON TABLE "public"."content_posts" TO "authenticated";
GRANT ALL ON TABLE "public"."content_posts" TO "service_role";



GRANT ALL ON TABLE "public"."contract_templates" TO "anon";
GRANT ALL ON TABLE "public"."contract_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."contract_templates" TO "service_role";



GRANT ALL ON TABLE "public"."contracts" TO "anon";
GRANT ALL ON TABLE "public"."contracts" TO "authenticated";
GRANT ALL ON TABLE "public"."contracts" TO "service_role";



GRANT ALL ON TABLE "public"."coupons" TO "anon";
GRANT ALL ON TABLE "public"."coupons" TO "authenticated";
GRANT ALL ON TABLE "public"."coupons" TO "service_role";



GRANT ALL ON TABLE "public"."device_components" TO "anon";
GRANT ALL ON TABLE "public"."device_components" TO "authenticated";
GRANT ALL ON TABLE "public"."device_components" TO "service_role";



GRANT ALL ON TABLE "public"."device_media" TO "anon";
GRANT ALL ON TABLE "public"."device_media" TO "authenticated";
GRANT ALL ON TABLE "public"."device_media" TO "service_role";



GRANT ALL ON TABLE "public"."device_status_history" TO "anon";
GRANT ALL ON TABLE "public"."device_status_history" TO "authenticated";
GRANT ALL ON TABLE "public"."device_status_history" TO "service_role";



GRANT ALL ON TABLE "public"."domains" TO "anon";
GRANT ALL ON TABLE "public"."domains" TO "authenticated";
GRANT ALL ON TABLE "public"."domains" TO "service_role";



GRANT ALL ON TABLE "public"."employee_commissions_config" TO "anon";
GRANT ALL ON TABLE "public"."employee_commissions_config" TO "authenticated";
GRANT ALL ON TABLE "public"."employee_commissions_config" TO "service_role";



GRANT ALL ON TABLE "public"."employee_documents" TO "anon";
GRANT ALL ON TABLE "public"."employee_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."employee_documents" TO "service_role";



GRANT ALL ON TABLE "public"."employee_productivity_logs" TO "anon";
GRANT ALL ON TABLE "public"."employee_productivity_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."employee_productivity_logs" TO "service_role";



GRANT ALL ON TABLE "public"."employees" TO "anon";
GRANT ALL ON TABLE "public"."employees" TO "authenticated";
GRANT ALL ON TABLE "public"."employees" TO "service_role";



GRANT ALL ON TABLE "public"."gdpr_access_requests" TO "anon";
GRANT ALL ON TABLE "public"."gdpr_access_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."gdpr_access_requests" TO "service_role";



GRANT ALL ON TABLE "public"."gdpr_audit_log" TO "anon";
GRANT ALL ON TABLE "public"."gdpr_audit_log" TO "authenticated";
GRANT ALL ON TABLE "public"."gdpr_audit_log" TO "service_role";



GRANT ALL ON TABLE "public"."gdpr_breach_incidents" TO "anon";
GRANT ALL ON TABLE "public"."gdpr_breach_incidents" TO "authenticated";
GRANT ALL ON TABLE "public"."gdpr_breach_incidents" TO "service_role";



GRANT ALL ON TABLE "public"."gdpr_consent_records" TO "anon";
GRANT ALL ON TABLE "public"."gdpr_consent_records" TO "authenticated";
GRANT ALL ON TABLE "public"."gdpr_consent_records" TO "service_role";



GRANT ALL ON TABLE "public"."gdpr_consent_overview" TO "anon";
GRANT ALL ON TABLE "public"."gdpr_consent_overview" TO "authenticated";
GRANT ALL ON TABLE "public"."gdpr_consent_overview" TO "service_role";



GRANT ALL ON TABLE "public"."gdpr_consent_requests" TO "anon";
GRANT ALL ON TABLE "public"."gdpr_consent_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."gdpr_consent_requests" TO "service_role";



GRANT ALL ON TABLE "public"."gdpr_processing_activities" TO "anon";
GRANT ALL ON TABLE "public"."gdpr_processing_activities" TO "authenticated";
GRANT ALL ON TABLE "public"."gdpr_processing_activities" TO "service_role";



GRANT ALL ON TABLE "public"."gdpr_processing_inventory" TO "anon";
GRANT ALL ON TABLE "public"."gdpr_processing_inventory" TO "authenticated";
GRANT ALL ON TABLE "public"."gdpr_processing_inventory" TO "service_role";



GRANT ALL ON TABLE "public"."global_tags" TO "anon";
GRANT ALL ON TABLE "public"."global_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."global_tags" TO "service_role";



GRANT ALL ON TABLE "public"."google_calendar_configs" TO "anon";
GRANT ALL ON TABLE "public"."google_calendar_configs" TO "authenticated";
GRANT ALL ON TABLE "public"."google_calendar_configs" TO "service_role";



GRANT ALL ON TABLE "public"."hidden_stages" TO "anon";
GRANT ALL ON TABLE "public"."hidden_stages" TO "authenticated";
GRANT ALL ON TABLE "public"."hidden_stages" TO "service_role";



GRANT ALL ON TABLE "public"."hidden_units" TO "anon";
GRANT ALL ON TABLE "public"."hidden_units" TO "authenticated";
GRANT ALL ON TABLE "public"."hidden_units" TO "service_role";



GRANT ALL ON TABLE "public"."integrations" TO "anon";
GRANT ALL ON TABLE "public"."integrations" TO "authenticated";
GRANT ALL ON TABLE "public"."integrations" TO "service_role";



GRANT ALL ON TABLE "public"."invoice_items" TO "anon";
GRANT ALL ON TABLE "public"."invoice_items" TO "authenticated";
GRANT ALL ON TABLE "public"."invoice_items" TO "service_role";



GRANT ALL ON TABLE "public"."invoice_meta" TO "anon";
GRANT ALL ON TABLE "public"."invoice_meta" TO "authenticated";
GRANT ALL ON TABLE "public"."invoice_meta" TO "service_role";



GRANT ALL ON TABLE "public"."invoice_payments" TO "anon";
GRANT ALL ON TABLE "public"."invoice_payments" TO "authenticated";
GRANT ALL ON TABLE "public"."invoice_payments" TO "service_role";



GRANT ALL ON TABLE "public"."invoice_series" TO "anon";
GRANT ALL ON TABLE "public"."invoice_series" TO "authenticated";
GRANT ALL ON TABLE "public"."invoice_series" TO "service_role";



GRANT ALL ON TABLE "public"."invoice_templates" TO "anon";
GRANT ALL ON TABLE "public"."invoice_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."invoice_templates" TO "service_role";



GRANT ALL ON TABLE "public"."invoiceseries" TO "anon";
GRANT ALL ON TABLE "public"."invoiceseries" TO "authenticated";
GRANT ALL ON TABLE "public"."invoiceseries" TO "service_role";



GRANT ALL ON TABLE "public"."item_tags" TO "anon";
GRANT ALL ON TABLE "public"."item_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."item_tags" TO "service_role";



GRANT ALL ON TABLE "public"."job_notes" TO "anon";
GRANT ALL ON TABLE "public"."job_notes" TO "authenticated";
GRANT ALL ON TABLE "public"."job_notes" TO "service_role";



GRANT ALL ON TABLE "public"."lead_interactions" TO "anon";
GRANT ALL ON TABLE "public"."lead_interactions" TO "authenticated";
GRANT ALL ON TABLE "public"."lead_interactions" TO "service_role";



GRANT ALL ON TABLE "public"."lead_sources" TO "anon";
GRANT ALL ON TABLE "public"."lead_sources" TO "authenticated";
GRANT ALL ON TABLE "public"."lead_sources" TO "service_role";



GRANT ALL ON TABLE "public"."leads" TO "anon";
GRANT ALL ON TABLE "public"."leads" TO "authenticated";
GRANT ALL ON TABLE "public"."leads" TO "service_role";



GRANT ALL ON TABLE "public"."loyalty_points" TO "anon";
GRANT ALL ON TABLE "public"."loyalty_points" TO "authenticated";
GRANT ALL ON TABLE "public"."loyalty_points" TO "service_role";



GRANT ALL ON TABLE "public"."mail_accounts" TO "anon";
GRANT ALL ON TABLE "public"."mail_accounts" TO "authenticated";
GRANT ALL ON TABLE "public"."mail_accounts" TO "service_role";



GRANT ALL ON TABLE "public"."mail_attachments" TO "anon";
GRANT ALL ON TABLE "public"."mail_attachments" TO "authenticated";
GRANT ALL ON TABLE "public"."mail_attachments" TO "service_role";



GRANT ALL ON TABLE "public"."mail_contacts" TO "anon";
GRANT ALL ON TABLE "public"."mail_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."mail_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."mail_folders" TO "anon";
GRANT ALL ON TABLE "public"."mail_folders" TO "authenticated";
GRANT ALL ON TABLE "public"."mail_folders" TO "service_role";



GRANT ALL ON TABLE "public"."mail_threads" TO "anon";
GRANT ALL ON TABLE "public"."mail_threads" TO "authenticated";
GRANT ALL ON TABLE "public"."mail_threads" TO "service_role";



GRANT ALL ON TABLE "public"."marketing_campaigns" TO "anon";
GRANT ALL ON TABLE "public"."marketing_campaigns" TO "authenticated";
GRANT ALL ON TABLE "public"."marketing_campaigns" TO "service_role";



GRANT ALL ON TABLE "public"."marketing_logs" TO "anon";
GRANT ALL ON TABLE "public"."marketing_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."marketing_logs" TO "service_role";



GRANT ALL ON TABLE "public"."marketing_metrics" TO "anon";
GRANT ALL ON TABLE "public"."marketing_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."marketing_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."modules" TO "anon";
GRANT ALL ON TABLE "public"."modules" TO "authenticated";
GRANT ALL ON TABLE "public"."modules" TO "service_role";



GRANT ALL ON TABLE "public"."modules_catalog" TO "anon";
GRANT ALL ON TABLE "public"."modules_catalog" TO "authenticated";
GRANT ALL ON TABLE "public"."modules_catalog" TO "service_role";



GRANT ALL ON TABLE "public"."notification_logs" TO "anon";
GRANT ALL ON TABLE "public"."notification_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."notification_logs" TO "service_role";



GRANT ALL ON TABLE "public"."notification_templates" TO "anon";
GRANT ALL ON TABLE "public"."notification_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."notification_templates" TO "service_role";



GRANT ALL ON TABLE "public"."notifications" TO "anon";
GRANT ALL ON TABLE "public"."notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."notifications" TO "service_role";



GRANT ALL ON TABLE "public"."payment_integrations" TO "anon";
GRANT ALL ON TABLE "public"."payment_integrations" TO "authenticated";
GRANT ALL ON TABLE "public"."payment_integrations" TO "service_role";



GRANT ALL ON TABLE "public"."payment_transactions" TO "anon";
GRANT ALL ON TABLE "public"."payment_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."payment_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."product_brands" TO "anon";
GRANT ALL ON TABLE "public"."product_brands" TO "authenticated";
GRANT ALL ON TABLE "public"."product_brands" TO "service_role";



GRANT ALL ON TABLE "public"."product_catalog" TO "anon";
GRANT ALL ON TABLE "public"."product_catalog" TO "authenticated";
GRANT ALL ON TABLE "public"."product_catalog" TO "service_role";



GRANT ALL ON TABLE "public"."product_categories" TO "anon";
GRANT ALL ON TABLE "public"."product_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."product_categories" TO "service_role";



GRANT ALL ON TABLE "public"."product_models" TO "anon";
GRANT ALL ON TABLE "public"."product_models" TO "authenticated";
GRANT ALL ON TABLE "public"."product_models" TO "service_role";



GRANT ALL ON TABLE "public"."products" TO "anon";
GRANT ALL ON TABLE "public"."products" TO "authenticated";
GRANT ALL ON TABLE "public"."products" TO "service_role";



GRANT ALL ON TABLE "public"."professional_documents" TO "anon";
GRANT ALL ON TABLE "public"."professional_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."professional_documents" TO "service_role";



GRANT ALL ON TABLE "public"."professional_schedules" TO "anon";
GRANT ALL ON TABLE "public"."professional_schedules" TO "authenticated";
GRANT ALL ON TABLE "public"."professional_schedules" TO "service_role";



GRANT ALL ON TABLE "public"."professional_services" TO "anon";
GRANT ALL ON TABLE "public"."professional_services" TO "authenticated";
GRANT ALL ON TABLE "public"."professional_services" TO "service_role";



GRANT ALL ON TABLE "public"."professional_titles" TO "anon";
GRANT ALL ON TABLE "public"."professional_titles" TO "authenticated";
GRANT ALL ON TABLE "public"."professional_titles" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."project_activity" TO "anon";
GRANT ALL ON TABLE "public"."project_activity" TO "authenticated";
GRANT ALL ON TABLE "public"."project_activity" TO "service_role";



GRANT ALL ON TABLE "public"."project_comments" TO "anon";
GRANT ALL ON TABLE "public"."project_comments" TO "authenticated";
GRANT ALL ON TABLE "public"."project_comments" TO "service_role";



GRANT ALL ON TABLE "public"."project_files" TO "anon";
GRANT ALL ON TABLE "public"."project_files" TO "authenticated";
GRANT ALL ON TABLE "public"."project_files" TO "service_role";



GRANT ALL ON TABLE "public"."project_notification_preferences" TO "anon";
GRANT ALL ON TABLE "public"."project_notification_preferences" TO "authenticated";
GRANT ALL ON TABLE "public"."project_notification_preferences" TO "service_role";



GRANT ALL ON TABLE "public"."project_permissions" TO "anon";
GRANT ALL ON TABLE "public"."project_permissions" TO "authenticated";
GRANT ALL ON TABLE "public"."project_permissions" TO "service_role";



GRANT ALL ON TABLE "public"."project_reads" TO "anon";
GRANT ALL ON TABLE "public"."project_reads" TO "authenticated";
GRANT ALL ON TABLE "public"."project_reads" TO "service_role";



GRANT ALL ON TABLE "public"."project_stages" TO "anon";
GRANT ALL ON TABLE "public"."project_stages" TO "authenticated";
GRANT ALL ON TABLE "public"."project_stages" TO "service_role";



GRANT ALL ON TABLE "public"."project_tasks" TO "anon";
GRANT ALL ON TABLE "public"."project_tasks" TO "authenticated";
GRANT ALL ON TABLE "public"."project_tasks" TO "service_role";



GRANT ALL ON TABLE "public"."projects" TO "anon";
GRANT ALL ON TABLE "public"."projects" TO "authenticated";
GRANT ALL ON TABLE "public"."projects" TO "service_role";



GRANT ALL ON TABLE "public"."quote_templates" TO "anon";
GRANT ALL ON TABLE "public"."quote_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."quote_templates" TO "service_role";



GRANT ALL ON TABLE "public"."resources" TO "anon";
GRANT ALL ON TABLE "public"."resources" TO "authenticated";
GRANT ALL ON TABLE "public"."resources" TO "service_role";



GRANT ALL ON TABLE "public"."role_permissions" TO "anon";
GRANT ALL ON TABLE "public"."role_permissions" TO "authenticated";
GRANT ALL ON TABLE "public"."role_permissions" TO "service_role";



GRANT ALL ON TABLE "public"."rooms" TO "anon";
GRANT ALL ON TABLE "public"."rooms" TO "authenticated";
GRANT ALL ON TABLE "public"."rooms" TO "service_role";



GRANT ALL ON TABLE "public"."scheduled_jobs" TO "anon";
GRANT ALL ON TABLE "public"."scheduled_jobs" TO "authenticated";
GRANT ALL ON TABLE "public"."scheduled_jobs" TO "service_role";



GRANT ALL ON TABLE "public"."scheduled_notifications" TO "anon";
GRANT ALL ON TABLE "public"."scheduled_notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."scheduled_notifications" TO "service_role";



GRANT ALL ON TABLE "public"."service_categories" TO "anon";
GRANT ALL ON TABLE "public"."service_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."service_categories" TO "service_role";



GRANT ALL ON TABLE "public"."service_units" TO "anon";
GRANT ALL ON TABLE "public"."service_units" TO "authenticated";
GRANT ALL ON TABLE "public"."service_units" TO "service_role";



GRANT ALL ON TABLE "public"."service_variants" TO "anon";
GRANT ALL ON TABLE "public"."service_variants" TO "authenticated";
GRANT ALL ON TABLE "public"."service_variants" TO "service_role";



GRANT ALL ON TABLE "public"."services_tags" TO "anon";
GRANT ALL ON TABLE "public"."services_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."services_tags" TO "service_role";



GRANT ALL ON TABLE "public"."social_metrics" TO "anon";
GRANT ALL ON TABLE "public"."social_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."social_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."stock_movements" TO "anon";
GRANT ALL ON TABLE "public"."stock_movements" TO "authenticated";
GRANT ALL ON TABLE "public"."stock_movements" TO "service_role";



GRANT ALL ON TABLE "public"."supplier_products" TO "anon";
GRANT ALL ON TABLE "public"."supplier_products" TO "authenticated";
GRANT ALL ON TABLE "public"."supplier_products" TO "service_role";



GRANT ALL ON TABLE "public"."suppliers" TO "anon";
GRANT ALL ON TABLE "public"."suppliers" TO "authenticated";
GRANT ALL ON TABLE "public"."suppliers" TO "service_role";



GRANT ALL ON TABLE "public"."tag_scopes" TO "anon";
GRANT ALL ON TABLE "public"."tag_scopes" TO "authenticated";
GRANT ALL ON TABLE "public"."tag_scopes" TO "service_role";



GRANT ALL ON TABLE "public"."ticket_comment_attachments" TO "anon";
GRANT ALL ON TABLE "public"."ticket_comment_attachments" TO "authenticated";
GRANT ALL ON TABLE "public"."ticket_comment_attachments" TO "service_role";



GRANT ALL ON TABLE "public"."ticket_comment_versions" TO "anon";
GRANT ALL ON TABLE "public"."ticket_comment_versions" TO "authenticated";
GRANT ALL ON TABLE "public"."ticket_comment_versions" TO "service_role";



GRANT ALL ON TABLE "public"."ticket_comments" TO "anon";
GRANT ALL ON TABLE "public"."ticket_comments" TO "authenticated";
GRANT ALL ON TABLE "public"."ticket_comments" TO "service_role";



GRANT ALL ON TABLE "public"."ticket_devices" TO "anon";
GRANT ALL ON TABLE "public"."ticket_devices" TO "authenticated";
GRANT ALL ON TABLE "public"."ticket_devices" TO "service_role";



GRANT ALL ON TABLE "public"."ticket_macros" TO "anon";
GRANT ALL ON TABLE "public"."ticket_macros" TO "authenticated";
GRANT ALL ON TABLE "public"."ticket_macros" TO "service_role";



GRANT ALL ON TABLE "public"."ticket_products" TO "anon";
GRANT ALL ON TABLE "public"."ticket_products" TO "authenticated";
GRANT ALL ON TABLE "public"."ticket_products" TO "service_role";



GRANT ALL ON TABLE "public"."ticket_services" TO "anon";
GRANT ALL ON TABLE "public"."ticket_services" TO "authenticated";
GRANT ALL ON TABLE "public"."ticket_services" TO "service_role";



GRANT ALL ON TABLE "public"."ticket_timeline" TO "anon";
GRANT ALL ON TABLE "public"."ticket_timeline" TO "authenticated";
GRANT ALL ON TABLE "public"."ticket_timeline" TO "service_role";



GRANT ALL ON TABLE "public"."tickets_tags" TO "anon";
GRANT ALL ON TABLE "public"."tickets_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."tickets_tags" TO "service_role";



GRANT ALL ON SEQUENCE "public"."tickets_ticket_number_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."tickets_ticket_number_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."tickets_ticket_number_seq" TO "service_role";



GRANT ALL ON TABLE "public"."user_company_context" TO "anon";
GRANT ALL ON TABLE "public"."user_company_context" TO "authenticated";
GRANT ALL ON TABLE "public"."user_company_context" TO "service_role";



GRANT ALL ON TABLE "public"."user_modules" TO "anon";
GRANT ALL ON TABLE "public"."user_modules" TO "authenticated";
GRANT ALL ON TABLE "public"."user_modules" TO "service_role";



GRANT ALL ON TABLE "public"."user_preferences" TO "anon";
GRANT ALL ON TABLE "public"."user_preferences" TO "authenticated";
GRANT ALL ON TABLE "public"."user_preferences" TO "service_role";



GRANT ALL ON TABLE "public"."users_with_company" TO "anon";
GRANT ALL ON TABLE "public"."users_with_company" TO "authenticated";
GRANT ALL ON TABLE "public"."users_with_company" TO "service_role";



GRANT ALL ON TABLE "public"."v_current_user_modules" TO "anon";
GRANT ALL ON TABLE "public"."v_current_user_modules" TO "authenticated";
GRANT ALL ON TABLE "public"."v_current_user_modules" TO "service_role";



GRANT ALL ON TABLE "public"."valid_users_view" TO "anon";
GRANT ALL ON TABLE "public"."valid_users_view" TO "authenticated";
GRANT ALL ON TABLE "public"."valid_users_view" TO "service_role";



GRANT ALL ON TABLE "public"."verifactu_cert_history" TO "anon";
GRANT ALL ON TABLE "public"."verifactu_cert_history" TO "authenticated";
GRANT ALL ON TABLE "public"."verifactu_cert_history" TO "service_role";



GRANT ALL ON TABLE "public"."verifactu_events" TO "anon";
GRANT ALL ON TABLE "public"."verifactu_events" TO "authenticated";
GRANT ALL ON TABLE "public"."verifactu_events" TO "service_role";



GRANT ALL ON TABLE "public"."verifactu_function_log" TO "anon";
GRANT ALL ON TABLE "public"."verifactu_function_log" TO "authenticated";
GRANT ALL ON TABLE "public"."verifactu_function_log" TO "service_role";



GRANT ALL ON TABLE "public"."verifactu_invoice_meta" TO "anon";
GRANT ALL ON TABLE "public"."verifactu_invoice_meta" TO "authenticated";
GRANT ALL ON TABLE "public"."verifactu_invoice_meta" TO "service_role";



GRANT ALL ON TABLE "public"."verifactu_settings" TO "anon";
GRANT ALL ON TABLE "public"."verifactu_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."verifactu_settings" TO "service_role";



GRANT ALL ON TABLE "public"."visible_stages_by_company" TO "anon";
GRANT ALL ON TABLE "public"."visible_stages_by_company" TO "authenticated";
GRANT ALL ON TABLE "public"."visible_stages_by_company" TO "service_role";



GRANT ALL ON TABLE "public"."waitlist" TO "anon";
GRANT ALL ON TABLE "public"."waitlist" TO "authenticated";
GRANT ALL ON TABLE "public"."waitlist" TO "service_role";



ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";






